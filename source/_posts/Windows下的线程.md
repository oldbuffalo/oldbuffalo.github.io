---
title: Windows下的线程
date: 2018-11-06 21:08:17
tags: 
- 操作系统
- Windows
---

## 线程介绍

进程中的执行单元，线程是最小的调度单位，进程是最小的分配资源的单元。
换言之，就是线程是进程的一部分，帮进程干事情，cpu调度的是线程，而不是进程，进程只提供一块空间。
特点:1.轻量2.可并发执行3.切换开销小4.共享进程资源，也有自己特有的线程堆栈和内核对象
因为线程共享进程的资源很多，例如进程的地址空间、打开文件、定时器、信号量、全局、静态变量等
，拥有的系统资源很少，因此很轻量，从而上下文切换的开销很小。

<!-- more -->
## 什么时候需要使用线程？

在同一个进程中，需要完成不同的工作，又不想因为某个工作阻塞而影响别的工作的时候，就将不同的工作放在不同的线程，并发的执行，这样既可以提高程序吞吐量又可以改善响应时间。

## 线程状态转换

![线程状态图](/pic/线程状态图.png)

其中可运行也称为就绪。
就绪->运行   获得cpu时间片
运行->就绪   cpu时间片耗尽
运行->阻塞 1.等待I/O操作发生2.sleep3.试图获得锁4.等待事件 
阻塞->就绪 1.I/O操作完成2.sleep时间到了3.成功获得锁4.事件触发

那么为什么不能从阻塞到运行以及就绪到阻塞呢？

## 线程构成

1.线程堆栈(函数中的局部变量和函数参数)，线程退出时释放
2.内核对象(Windows核心编程第三章有对这个概念深入的介绍)   

![线程内核对象](/pic/线程内核对象.png)

这里主要关注内核对象中的使用次数(计数器)、暂停次数(挂起计数器)、信号(已通知=FALSE)

使用次数初始值为2，线程退出时减1，关闭句柄的时候减1，为0时释放内核对象

暂停次数初始值为1，在创建线程时判断是否有挂起标志，没有的话再置为0

信号初始值为FALSE，线程退出时变为TRUE，一般用WiatForSingleObject()检测是否有信号，从而判断线程是否正常退出

## 线程的常用函数

### 创建

CreateThread和_beginthreadex     创建成功返回句柄
参数就不罗列了，有安全属性，线程栈大小，线程函数入口地址，传入参数，创建标志，线程ID

**这里着重强调一下两者的区别**(介意使用后者)
前者是Windows函数，后者是C/C++运行期库函数，主要的区别在于对于系统全局变量的影响上。
比如C运行库全局变量errno，在系统函数出错时进行赋值，如果是多线程编程，很容易造成值覆盖的问题。

```
if(/*某个系统函数调用出错*/){
	switch(errno){
        //错误处理函数
	}
}
```

假如线程A运行到if和switch之间，时间片用完了，这时候errno已经被赋值，但是还没进入switch的时候被切换掉了，此时同一进程的线程B运行时某个函数改动了errno，当线程A重新切换到运行态的时候，errno的值已经不是预想的了。因此要避免这种多线程访问修改导致数据覆盖的问题。

CreateThread没有办法解决这个问题，_beginthreadex在创建新线程时会分配并初始化一个_tiddata块。这个_tiddata块自然是用来存放一些需要线程独享的数据。事实上新线程运行时会首先将_tiddata块与自己进一步关联起来,从而接下里调用标准C运行库函数进行操作时就只会改变线程自身数据块的值。

注意点：1.通过句柄操作线程，线程退出时要记得关闭句柄
​　　　　2.无法连着两次关闭句柄
​　　　　3.创建之后关闭了句柄，线程还在，只是无法操作线程了。

### 挂起、唤醒

SuspendThread、ResumeThread
注意:1.每挂起一次，内核对象的挂起计数器就加1，为0时线程才工作，因此挂起多少次，就要唤醒对应次数
​　　 2.对于一个尚未挂起的线程进行唤醒是无用的操作。

### 死亡

1.函数返回  return   这是最好的方式
2.ExitThread   _endthreadex  最好使用后者       这两个函数只能销毁自身，释放堆栈
3.TerminateThread  强制杀死任意线程   不安全  不释放资源
4.包含线程的进程退出   

### 将线程函数作为类成员函数需要注意的问题？

要定义成静态成员变量。因为非静态成员函数都会在参数列表中加上一个this指针为为参数,线程处理函数相当于变成DWORD WINAPI ThreadFun(LPVOID, CMyClass *this) ，这和标准的线程函数就不匹配了，编译就通不过。况且，如果是非静态成员函数，不定义类对象或者指针就无法调用，一旦对象生命期结束了，难道线程函数就无法调用了？因此要脱离类本身存在，定义成静态的(相当于一个全局函数)。





