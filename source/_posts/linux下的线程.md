---
title: Linux下的线程
date: 2018-11-07 12:09:05
tags: 
- 操作系统
- Linux
---

## 线程概述

线程的一些特性和状态转换和Windows下面类似。因此就简单介绍一下，重点突出Linux下面的一些特色的地方。

1.线程是轻量级进程(light-weight process)，也有PCB(process control block)，创建线程使用的底层函数和进程一样，都是clone(具体参见进程创建过程)
2.从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB指向的内存资源的三级页表是相同的(换句话说，就是进程和线程共享某些资源，通过间接寻址，指向同一块虚拟地址空间)
3.线程就是寄存器和栈(调度单位就是寄存器和栈,保护和恢复现场)
4.线程是最小的调度单位，内核通过调度编号(LWP)去调度。（LWP---线程编号）
5.独占资源的称为进程，进程可以蜕化成主控线程。

ps -Lf pid   显示指定进程的线程信息
ps -eLf        显示所有线程

## 线程间资源共享资源

 1.文件描述符表 2.信号处理方式 3.当前工作目录(pwd)4.用户ID、组ID 
 5.内存地址空间0-3G(32位)用户地址空间:Text、Data、Bss、堆、lib

注意堆区：linux是共享堆，线程和进程指向同一块堆空间，可以设置成非共享堆，但Windows就是非共享堆，每个线程都有自己的堆空间。

## 线程间非共享资源

1.线程id 2. 处理器现场和内核栈指针(保护上下文) 3.用户空间栈 4.errno全局变量
5.阻塞信号集(屏蔽字) 6.进程调度优先级

## 线程优缺点

优点:1. 提高程序并发性2.开销小,不用重新分配内存3.通信和共享数据方便

缺点:1.线程稳定性差2.gbd调试困难3.线程使用信号比较麻烦。(虽然有同样的处理函数，但是可以对别的线程设置屏蔽字，并且信号不能调试，再加上多线程调试难度很大)

## 线程原语

Linux下采用的线程接口称为"pthread"或"POSIX线程"，采用的是NPTL库(Native POSIX Thread Library)

getconf GNU_LIBPTHREAD_VERSION   查看当前pthread库版本

使用线程库时 gcc时要指定 -lpthread

pthread_create  创建线程    注意第二个参数  线程属性一般不怎么使用(具体参见APUE  p342）
pthread_self   获取当前线程的id
pthread_join   阻塞函数   等待指定的线程退出，并回收资源，第二个参数可以获取线程退出码
pthread_detach  设置线程为分离态，一旦线程退出，内核自动回收资源。

优点:释放了主控线程，不需要再进行回收操作  缺点:无法获得退出状态了

线程在创建的时候默认是可回收态，也就是说当可回收态的线程退出时，其线程ID和退出状态将被保留，等待另一个线程调用pthread_join。一旦线程被置成分离态，再调用pthread_join就会出错

### 线程退出方式

1.return  如果是普通线程return，会回到主控线程，主控线程return，则进程终止
2.pthread_exit(void* status)    只会结束调用该函数的线程本身，不会影响其他人，推荐使用这个函数
注意点:指针status不能指向线程函数中的某个局部变量
3.exit(0) 无论哪种线程调用，都导致进程终止
4.pthread_cancel(pthread_t tid)  通过tid结束指定线程  统一退出码是-1   还能安排多个线程退出时的处理函数(APUE p316)

类似于信号杀死进程    信号处理条件(产生中断、异常、系统调用，从用户态切换到内核态，返回用户态再处理信号)，但是pthread_cancel,只有产生系统调用的时候才会检测cancel事件。可以配合空调函数pthread_testcancel()产生系统调用，但是什么事情都没做。



注意点：

1.与出错时返回-1，并置errno为某个正值的大多数系统函数不同，pthread函数出错时返回正值，不设置errno，成功返回0，由于不设置errno,因此不能用perror打印，可以用strerror把错误码转换成错误信息再打印
2.注意处理主控线程和普通线程之间的竞争关系，可以让主控线程sleep几秒，保证普通线程在主控线程退出前有充分时间运行
3.pthread_self获得的线程id和pthread_create传出的线程id是否等价？

考虑这个问题之前，先来看一下pthread_create的内部实现
1.创建线程   
2.clone  共享资源
3.传出线程id
完成前两步的时候，该线程就能被内核调用，现在假设这样一种情况，线程处理函数的工作极其短暂，在pthread_create尚未传出线程id的时候，线程就结束了。那么当线程id传出时，这个线程已经不在了。

因此区别在于pthread_self一定能保证线程是存活的，而后者可能线程已经结束了。

再考虑一种情况，假如传出的线程id是一个全局变量，在线程处理函数中打印这个全局的线程id，如果说此时线程创建函数还没有传出这个值，只是完成了前两步，那么这个全局变量就是未初始化的值，不是真正的线程id。