---
title: 高性能服务器程序框架
date: 2019-03-25 17:14:01
tags:
- 网络
- Linux高性能服务器编程
---

服务器主要可以分成三个模块

- I/O处理单元
- 逻辑单元
- 存储单元

<!--more-->

## 服务器模型

- C/S模型(客户端/服务器模型)

这种模型很好理解，服务器掌控着资源，客户端每次都需要请求服务器来获取资源。

这种模型很适合资源相对集中的场合，但是当访问量过大时，可能所有客户都将得到很慢的回应。

![](/pic/CS模型.png)

- P2P模型(点对点模型)

网络中所有的主机都是对等的地位。P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享，但是当用户之间传输的请求过多时，网络的负载将加重。

云计算机群是P2P模型的一个典范。

![](/pic/P2P1.png)

上图所示的P2P模型存在一个显著的问题，就是主机之间很难互相发现，所以实际使用的P2P模型通常带一个专门的发现服务器。发现服务器通常还提供查找服务，使得每个客户都能尽快找到自己需要的资源。

![](/pic/P2P2.png)

## I/O处理单元

- I/O模型
  - 阻塞I/O
  - 非阻塞I/O
  - I/O复用
  - 信号驱动I/O(SIGIO)
  - 异步I/O

具体参见[Linux下的网络I/O模型]()

- 两种高效的事件处理模式

服务器通常要处理三类事件：I/O事件、信号、定时事件

1.Reactor

同步I/O模型通常用于实现Reactor模式

Reactor:要求主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

![](/pic/Reactor.png)

使用同步I/O模型(epoll_wait)实现Reactor。

- 主线程往epoll内核事件表中注册socket上的读就绪事件
- 主线程调用epoll_wait等待socket上有数据可读
- 当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列
- 睡眠在请求队列上的某个工作线程被唤醒，它从socket上读取数据，并处理客户端请求，然后往epoll内核事件表中注册该socket上的写就绪事件
- 主线程调用epoll_wait等待socket可写
- 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列
- 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果

2.Proactor

异步I/O模型通常用于实现Proactor模式，同步I/O也能模拟

Proactor:将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。因此这种模式更符合一般的服务器编程框架。

![](/pic/Proactor.png)

使用异步I/O模型(aio_read和aio_write)实现Proactor模式

主线程中的epoll_wait调用仅仅用来检测监听socket上的连接请求事件，而不能检测连接socket上的读写事件。连接socket上的读写事件是通过aio_read和aio_write向内核注册的，内核通过信号向应用程序通知连接socket上的读写事件。

- 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(以信号为例)
- 主线程继续处理其他逻辑(这里体现出异步，不同于同步的阻塞)
- 当socket上的数据被读入用户缓冲区，内核将向应用程序发送一个信号，以通知应用程序数据已经可用
- 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序(以信号为例)
- 主线程继续处理其他逻辑
- 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕
- 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket



使用同步I/O模拟Proactor模式

原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一"完成事件"。那么从工作线程的角度来看，它们直接获得了数据读写的结果，只需要对读写的结果进行逻辑处理。

![](/pic/Proactor1.png)

- 主线程往epoll内核事件表中注册socket上的读就绪事件
- 主线程调用epoll_wait等待socket上有数据可读
- 当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，知道没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列
- 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket的写就绪事件
- 主线程调用epoll_wait等待socket可写
- 当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果

## 逻辑单元

- 两种高效的并发模式

并发模式：I/O处理单元和多个逻辑单元之间协调完成任务的方法

1.半同步/半异步模式

首先区分一下并发模式中的同步和异步概念

在I/O模式中，同步和异步的区别在于内核向应用程序通知的是什么类型的事件，换句话说I/O读写是由谁完成的

在并发模式中，“同步”指的程序完全按照代码序列顺序执行，"异步"指的是程序的执行需要由系统事件来驱动。常见的系统事件有中断、信号等。

下图描绘了并发模式下同步异步的区别：

![](/pic/并发模式同步异步.png)

异步线程执行效率高，实时性强，很多嵌入式程序采用的模型，但是以异步方式执行的程序相对复杂，难以调试和扩展，不适合于大量的并发。

同步线程虽然效率相对较低，实时性较差，但逻辑简单。

因此，像服务器这种既要求较好的实时性，又要求同时处理多个客户请求的应用程序，应该同时使用同步线程和异步线程相结合来实现，也就是半同步/半异步模式。

半同步/半异步模式中，同步线程用于处理客户逻辑，相当于逻辑单元，异步线程用于处理I/O事件，相当于I/O处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。

![](/pic/半同步半异步模式.png)

在服务器程序中，结合考虑两种事件处理模式和几种I/O模型，那么半同步/半异步模式存在多种变体

- 半同步/半反应堆模式

![](/pic/半同步半反应堆.png)

异步线程只有一个，由主线程充当，负责监听所有socket上的事件如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送给客户端，主线程就将该连接socket插入请求队列中。

所有的工作线程都睡眠在请求队列上，当有任务到来时，它们 将通过竞争(比如申请互斥锁)来获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务。

由于主线程插入请求队列的任务是就绪的连接socket，因此半同步/半反应堆模式采用的事件处理模式是Reactor模式，要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。

缺点：

1.主线程和工作线程共享请求队列。主线程往请求队列中添加任务或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间

2.每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，请求队列中就会堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这个问题，工作线程的切换也将消耗大量的CPU时间

- 半同步/半异步模式

![](/pic/半同步半异步.png)

主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道里有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，就把新的socket上的读写事件注册到自己的epoll内核事件表中。因此，每个工作线程都能同时处理多个客户连接。

每个线程(主线程和工作线程)都维持着自己的事件循环，它们各自独立地监听不同的事件。因此，半同步/半异步模式下，每个线程都工作在异步的模式。

2.领导者/追随者模式

领导者/追随者：多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件

在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件，而其他线程都是追随者，他们休眠在线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。

该模式主要包括：句柄集、线程集、事件处理器、具体事件处理器。

具体关系参见《Linux高性能服务器编程》P134

- 有限状态机

逻辑单元内部的一种高效编程方法。我们以一个HTTP请求的读取和分析程序来分析一下，在服务器读取HTTP请求时，如果没有利用有限状态机，就需要等读取到表示头部结束的空行才能对头部进行解析，但是用有限状态机之后可以一边接受数据一边进行分析，其效率更高。】

使用有限状态机读取和分析HTTP请求，[代码实例](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/8_chapter/HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%88%86%E6%9E%90.cpp)

模拟了正确的请求报文和错误的请求报文两种情况，发现其正常工作。

![](/pic/HTTP请求读取和分析1.png)

![](/pic/HTTP请求读取和分析2.png)

在main函数中，循环调用recv函数往buf中读入用户数据，每次成功读取数据后，交给parse_content函数来分析读入的数据。parse_content函数首先要做的是调用parse_line函数来获取完整一行，对于完整的一行根据行状态的不同调用不同的处理函数。

分析一下发现，这里面存在着两个有限状态机，分别是主状态机和从状态机，从状态机就是一个parse_line函数，负责从buf中解析出一个行，其初始状态为LINE_OK，原始驱动力来源于buf中新到达的数据，而当从状态机读取到了一个完整的行，就需要将这个行交给主状态机处理，主状态机中根据当前状态调用不同的函数对报文进行解析，从而实现状态转移。

