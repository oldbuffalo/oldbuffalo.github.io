---
title: 进程池
date: 2019-04-17 17:50:41
tags:
- Linux高性能服务器编程
- 进程
---

## 为什么需要池？

多进程的网络模型为主进程负责accept，每来一个客户端就fork出一个子进程为之服务。这种动态创建子进程(子线程)来实现并发服务器有着诸多缺点。

- 动态创建进程(或线程)比较耗费时间，会导致较慢的客户响应
- 动态创建的子进程(或子线程)通常只用来为一个客户服务(除非做特殊的处理)，这将导致系统上产生大量的细微进程(线程)。进程(线程)切换将消耗大量CPU时间
- 动态创建的子进程是当前进程的完整映像。当前进程必须谨慎管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使得系统的可用资源急剧下降，影响服务器的性能。

进程池是由服务器预先创建一组子进程。进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、pgid等。因为进程池在服务器启动之前就创建好了，所以每个子进程相对干净，即它们没有打开不必要的文件描述符，也不会错误地使用大块的堆内存。

当有新的任务来的时候，主进程将通过某种方式选择进程池中某一个子进程来为之服务。

- 主进程使用某种算法来主动选择子进程。随机算法和Round Robin(轮流选取)算法。但更优秀、更智能的算法应该考虑负载的均衡
- 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。

选择好子进程之后，主进程还需要使用某种通知机制告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是通过管道。

<!--more-->

![](/pic/进程池模型.png)

[半同步/半异步进程池实现](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/15_chapter/CGI_server.cpp)

半同步/半异步模型是主进程负责管理所有监听socket，而各个子进程分别管理属于自己的连接socket。

代码主要逻辑分析：

main函数负责进行网络的一些初始化工作，已经创建进程池，需要注意的是在创建进程池之前需要创建好监听socket，一旦进程池创建成功，调用run函数就使得父进程(程序一执行就存在，只不过发生了代码逻辑的跳转)和八个子进程同时启动，开始监听事件。

run函数区分父进程和子进程用了一个小技巧，通过循环创建进程时子进程继承过来的索引进行区分。父进程一开始初始化为-1，子进程都大于等于0。

父进程：负责监听listenfd和信号管道的fd[0]端。信号管道用于统一事件源。

- 父进程一旦监听到有新的连接到来时，通过Round Robin选择一个子进程(简单地通过m_pid是否为-1来选取)，然后就通过父子进程之间已经建立好的管道将这个事件通知给子进程。
- 父进程还会监听到信号管道发来的信号事件，根据不同的信号进行相应的处理。比较需要注意的子进程的回收，还要关闭相应的管道

子进程：负责监听父子进程通信的管道的fd[1]端，信号管道的fd[0]端和通过该子进程建立连接的confd。维护该子进程连接着的所有用户请求对象的一个数组。

- 子进程一旦监听到父进程通过管道给自己发送数据，就代表有的客户连接需要接收。调用accept接收用户连接，然后进行用户请求类的初始化
- 子进程监听到信号管道发来的信号事件，根据相应的信号进行对应的处理
- 子进程监听到已经建立连接的用户有数据请求，就调用用户请求对象的process方法

还有一个很关键的类，就是用来处理客户CGI请求的类，需要实现init方法和process方法，process方法就完成了CGI请求(创建一个子进程，用来执行CGI程序，并且将标准输出重定向到网络socket)

小技巧：子进程中需要的变量都从父进程继承了过来，并根据需要进行相应的修改也不会相互影响

扩展性：该进程池具有一定的扩展性，本次实例中process用来实现的CGI请求，但是可以根据不同的场景需要进行修改，但不会修改进程池内部源码。