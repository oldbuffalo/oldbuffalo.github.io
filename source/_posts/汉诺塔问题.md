---
title: 汉诺塔问题
date: 2018-10-04 15:48:42
tags: "算法" 
---

## 问题描述
有a,b,c三根柱子，如今柱子a上面有64个盘子(盘子大小从上到下按大小排列)
目的:将柱子a上面的盘子全部移动到柱子c上面，列出方法和次数
规则: 1. 每次只能移动一个盘子     2. 小盘子只能放在大盘子之上

这是一道很经典的题目，问题描述也很简单，用递归做起来也比较简单，但不是很好理解

![](/pic/汉诺塔.png)

## 分析
算法一直是我的软肋，尤其是涉及递归的更加不好理解(为何如此之菜，哎)
一上来碰到这种问题肯定没什么思路，机智如我就开始找规律嘛
64个太多,那就从1个开始吧。
1个 a->c 1次
2个 a->b a->c b->c 3次
3个 a->c a->b c->b a->c b->a b->c a->c  7次
这时候根据我多年找规律的经验就可以大胆地猜测 总的次数是2^n-1
那64个的话应该是2^64-1(**天文数字 根本不可能完成的任务**)
虽然猜出了次数(毫无理论依据,逃)，但是还是不知道移动的次序。

## 问题分解
从第一步开始想大概率是毫无头绪的，因为你有无数种选择。那么倒推着
想。首先假设已经成功将a柱上面的63个盘子移到了b柱，此时只要将a柱
最后一个盘子移动到c柱，这是确定的。
这时候问题就变成了，如何将b柱上63个盘子移动到c。这和之前的问题一模
一样，只不过数据规模变小了，并且是从a变到了b。因此可以采用一个的思
考方法，先将b上面的62个盘子移到a，再将最下面的盘子移到c，以此类推
就有了解决问题的一个循环的流程。
## 递归
以上的流程就是一个递归的过程。我所理解的递归就是有不断地用更小规模的
数据去求上层数据，当然必须有一个终止的时刻返回。

## 代码展示
```
def fun(n,a,b,c):  #n代表数据规模  a,b,c是三个柱子  从a->c
    if n == 1:
        print(a,'->',c)
    else:
        fun(n-1,a,c,b)  #第一步把n-1个数据从a->b
        print(a,'->',c) #第二步把第n个数组从a->c
        fun(n-1,b,a,c)  #这时候问题规模下降1 变成n-1个数从b->c的问题
```

## 拓展
我们知道绝大多数的递归都能用循环来写，这里有一种循环方式实现的方法，代码过长
这里就不贴出来了，[链接](http://tieba.baidu.com/f?kz=1255166419)

## 总结
其实就是想发篇博客练一下warkdown语法的，但是被各种空格，对齐方式所折磨。
算法很捉急，这算是个开头吧。





