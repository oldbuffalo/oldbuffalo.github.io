{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/timg.jpg","path":"timg.jpg","modified":0,"renderable":0},{"_id":"source/pic/5种IO模型的比较.png","path":"pic/5种IO模型的比较.png","modified":0,"renderable":0},{"_id":"source/pic/ARP命令1.png","path":"pic/ARP命令1.png","modified":0,"renderable":0},{"_id":"source/pic/CGI调试1.png","path":"pic/CGI调试1.png","modified":0,"renderable":0},{"_id":"source/pic/ARP报文.png","path":"pic/ARP报文.png","modified":0,"renderable":0},{"_id":"source/pic/CGI调试4.png","path":"pic/CGI调试4.png","modified":0,"renderable":0},{"_id":"source/pic/CGI调试3.png","path":"pic/CGI调试3.png","modified":0,"renderable":0},{"_id":"source/pic/CGI调试2.png","path":"pic/CGI调试2.png","modified":0,"renderable":0},{"_id":"source/pic/CGI调试5.png","path":"pic/CGI调试5.png","modified":0,"renderable":0},{"_id":"source/pic/CS模型.png","path":"pic/CS模型.png","modified":0,"renderable":0},{"_id":"source/pic/DNS报文标志字段.png","path":"pic/DNS报文标志字段.png","modified":0,"renderable":0},{"_id":"source/pic/DNS_tcpdump1.png","path":"pic/DNS_tcpdump1.png","modified":0,"renderable":0},{"_id":"source/pic/HTTP清河读取和分析2.png","path":"pic/HTTP清河读取和分析2.png","modified":0,"renderable":0},{"_id":"source/pic/HTTP应答.png","path":"pic/HTTP应答.png","modified":0,"renderable":0},{"_id":"source/pic/HTTP请求.png","path":"pic/HTTP请求.png","modified":0,"renderable":0},{"_id":"source/pic/HTTP请求读取和分析1.png","path":"pic/HTTP请求读取和分析1.png","modified":0,"renderable":0},{"_id":"source/pic/ICMP重定向报文.png","path":"pic/ICMP重定向报文.png","modified":0,"renderable":0},{"_id":"source/pic/IP分片抓包.png","path":"pic/IP分片抓包.png","modified":0,"renderable":0},{"_id":"source/pic/IP抓包telnet.png","path":"pic/IP抓包telnet.png","modified":0,"renderable":0},{"_id":"source/pic/P2P1.png","path":"pic/P2P1.png","modified":0,"renderable":0},{"_id":"source/pic/IP抓包tcpdump.png","path":"pic/IP抓包tcpdump.png","modified":0,"renderable":0},{"_id":"source/pic/P2P2.png","path":"pic/P2P2.png","modified":0,"renderable":0},{"_id":"source/pic/SNDBUF1.png","path":"pic/SNDBUF1.png","modified":0,"renderable":0},{"_id":"source/pic/Reactor.png","path":"pic/Reactor.png","modified":0,"renderable":0},{"_id":"source/pic/SO_RCVBUF.png","path":"pic/SO_RCVBUF.png","modified":0,"renderable":0},{"_id":"source/pic/SO_SNDBUF.png","path":"pic/SO_SNDBUF.png","modified":0,"renderable":0},{"_id":"source/pic/SO_RCVBUF1.png","path":"pic/SO_RCVBUF1.png","modified":0,"renderable":0},{"_id":"source/pic/TCP头部选项一般结构.png","path":"pic/TCP头部选项一般结构.png","modified":0,"renderable":0},{"_id":"source/pic/TCP带外数据.png","path":"pic/TCP带外数据.png","modified":0,"renderable":0},{"_id":"source/pic/TCP收发数据结果.png","path":"pic/TCP收发数据结果.png","modified":0,"renderable":0},{"_id":"source/pic/Web调试2.png","path":"pic/Web调试2.png","modified":0,"renderable":0},{"_id":"source/pic/Web调试3.png","path":"pic/Web调试3.png","modified":0,"renderable":0},{"_id":"source/pic/arp命令2.png","path":"pic/arp命令2.png","modified":0,"renderable":0},{"_id":"source/pic/fork之后的管道.png","path":"pic/fork之后的管道.png","modified":0,"renderable":0},{"_id":"source/pic/host命令.png","path":"pic/host命令.png","modified":0,"renderable":0},{"_id":"source/pic/listen测试.png","path":"pic/listen测试.png","modified":0,"renderable":0},{"_id":"source/pic/nc测试.png","path":"pic/nc测试.png","modified":0,"renderable":0},{"_id":"source/pic/netstat命令1.png","path":"pic/netstat命令1.png","modified":0,"renderable":0},{"_id":"source/pic/queue结构.png","path":"pic/queue结构.png","modified":0,"renderable":0},{"_id":"source/pic/route命令.png","path":"pic/route命令.png","modified":0,"renderable":0},{"_id":"source/pic/shutdown参数.png","path":"pic/shutdown参数.png","modified":0,"renderable":0},{"_id":"source/pic/stack结构.png","path":"pic/stack结构.png","modified":0,"renderable":0},{"_id":"source/pic/tcpip数据封装.png","path":"pic/tcpip数据封装.png","modified":0,"renderable":0},{"_id":"source/pic/tcp抓包1.png","path":"pic/tcp抓包1.png","modified":0,"renderable":0},{"_id":"source/pic/telnet测试.png","path":"pic/telnet测试.png","modified":0,"renderable":0},{"_id":"source/pic/tcp抓包2.png","path":"pic/tcp抓包2.png","modified":0,"renderable":0},{"_id":"source/pic/telnet测试四次挥手.png","path":"pic/telnet测试四次挥手.png","modified":0,"renderable":0},{"_id":"source/pic/telnet问题.png","path":"pic/telnet问题.png","modified":0,"renderable":0},{"_id":"source/pic/从父到子的管道.png","path":"pic/从父到子的管道.png","modified":0,"renderable":0},{"_id":"source/pic/代理服务器.png","path":"pic/代理服务器.png","modified":0,"renderable":0},{"_id":"source/pic/信号驱动型IO.png","path":"pic/信号驱动型IO.png","modified":0,"renderable":0},{"_id":"source/pic/半同步半反应堆.png","path":"pic/半同步半反应堆.png","modified":0,"renderable":0},{"_id":"source/pic/半同步半异步.png","path":"pic/半同步半异步.png","modified":0,"renderable":0},{"_id":"source/pic/半同步半异步模式.png","path":"pic/半同步半异步模式.png","modified":0,"renderable":0},{"_id":"source/pic/单继承但不重写虚函数表.png","path":"pic/单继承但不重写虚函数表.png","modified":0,"renderable":0},{"_id":"source/pic/单继承重写虚函数.png","path":"pic/单继承重写虚函数.png","modified":0,"renderable":0},{"_id":"source/pic/异步IO.png","path":"pic/异步IO.png","modified":0,"renderable":0},{"_id":"source/pic/查询问题格式.png","path":"pic/查询问题格式.png","modified":0,"renderable":0},{"_id":"source/pic/抓包带外数据.png","path":"pic/抓包带外数据.png","modified":0,"renderable":0},{"_id":"source/pic/知名端口号.png","path":"pic/知名端口号.png","modified":0,"renderable":0},{"_id":"source/pic/汉诺塔.png","path":"pic/汉诺塔.png","modified":0,"renderable":0},{"_id":"source/pic/线程状态图.png","path":"pic/线程状态图.png","modified":0,"renderable":0},{"_id":"source/pic/虚函数表.png","path":"pic/虚函数表.png","modified":0,"renderable":0},{"_id":"source/pic/资源记录格式.png","path":"pic/资源记录格式.png","modified":0,"renderable":0},{"_id":"source/pic/进程池模型.png","path":"pic/进程池模型.png","modified":0,"renderable":0},{"_id":"source/pic/CGI调试6.png","path":"pic/CGI调试6.png","modified":0,"renderable":0},{"_id":"source/pic/CGI调试7.png","path":"pic/CGI调试7.png","modified":0,"renderable":0},{"_id":"source/pic/DNS报文.png","path":"pic/DNS报文.png","modified":0,"renderable":0},{"_id":"source/pic/DNS_tcpdump2.png","path":"pic/DNS_tcpdump2.png","modified":0,"renderable":0},{"_id":"source/pic/IPv4头部.png","path":"pic/IPv4头部.png","modified":0,"renderable":0},{"_id":"source/pic/IPv6头部.png","path":"pic/IPv6头部.png","modified":0,"renderable":0},{"_id":"source/pic/IP分片.png","path":"pic/IP分片.png","modified":0,"renderable":0},{"_id":"source/pic/Proactor.png","path":"pic/Proactor.png","modified":0,"renderable":0},{"_id":"source/pic/Proactor1.png","path":"pic/Proactor1.png","modified":0,"renderable":0},{"_id":"source/pic/TCP三次握手建立连接.png","path":"pic/TCP三次握手建立连接.png","modified":0,"renderable":0},{"_id":"source/pic/TCP首部.png","path":"pic/TCP首部.png","modified":0,"renderable":0},{"_id":"source/pic/Web调试1.png","path":"pic/Web调试1.png","modified":0,"renderable":0},{"_id":"source/pic/listen测试3.png","path":"pic/listen测试3.png","modified":0,"renderable":0},{"_id":"source/pic/poll事件表.png","path":"pic/poll事件表.png","modified":0,"renderable":0},{"_id":"source/pic/splice函数flag参数.png","path":"pic/splice函数flag参数.png","modified":0,"renderable":0},{"_id":"source/pic/tcpdump抓取四次挥手.png","path":"pic/tcpdump抓取四次挥手.png","modified":0,"renderable":0},{"_id":"source/pic/发送方滑动窗口.png","path":"pic/发送方滑动窗口.png","modified":0,"renderable":0},{"_id":"source/pic/常见TCP头部选项.png","path":"pic/常见TCP头部选项.png","modified":0,"renderable":0},{"_id":"source/pic/并发模式同步异步.png","path":"pic/并发模式同步异步.png","modified":0,"renderable":0},{"_id":"source/pic/快重传.png","path":"pic/快重传.png","modified":0,"renderable":0},{"_id":"source/pic/慢开始.png","path":"pic/慢开始.png","modified":0,"renderable":0},{"_id":"source/pic/模板方法1.png","path":"pic/模板方法1.png","modified":0,"renderable":0},{"_id":"source/pic/模板方法2.png","path":"pic/模板方法2.png","modified":0,"renderable":0},{"_id":"source/pic/模板方法3.png","path":"pic/模板方法3.png","modified":0,"renderable":0},{"_id":"source/pic/模板方法类图.png","path":"pic/模板方法类图.png","modified":0,"renderable":0},{"_id":"source/pic/策略模式类图.png","path":"pic/策略模式类图.png","modified":0,"renderable":0},{"_id":"source/pic/阻塞型网络IO.png","path":"pic/阻塞型网络IO.png","modified":0,"renderable":0},{"_id":"source/pic/Cookie.png","path":"pic/Cookie.png","modified":0,"renderable":0},{"_id":"source/pic/IP模块工作流程图.png","path":"pic/IP模块工作流程图.png","modified":0,"renderable":0},{"_id":"source/pic/STL容器.png","path":"pic/STL容器.png","modified":0,"renderable":0},{"_id":"source/pic/TCP四次挥手释放连接.png","path":"pic/TCP四次挥手释放连接.png","modified":0,"renderable":0},{"_id":"source/pic/Web调试4.png","path":"pic/Web调试4.png","modified":0,"renderable":0},{"_id":"source/pic/deque结构.png","path":"pic/deque结构.png","modified":0,"renderable":0},{"_id":"source/pic/getnameinfo_flags.png","path":"pic/getnameinfo_flags.png","modified":0,"renderable":0},{"_id":"source/pic/linux进程内存分布.png","path":"pic/linux进程内存分布.png","modified":0,"renderable":0},{"_id":"source/pic/listen测试2.png","path":"pic/listen测试2.png","modified":0,"renderable":0},{"_id":"source/pic/socket选项.png","path":"pic/socket选项.png","modified":0,"renderable":0},{"_id":"source/pic/地址信息错误码.png","path":"pic/地址信息错误码.png","modified":0,"renderable":0},{"_id":"source/pic/多继承无虚函数覆盖的虚函数表.png","path":"pic/多继承无虚函数覆盖的虚函数表.png","modified":0,"renderable":0},{"_id":"source/pic/多重继承无虚函数覆盖.png","path":"pic/多重继承无虚函数覆盖.png","modified":0,"renderable":0},{"_id":"source/pic/多重继承有虚函数重写的虚函数表.png","path":"pic/多重继承有虚函数重写的虚函数表.png","modified":0,"renderable":0},{"_id":"source/pic/多重继承有虚函数重写.png","path":"pic/多重继承有虚函数重写.png","modified":0,"renderable":0},{"_id":"source/pic/快恢复.png","path":"pic/快恢复.png","modified":0,"renderable":0},{"_id":"source/pic/慢开始和拥塞避免.png","path":"pic/慢开始和拥塞避免.png","modified":0,"renderable":0},{"_id":"source/pic/接收方滑动窗口.png","path":"pic/接收方滑动窗口.png","modified":0,"renderable":0},{"_id":"source/pic/网络IO复用.png","path":"pic/网络IO复用.png","modified":0,"renderable":0},{"_id":"source/pic/非阻塞型网络IO.png","path":"pic/非阻塞型网络IO.png","modified":0,"renderable":0},{"_id":"source/pic/HTTP请求方法.png","path":"pic/HTTP请求方法.png","modified":0,"renderable":0},{"_id":"source/pic/TCP状态转移过程.png","path":"pic/TCP状态转移过程.png","modified":0,"renderable":0},{"_id":"source/pic/ai_flags.png","path":"pic/ai_flags.png","modified":0,"renderable":0},{"_id":"source/pic/pycharm分屏.png","path":"pic/pycharm分屏.png","modified":0,"renderable":0},{"_id":"source/pic/数据读写flags.png","path":"pic/数据读写flags.png","modified":0,"renderable":0},{"_id":"source/pic/线程内核对象.png","path":"pic/线程内核对象.png","modified":0,"renderable":0},{"_id":"source/pic/路由表.png","path":"pic/路由表.png","modified":0,"renderable":0},{"_id":"source/pic/HTTP状态码.png","path":"pic/HTTP状态码.png","modified":0,"renderable":0},{"_id":"source/pic/IPv6扩展头部.png","path":"pic/IPv6扩展头部.png","modified":0,"renderable":0},{"_id":"source/pic/简单工厂.png","path":"pic/简单工厂.png","modified":0,"renderable":0},{"_id":"source/pic/initializer_list.png","path":"pic/initializer_list.png","modified":0,"renderable":0},{"_id":"source/pic/lsof输出.png","path":"pic/lsof输出.png","modified":0,"renderable":0},{"_id":"source/pic/STL组件之间的关系.png","path":"pic/STL组件之间的关系.png","modified":0,"renderable":0},{"_id":"source/pic/简单虚继承对象模型.png","path":"pic/简单虚继承对象模型.png","modified":0,"renderable":0},{"_id":"source/pic/菱形虚继承.png","path":"pic/菱形虚继承.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"1ca8058a08db6aa2dc9ba475cc4c45208a63906d","modified":1638768636989},{"_id":"source/CNAME","hash":"a47160fade698a57d917ded1359ee36d14e88739","modified":1638768636989},{"_id":"source/timg.jpg","hash":"438a61df3afc1ec282a8e63455d7a03c2b01b545","modified":1638768637058},{"_id":"source/404/404.md","hash":"17657585e818d245e2000306cb66d0ce8dedb022","modified":1638768636989},{"_id":"source/_posts/ARP协议分析.md","hash":"aa6cca7549ede9b5128244e898337ecc58b1e9fa","modified":1638768636989},{"_id":"source/_posts/C-11的一些小知识点.md","hash":"a151d67aa0aded437de1bc85df71e1f00a139d67","modified":1638768636990},{"_id":"source/_posts/DNS.md","hash":"e28448e7086b9b1f4d2cfe3b79d141cff11efbaf","modified":1638768636990},{"_id":"source/_posts/HTTP代理服务器.md","hash":"67a2b5cc35b6f8cbc7408502850f1087f9be8dd3","modified":1638768636990},{"_id":"source/_posts/HTTP协议.md","hash":"4e01e9cabc67415cd7d2a32dac76c05d1c0fe917","modified":1638768636990},{"_id":"source/_posts/Linux下的网络IO模型 .md","hash":"a2521f4a87cccb75abe22e85832858a9558b2a9d","modified":1638768636990},{"_id":"source/_posts/IP协议.md","hash":"2ea57afae9f26bb6be9c07e7b69f9228acf82b77","modified":1638768636990},{"_id":"source/_posts/STL六大部件.md","hash":"acd4007776479b817c4e990342a02046c57d56bd","modified":1638768636990},{"_id":"source/_posts/TCP协议.md","hash":"a60ea9a116c829296c145583d7dc46f4bbb0c264","modified":1638768636990},{"_id":"source/_posts/STL容器性能测试.md","hash":"0e23cee34221c636418604bba973c5fe0161fcd0","modified":1638768636990},{"_id":"source/_posts/TCP数据传输.md","hash":"cd8c26381d656c86ddff09254e7636fd86e02031","modified":1638768636991},{"_id":"source/_posts/epoll.md","hash":"ad775d4f49722cc81b275d9ba125ea7a6b30d1d4","modified":1638768636991},{"_id":"source/_posts/Windows下的线程同步.md","hash":"927306f8de2b7ddc1dee10b77dc6ef44184cb80e","modified":1638768636991},{"_id":"source/_posts/Variadic-Templates.md","hash":"44e05cb0af0ba23263a9df03155b03803980b473","modified":1638768636991},{"_id":"source/_posts/Windows下的线程.md","hash":"80b2f308a4a07ee0f8b48605094f4dc690306057","modified":1638768636991},{"_id":"source/_posts/gdb调试.md","hash":"49dfb7a5d19cae144253618298f233fb267f8c5d","modified":1638768636991},{"_id":"source/_posts/linux下的多进程服务器模型.md","hash":"a58d0784e67f8df7c68949ff1fd597f5646a3fda","modified":1638768636991},{"_id":"source/_posts/linux下的线程.md","hash":"c6d6c582bd4174a85190ed0b60ee112599737784","modified":1638768636992},{"_id":"source/_posts/linux进程间通信方式.md","hash":"c41bef7a027278dfab97f233c6605ae228c11e5b","modified":1638768636992},{"_id":"source/_posts/linux下的select模型.md","hash":"ae4269494e2a2a932701ed4b01fa7df519f1674d","modified":1638768636991},{"_id":"source/_posts/lsof.md","hash":"f071073710bdaf96e1b648419d155249e461b159","modified":1638768636992},{"_id":"source/_posts/linux网络编程流程.md","hash":"6f5d23379a6c3fe27b0c824a4796d1cd6898bcc7","modified":1638768636992},{"_id":"source/_posts/poll.md","hash":"8a092ff5a0817611821412f8f8ceb992044c92de","modified":1638768636992},{"_id":"source/_posts/socket选项.md","hash":"5a3c165971219c021b520b2c1f3b3b0c2f33e9a0","modified":1638768636992},{"_id":"source/_posts/八大设计原则.md","hash":"522e80d22a8954ab834c51ac3754db6eeaf594b1","modified":1638768636993},{"_id":"source/_posts/三次握手四次挥手.md","hash":"b67167e2d1db4f936abae89537428e5b41f656d5","modified":1638768636992},{"_id":"source/_posts/tcpdump.md","hash":"cf22c32f5e7117b3ac2dccdd8a741cf8e608cf1b","modified":1638768636992},{"_id":"source/_posts/优秀博客整理.md","hash":"54f4a44a86fb4f52ea342de7a0fe11ee874be09a","modified":1638768636992},{"_id":"source/_posts/写给21岁的自己.md","hash":"19e9faac78c2274853d9ea5ea54e44a53ed74356","modified":1638768636993},{"_id":"source/_posts/拥塞控制.md","hash":"62b5adc50dba9972b48025ac031d5dc08b4cbb7d","modified":1638768636993},{"_id":"source/_posts/庆祝博客的诞生.md","hash":"c8103ced881e99940e13952ab7eebf4633f6f196","modified":1638768636993},{"_id":"source/_posts/构造函数.md","hash":"4a368d42a7b8777617c86cde4392329b3f5edb3e","modified":1638768636993},{"_id":"source/_posts/服务器内核参数配置.md","hash":"ef36b55d135ea32fc3a7441e33f42dfe156e5458","modified":1638768636993},{"_id":"source/_posts/模板方法.md","hash":"bb8637e280585a5e31deac15ef4d5fb74d6a39a7","modified":1638768636993},{"_id":"source/_posts/禁止拷贝构造和赋值.md","hash":"2280981aa7ada93b4d52ee09eeffe97696e9b98a","modified":1638768636994},{"_id":"source/_posts/知识点整理.md","hash":"5ec44e8ca9aa19bc981345bbce6f922f6d94cece","modified":1638768636994},{"_id":"source/_posts/汉诺塔问题.md","hash":"3fa99bc69f92d356ecc4049b539386afa8ec6392","modified":1638768636993},{"_id":"source/_posts/滑动窗口.md","hash":"7ce9366a816c800f194b2c18c3fac3156e7afc36","modified":1638768636994},{"_id":"source/_posts/策略模式.md","hash":"2ce6baab538002dc37e02d3e0fbcd76be052f94c","modified":1638768636994},{"_id":"source/_posts/算法整理.md","hash":"ecedf327011c0b9f958969b16bc6be7258f5b3fb","modified":1638768636994},{"_id":"source/_posts/线程同步经典问题练习.md","hash":"bb16a7393494c0b13415833b381c0bcce4e22761","modified":1638768636994},{"_id":"source/_posts/线程池.md","hash":"3ecfc03f6f686129c08476414a0a2fc53cfcdbbe","modified":1638768636994},{"_id":"source/_posts/虚函数表.md","hash":"7c8e4bd66eb0f6503a1f7ea51c3e9e4bf68d865c","modified":1638768636994},{"_id":"source/_posts/网络中一些高级IO函数.md","hash":"85e6ae7299de2cea401a41a41a92922dfcf397c1","modified":1638768636994},{"_id":"source/_posts/设计模式之简单工厂.md","hash":"1112874cfb343b0c3b3155c2ded4b5f29ecee181","modified":1638768636995},{"_id":"source/_posts/进程.md","hash":"7fe0a3b0dc60eca88dbfbc3f270ad579655f9215","modified":1638768636995},{"_id":"source/about/index.md","hash":"72abb072d942039e6bd8a4657885ea071d9a9637","modified":1638768636995},{"_id":"source/_posts/高性能服务器程序框架.md","hash":"7a0eb48a3198be7ae48b3fc8980b23f7f43356b2","modified":1638768636995},{"_id":"source/_posts/进程池.md","hash":"06fb7000e3cf08d74042ae5cb364d98823ab4f2e","modified":1638768636995},{"_id":"source/_posts/重载.md","hash":"f7ea653bee6bd03e14f339478be72ba0be76b140","modified":1638768636995},{"_id":"source/pic/5种IO模型的比较.png","hash":"21418387af89f30583d6bcc8b38981b65e5f8d4e","modified":1638768636996},{"_id":"source/pic/ARP命令1.png","hash":"aeb8789263647306d4ce8f37cc45b119d04f1462","modified":1638768636996},{"_id":"source/pic/CGI调试1.png","hash":"c261e4ce8985d2fe59c4c53732a0d8609bb16d6f","modified":1638768636997},{"_id":"source/pic/ARP报文.png","hash":"9fc94a284fa8cd67b289fdf78422c00146bb4d15","modified":1638768636996},{"_id":"source/pic/CGI调试4.png","hash":"ad9e5312723c8c1c75493a0167a6375638a23394","modified":1638768636997},{"_id":"source/pic/CGI调试3.png","hash":"f29fc0ad4f037dd4f177ff18a94a73a93447ed62","modified":1638768636997},{"_id":"source/pic/CGI调试2.png","hash":"303015f54706e7346265d8608966048083a67658","modified":1638768636997},{"_id":"source/pic/CGI调试5.png","hash":"7c7d2214efc112639291ffa569faf6bc63293f01","modified":1638768636997},{"_id":"source/pic/CS模型.png","hash":"21c5eb22a51a751988baade498699c9dc567c436","modified":1638768636999},{"_id":"source/pic/DNS报文标志字段.png","hash":"b547db00e524507ab4311a9d0f06e0792d6bfe05","modified":1638768637001},{"_id":"source/pic/DNS_tcpdump1.png","hash":"2ea4f1531734283ef8700fc8326245b76d377201","modified":1638768637000},{"_id":"source/pic/HTTP清河读取和分析2.png","hash":"03292f31154d0f43817a9a1053df6fba4e47eb32","modified":1638768637001},{"_id":"source/pic/HTTP应答.png","hash":"4c562a53ef52cd5b3b527be668f4270b2b3d9d38","modified":1638768637001},{"_id":"source/pic/HTTP请求.png","hash":"c34310961acc1f3a24f598ad3261ffc89cf0525b","modified":1638768637003},{"_id":"source/pic/HTTP请求读取和分析1.png","hash":"07458e08090aef0310b0b284c559347c55e0e378","modified":1638768637005},{"_id":"source/pic/ICMP重定向报文.png","hash":"2145929c1c6f33a0240fb57779efcc8aee6a1c92","modified":1638768637005},{"_id":"source/pic/IP分片抓包.png","hash":"9cd59c6ac7ab26107e57bd2b3821e73b45a09913","modified":1638768637009},{"_id":"source/pic/IP抓包telnet.png","hash":"0c32ef0f9ffda8f35b15b9a4a51ddc72b0b00256","modified":1638768637009},{"_id":"source/pic/P2P1.png","hash":"a5ebfe8d52b09a126ff35866ba94a18855fb3b5b","modified":1638768637010},{"_id":"source/pic/IP抓包tcpdump.png","hash":"e2b92bc95be46e6a8f0837f839a1b0caac7995ce","modified":1638768637009},{"_id":"source/pic/P2P2.png","hash":"2077444caf501a3e6ce8ce8c7dec89fdc34bc6d8","modified":1638768637010},{"_id":"source/pic/SNDBUF1.png","hash":"5c3b6e34b9e1c8c333af06dcfba20e7b6985279f","modified":1638768637011},{"_id":"source/pic/Reactor.png","hash":"8b1f9aa8c4eeab565fb2d2b3fbf34b397cb0ce7c","modified":1638768637011},{"_id":"source/pic/SO_RCVBUF.png","hash":"245fbf5ead712b6a18e5eccb7c854dac6fcb9a15","modified":1638768637012},{"_id":"source/pic/SO_SNDBUF.png","hash":"32dca0500c8707e57f9c3bdc733052bbc9b18ab4","modified":1638768637012},{"_id":"source/pic/SO_RCVBUF1.png","hash":"d87c4ec8ecae690da2a60af6e9810344d7a4d843","modified":1638768637012},{"_id":"source/pic/TCP头部选项一般结构.png","hash":"7236cfecb551c7644ca5006e589465259687e8c0","modified":1638768637016},{"_id":"source/pic/TCP带外数据.png","hash":"c33628ecbd8294480c8e01f775b4d8d6197b5898","modified":1638768637016},{"_id":"source/pic/TCP收发数据结果.png","hash":"f77dc6a79955ef233c34a37428b1397d393c6a81","modified":1638768637016},{"_id":"source/pic/Web调试2.png","hash":"abd40732f157c1a86c6767aaebb826b5adb37477","modified":1638768637018},{"_id":"source/pic/Web调试3.png","hash":"0292f4a524e5ff9be80e6ecd9b97fbeb62c3c7d2","modified":1638768637018},{"_id":"source/pic/arp命令2.png","hash":"2bff10f13791965338e621c0032355e919b55ab7","modified":1638768637020},{"_id":"source/pic/fork之后的管道.png","hash":"a4b7e4064666a80bfb57c8ee789355d4aa308b67","modified":1638768637022},{"_id":"source/pic/host命令.png","hash":"9568652a99af4bad09f9011448c45da42b767b9b","modified":1638768637022},{"_id":"source/pic/listen测试.png","hash":"6711e3fafbb21a774ac8ceda52765c9555185d81","modified":1638768637024},{"_id":"source/pic/nc测试.png","hash":"1a5bfd03957937cb79135838c9694487baa1262a","modified":1638768637027},{"_id":"source/pic/netstat命令1.png","hash":"9153a3acf93e0d25dcb4bc71c718a5a77b9f6467","modified":1638768637027},{"_id":"source/pic/queue结构.png","hash":"966985f62f7300f1ef0374b334c5afddbc7db4c6","modified":1638768637028},{"_id":"source/pic/route命令.png","hash":"d43389545b676d1d1e99f182af4e7b8239eff81e","modified":1638768637029},{"_id":"source/pic/shutdown参数.png","hash":"2ec4c0bbca95d8a74fbcb580f02e5b5397183833","modified":1638768637029},{"_id":"source/pic/stack结构.png","hash":"e87a5d1edce60cc7e74a325ccd13685574cd2ffa","modified":1638768637031},{"_id":"source/pic/tcpip数据封装.png","hash":"8a8f5bd30864267fcd6b0a105dc24950a5ffc989","modified":1638768637032},{"_id":"source/pic/tcp抓包1.png","hash":"3759f74d7a4502d96a3a48e080333eb3c69ab673","modified":1638768637032},{"_id":"source/pic/telnet测试.png","hash":"85070316a65d5870d41c14920ba891f02c6a4b87","modified":1638768637033},{"_id":"source/pic/tcp抓包2.png","hash":"49d7925cd3f18c1ed85ca6441d9dae017eab8e5c","modified":1638768637033},{"_id":"source/pic/telnet测试四次挥手.png","hash":"a7f890fb07a8916ea7cd82775904642bdbea7864","modified":1638768637033},{"_id":"source/pic/telnet问题.png","hash":"41b5a738b2b36ebbb1a8078e245d9956558be090","modified":1638768637033},{"_id":"source/pic/从父到子的管道.png","hash":"4eb3a250b11e876bd37c3655d2c38c43a1830025","modified":1638768637034},{"_id":"source/pic/代理服务器.png","hash":"aa2fb7eff03053a660d1b7ce4786ba2c05a12e3c","modified":1638768637034},{"_id":"source/pic/信号驱动型IO.png","hash":"c60a28075ac51da5e3547f0a40617df37d4d309f","modified":1638768637034},{"_id":"source/pic/半同步半反应堆.png","hash":"4fc03629f2cf67a723508521152f90fabb6780a2","modified":1638768637035},{"_id":"source/pic/半同步半异步.png","hash":"e998b9e4720f79a99608fe791db00ca74173ce08","modified":1638768637035},{"_id":"source/pic/半同步半异步模式.png","hash":"e9f3a067d2dc930fcad20638a98c0d5217fb11e4","modified":1638768637035},{"_id":"source/pic/单继承但不重写虚函数表.png","hash":"407e490de0a65b63cca67cbe832aaf7fe08108d1","modified":1638768637035},{"_id":"source/pic/单继承重写虚函数.png","hash":"4f512ba6f5900fc0816aaed497f31dfcacc75270","modified":1638768637036},{"_id":"source/pic/异步IO.png","hash":"429c255ee7963de06342c1a27d6de6dd4c6b4323","modified":1638768637041},{"_id":"source/pic/查询问题格式.png","hash":"4939d137529c2e93f854d01384688724ae645b4a","modified":1638768637045},{"_id":"source/pic/抓包带外数据.png","hash":"da44d30a3b76e4355d3f10ec35d5a259941e2f4b","modified":1638768637043},{"_id":"source/pic/知名端口号.png","hash":"ef53b7e0c68b6b0d05eb8dd4e10969724086656e","modified":1638768637048},{"_id":"source/pic/汉诺塔.png","hash":"83d24f40618a3ada51b518469f1514d08c681ae7","modified":1638768637048},{"_id":"source/pic/线程状态图.png","hash":"58dd74c37e124b72728be0603b306354bbd0cadc","modified":1638768637052},{"_id":"source/pic/虚函数表.png","hash":"d977dc9ee9eb61353830dbe3634e358b9e9af81a","modified":1638768637054},{"_id":"source/pic/资源记录格式.png","hash":"c9c991d886e9b20f90df8af710ad6ea4cdaffd12","modified":1638768637055},{"_id":"source/pic/进程池模型.png","hash":"87e163ef8eb5bbf1a058210666f204f83a36ed76","modified":1638768637056},{"_id":"source/pic/CGI调试6.png","hash":"1febebf95af6b1adb8a6466ef6b89c0825d121e7","modified":1638768636998},{"_id":"source/pic/CGI调试7.png","hash":"3fd38d0fadb3b8604b175a48eac411a01dab508e","modified":1638768636998},{"_id":"source/pic/DNS报文.png","hash":"f43a47d427141923d7254101e278099d5c56567b","modified":1638768637001},{"_id":"source/pic/DNS_tcpdump2.png","hash":"d14d6447e7949a482adb39e12c80692c86af63d6","modified":1638768637000},{"_id":"source/pic/IPv4头部.png","hash":"f69e4eed6b6d84f7d02fa753c14d16190efb4a77","modified":1638768637006},{"_id":"source/pic/IPv6头部.png","hash":"e838f6d1951c77b233cb6b06a12dd7ccb9dc4c4d","modified":1638768637006},{"_id":"source/pic/IP分片.png","hash":"c26cc97bd98913ca5fb360d546bd91174728ae44","modified":1638768637008},{"_id":"source/pic/Proactor.png","hash":"8e1ab1ab0f856b39d88dcd4201bde8b8161d0b0a","modified":1638768637010},{"_id":"source/pic/Proactor1.png","hash":"1182abf78b13ff2a5b6507fc42191168e20a5e3a","modified":1638768637011},{"_id":"source/pic/TCP三次握手建立连接.png","hash":"5c515a2e54324a3c1db3c288fb4a97f05fc89c2e","modified":1638768637014},{"_id":"source/pic/TCP首部.png","hash":"2301d7f7cb7f37bd081f44bbc020e993b015131d","modified":1638768637017},{"_id":"source/pic/Web调试1.png","hash":"b9870bfe043ffdf1aee0961738def9e9974ed0a3","modified":1638768637018},{"_id":"source/pic/listen测试3.png","hash":"d13c796325e959c6d4fd5da7e0055b1eaeebdf47","modified":1638768637025},{"_id":"source/pic/poll事件表.png","hash":"c7f3e0ab5f1ca32649f9a053b12faae5f67bd2a8","modified":1638768637027},{"_id":"source/pic/splice函数flag参数.png","hash":"8be2d21d0682ad79d5da3b40a7a34b15e8b9b841","modified":1638768637031},{"_id":"source/pic/tcpdump抓取四次挥手.png","hash":"07ac62485d60b69813caa27eb707c5cd69022eb6","modified":1638768637032},{"_id":"source/pic/发送方滑动窗口.png","hash":"454472b46a7aac90e2351e480e44b524d99a321e","modified":1638768637036},{"_id":"source/pic/常见TCP头部选项.png","hash":"dea9a20075315ef542c624e189f97fb9acb3fd96","modified":1638768637041},{"_id":"source/pic/并发模式同步异步.png","hash":"13c688dc3d9ae8edfdadbd3bd9a5f37f7329f707","modified":1638768637041},{"_id":"source/pic/快重传.png","hash":"5ed460ba1e9f46337401f48176a4182badcb6ecc","modified":1638768637042},{"_id":"source/pic/慢开始.png","hash":"94c924848f657775088c1e4174e5a78cf72fe9eb","modified":1638768637043},{"_id":"source/pic/模板方法1.png","hash":"7d4745c02a5fb05d6668ac4592944a70cab45489","modified":1638768637046},{"_id":"source/pic/模板方法2.png","hash":"68f005b776843121677438d8e0caaeef12fa85a7","modified":1638768637046},{"_id":"source/pic/模板方法3.png","hash":"e597205b920544a005bd4824119d7c5433d69b3e","modified":1638768637046},{"_id":"source/pic/模板方法类图.png","hash":"6ce9488d31e8e7f12f2e3149d1ca0f97b90ee19a","modified":1638768637047},{"_id":"source/pic/策略模式类图.png","hash":"a2c66e26a7082463e0df114c70410fed3db1bf95","modified":1638768637049},{"_id":"source/_posts/2021/博客搭建流程再记录.md","hash":"18fbae51db6e7f21d99d3552b1a11d174846d8ed","modified":1638770263489},{"_id":"source/pic/阻塞型网络IO.png","hash":"17999d12032cf799ae5a7c5ab6c84a4b2328710c","modified":1638768637057},{"_id":"source/pic/Cookie.png","hash":"5d8e10462b77930b79e0f8163e3c50a70f3900a0","modified":1638768636999},{"_id":"source/pic/IP模块工作流程图.png","hash":"cc063ae4734f6b0fecf114a5640a9d31e2d6eefd","modified":1638768637010},{"_id":"source/pic/STL容器.png","hash":"1fde177e74e8d0b580dfa402e02a8335b1584fb2","modified":1638768637013},{"_id":"source/pic/TCP四次挥手释放连接.png","hash":"c125a34c538bebfdc828a0c482e37463fc4c7e1e","modified":1638768637015},{"_id":"source/pic/Web调试4.png","hash":"4c8b2b0a854812e8d7babce6890e8893429aaa51","modified":1638768637019},{"_id":"source/pic/deque结构.png","hash":"ec831ba886fd0c1b07351d6e6e88505a33cec0dd","modified":1638768637021},{"_id":"source/pic/getnameinfo_flags.png","hash":"8b50b4593e8c89d37f68e69954392b55cae62744","modified":1638768637022},{"_id":"source/pic/linux进程内存分布.png","hash":"55fa3e25fa9dfb79fac978679c3227f980ff757a","modified":1638768637024},{"_id":"source/pic/listen测试2.png","hash":"bacdcb6bc7a33b0b4a9ac262f944b520aff08b5e","modified":1638768637024},{"_id":"source/pic/socket选项.png","hash":"e8d5d3ba33e3f3dec65306e4b4839bd86af75b83","modified":1638768637030},{"_id":"source/pic/地址信息错误码.png","hash":"6fb95e17e8850cb8a670017bf2cdfb55f2e7930f","modified":1638768637038},{"_id":"source/pic/多继承无虚函数覆盖的虚函数表.png","hash":"fd3b8b1d24bc3b953018019983c8243b0ee1ccc0","modified":1638768637038},{"_id":"source/pic/多重继承无虚函数覆盖.png","hash":"1deb110b6161093c8b9510862754f9eb9a37ba41","modified":1638768637039},{"_id":"source/pic/多重继承有虚函数重写的虚函数表.png","hash":"2942cdec1aa636837f7e889de112fa1b553629cb","modified":1638768637040},{"_id":"source/pic/多重继承有虚函数重写.png","hash":"883017b99ef8e9f0716f7ac3dcd3774c6f659278","modified":1638768637039},{"_id":"source/pic/快恢复.png","hash":"49cfcec07c0fdb1e83ac3d01005a4402eb58e679","modified":1638768637042},{"_id":"source/pic/慢开始和拥塞避免.png","hash":"9ddcf24a8df3b8a88729d805e8e7be68f1f1422c","modified":1638768637043},{"_id":"source/pic/接收方滑动窗口.png","hash":"62cb7092ed0a72cd2f0a0658997ca748923bafcf","modified":1638768637044},{"_id":"source/pic/网络IO复用.png","hash":"e154403298ad25ef8394202bd553b14e7dee6b11","modified":1638768637053},{"_id":"source/pic/非阻塞型网络IO.png","hash":"d17183835a9bff2e6e9292d940594f4fcddcf952","modified":1638768637058},{"_id":"source/pic/HTTP请求方法.png","hash":"215ac7f12a58b3a60ea287ae2698f99cf67df83a","modified":1638768637004},{"_id":"source/pic/TCP状态转移过程.png","hash":"2e6b89ef796ea9977e5d574f6cd159dff6ae1040","modified":1638768637017},{"_id":"source/pic/ai_flags.png","hash":"80b27ad4964fabd582596813e564a235dfe3a90e","modified":1638768637020},{"_id":"source/pic/pycharm分屏.png","hash":"fab766433d83b1c28b8f900a8c586f4e90492174","modified":1638768637028},{"_id":"source/pic/数据读写flags.png","hash":"1dbafa1e1522e04ced61e838a7f6f6011dbfbeca","modified":1638768637045},{"_id":"source/pic/线程内核对象.png","hash":"c3cbc1ab97f90857aee05bb6deb5318349a95e46","modified":1638768637052},{"_id":"source/pic/路由表.png","hash":"a7e24c900be0782d44fcd6197fce0191a4417056","modified":1638768637056},{"_id":"source/_posts/2020/01/pycharm快捷键整理.md","hash":"895dfee9af029491848cc4879847498e47dde066","modified":1638768636989},{"_id":"source/_posts/2020/01/博客搭建流程.md","hash":"d965efd8638cf953f867629a5035d2e03b3d3c0f","modified":1638768636989},{"_id":"source/pic/HTTP状态码.png","hash":"4579cbf34238fe60821e58ccf58d07272500dd02","modified":1638768637003},{"_id":"source/pic/IPv6扩展头部.png","hash":"cf5527323f01fe4e9a45feac37df723ca4ea54d0","modified":1638768637007},{"_id":"source/pic/简单工厂.png","hash":"58706876003b634c0e2e4c083c15abce714ac77f","modified":1638768637050},{"_id":"source/pic/initializer_list.png","hash":"871a215cd72623c21e58195f91912c8cecb01b5f","modified":1638768637023},{"_id":"source/pic/lsof输出.png","hash":"8047a379e7b96c22b89bcc651a0a8df5b803e3a5","modified":1638768637027},{"_id":"source/pic/STL组件之间的关系.png","hash":"c997f98c0e039b6756fc932e9038c51d2b8d775b","modified":1638768637014},{"_id":"source/pic/简单虚继承对象模型.png","hash":"0da2f102cd5e67f4f7d42feac56a285bf8f18f47","modified":1638768637051},{"_id":"source/pic/菱形虚继承.png","hash":"3e9aed9c9b7593a64100cc1663df86a441998d09","modified":1638768637054},{"_id":"public/content.json","hash":"2ba134e5386ea1552b4033211bb3a79d94f34cf8","modified":1638770290565},{"_id":"public/404/404.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2021/12/2021-博客搭建流程再记录/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2020/01/pycharm快捷键整理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2020/01/博客搭建流程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/STL容器性能测试/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/策略模式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/C-11的一些小知识点/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/模板方法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/STL六大部件/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/Variadic-Templates/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/八大设计原则/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/禁止拷贝构造和赋值/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/gdb调试/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/lsof/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/服务器内核参数配置/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/线程池/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/04/进程池/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/高性能服务器程序框架/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/网络中一些高级IO函数/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/优秀博客整理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/虚函数表/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/算法整理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/进程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/linux进程间通信方式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/socket选项/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/linux网络编程流程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/HTTP协议/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/HTTP代理服务器/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/TCP数据传输/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/IP协议/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/DNS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/tcpdump/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2019/03/ARP协议分析/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/12/epoll/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/poll/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/linux下的select模型/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/linux下的多进程服务器模型/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/Linux下的网络IO模型/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/拥塞控制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/滑动窗口/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/三次握手四次挥手/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/TCP协议/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/设计模式之简单工厂/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/线程同步经典问题练习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/Windows下的线程同步/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/linux下的线程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/Windows下的线程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/重载/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/构造函数/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/11/知识点整理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/10/写给21岁的自己/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/10/汉诺塔问题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/2018/09/庆祝博客的诞生/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2018/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2018/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2018/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2018/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2018/11/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2018/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2019/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2019/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2019/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2019/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2019/03/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2019/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2019/04/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2020/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2020/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2021/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/archives/2021/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/网络/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/网络/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/Linux高性能服务器编程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/Linux高性能服务器编程/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/C/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/C-11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/HTTP/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/Linux/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/STL/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/TCP/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/IO复用/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/操作系统/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/Windows/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/常用工具/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/服务器模型/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/进程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/apue/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/设计模式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/随笔/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/Effective-C/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/算法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/线程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/数据结构/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/工具/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/git/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/tags/软件安装/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638770290565},{"_id":"public/pic/CGI调试4.png","hash":"ad9e5312723c8c1c75493a0167a6375638a23394","modified":1638770290565},{"_id":"public/CNAME","hash":"a47160fade698a57d917ded1359ee36d14e88739","modified":1638770290565},{"_id":"public/timg.jpg","hash":"438a61df3afc1ec282a8e63455d7a03c2b01b545","modified":1638770290565},{"_id":"public/pic/CGI调试1.png","hash":"c261e4ce8985d2fe59c4c53732a0d8609bb16d6f","modified":1638770290565},{"_id":"public/pic/5种IO模型的比较.png","hash":"21418387af89f30583d6bcc8b38981b65e5f8d4e","modified":1638770290565},{"_id":"public/pic/ARP报文.png","hash":"9fc94a284fa8cd67b289fdf78422c00146bb4d15","modified":1638770290565},{"_id":"public/pic/CGI调试2.png","hash":"303015f54706e7346265d8608966048083a67658","modified":1638770290565},{"_id":"public/pic/CGI调试3.png","hash":"f29fc0ad4f037dd4f177ff18a94a73a93447ed62","modified":1638770290565},{"_id":"public/pic/CGI调试5.png","hash":"7c7d2214efc112639291ffa569faf6bc63293f01","modified":1638770290565},{"_id":"public/pic/ARP命令1.png","hash":"aeb8789263647306d4ce8f37cc45b119d04f1462","modified":1638770290565},{"_id":"public/pic/CS模型.png","hash":"21c5eb22a51a751988baade498699c9dc567c436","modified":1638770290565},{"_id":"public/pic/DNS报文标志字段.png","hash":"b547db00e524507ab4311a9d0f06e0792d6bfe05","modified":1638770290565},{"_id":"public/pic/DNS_tcpdump1.png","hash":"2ea4f1531734283ef8700fc8326245b76d377201","modified":1638770290565},{"_id":"public/pic/HTTP应答.png","hash":"4c562a53ef52cd5b3b527be668f4270b2b3d9d38","modified":1638770290565},{"_id":"public/pic/HTTP请求.png","hash":"c34310961acc1f3a24f598ad3261ffc89cf0525b","modified":1638770290565},{"_id":"public/pic/HTTP清河读取和分析2.png","hash":"03292f31154d0f43817a9a1053df6fba4e47eb32","modified":1638770290565},{"_id":"public/pic/HTTP请求读取和分析1.png","hash":"07458e08090aef0310b0b284c559347c55e0e378","modified":1638770290565},{"_id":"public/pic/IP抓包telnet.png","hash":"0c32ef0f9ffda8f35b15b9a4a51ddc72b0b00256","modified":1638770290565},{"_id":"public/pic/ICMP重定向报文.png","hash":"2145929c1c6f33a0240fb57779efcc8aee6a1c92","modified":1638770290565},{"_id":"public/pic/IP分片抓包.png","hash":"9cd59c6ac7ab26107e57bd2b3821e73b45a09913","modified":1638770290565},{"_id":"public/pic/P2P1.png","hash":"a5ebfe8d52b09a126ff35866ba94a18855fb3b5b","modified":1638770290565},{"_id":"public/pic/IP抓包tcpdump.png","hash":"e2b92bc95be46e6a8f0837f839a1b0caac7995ce","modified":1638770290565},{"_id":"public/pic/SNDBUF1.png","hash":"5c3b6e34b9e1c8c333af06dcfba20e7b6985279f","modified":1638770290565},{"_id":"public/pic/P2P2.png","hash":"2077444caf501a3e6ce8ce8c7dec89fdc34bc6d8","modified":1638770290565},{"_id":"public/pic/SO_RCVBUF.png","hash":"245fbf5ead712b6a18e5eccb7c854dac6fcb9a15","modified":1638770290565},{"_id":"public/pic/SO_SNDBUF.png","hash":"32dca0500c8707e57f9c3bdc733052bbc9b18ab4","modified":1638770290565},{"_id":"public/pic/Reactor.png","hash":"8b1f9aa8c4eeab565fb2d2b3fbf34b397cb0ce7c","modified":1638770290565},{"_id":"public/pic/TCP头部选项一般结构.png","hash":"7236cfecb551c7644ca5006e589465259687e8c0","modified":1638770290565},{"_id":"public/pic/SO_RCVBUF1.png","hash":"d87c4ec8ecae690da2a60af6e9810344d7a4d843","modified":1638770290565},{"_id":"public/pic/TCP带外数据.png","hash":"c33628ecbd8294480c8e01f775b4d8d6197b5898","modified":1638770290565},{"_id":"public/pic/Web调试2.png","hash":"abd40732f157c1a86c6767aaebb826b5adb37477","modified":1638770290565},{"_id":"public/pic/TCP收发数据结果.png","hash":"f77dc6a79955ef233c34a37428b1397d393c6a81","modified":1638770290565},{"_id":"public/pic/Web调试3.png","hash":"0292f4a524e5ff9be80e6ecd9b97fbeb62c3c7d2","modified":1638770290565},{"_id":"public/pic/arp命令2.png","hash":"2bff10f13791965338e621c0032355e919b55ab7","modified":1638770290565},{"_id":"public/pic/fork之后的管道.png","hash":"a4b7e4064666a80bfb57c8ee789355d4aa308b67","modified":1638770290565},{"_id":"public/pic/listen测试.png","hash":"6711e3fafbb21a774ac8ceda52765c9555185d81","modified":1638770290565},{"_id":"public/pic/nc测试.png","hash":"1a5bfd03957937cb79135838c9694487baa1262a","modified":1638770290565},{"_id":"public/pic/host命令.png","hash":"9568652a99af4bad09f9011448c45da42b767b9b","modified":1638770290565},{"_id":"public/pic/netstat命令1.png","hash":"9153a3acf93e0d25dcb4bc71c718a5a77b9f6467","modified":1638770290565},{"_id":"public/pic/queue结构.png","hash":"966985f62f7300f1ef0374b334c5afddbc7db4c6","modified":1638770290565},{"_id":"public/pic/route命令.png","hash":"d43389545b676d1d1e99f182af4e7b8239eff81e","modified":1638770290565},{"_id":"public/pic/stack结构.png","hash":"e87a5d1edce60cc7e74a325ccd13685574cd2ffa","modified":1638770290565},{"_id":"public/pic/tcp抓包1.png","hash":"3759f74d7a4502d96a3a48e080333eb3c69ab673","modified":1638770290565},{"_id":"public/pic/shutdown参数.png","hash":"2ec4c0bbca95d8a74fbcb580f02e5b5397183833","modified":1638770290565},{"_id":"public/pic/tcpip数据封装.png","hash":"8a8f5bd30864267fcd6b0a105dc24950a5ffc989","modified":1638770290565},{"_id":"public/pic/telnet测试.png","hash":"85070316a65d5870d41c14920ba891f02c6a4b87","modified":1638770290565},{"_id":"public/pic/telnet测试四次挥手.png","hash":"a7f890fb07a8916ea7cd82775904642bdbea7864","modified":1638770290565},{"_id":"public/pic/telnet问题.png","hash":"41b5a738b2b36ebbb1a8078e245d9956558be090","modified":1638770290565},{"_id":"public/pic/tcp抓包2.png","hash":"49d7925cd3f18c1ed85ca6441d9dae017eab8e5c","modified":1638770290565},{"_id":"public/pic/从父到子的管道.png","hash":"4eb3a250b11e876bd37c3655d2c38c43a1830025","modified":1638770290565},{"_id":"public/pic/信号驱动型IO.png","hash":"c60a28075ac51da5e3547f0a40617df37d4d309f","modified":1638770290565},{"_id":"public/pic/代理服务器.png","hash":"aa2fb7eff03053a660d1b7ce4786ba2c05a12e3c","modified":1638770290565},{"_id":"public/pic/半同步半反应堆.png","hash":"4fc03629f2cf67a723508521152f90fabb6780a2","modified":1638770290565},{"_id":"public/pic/半同步半异步.png","hash":"e998b9e4720f79a99608fe791db00ca74173ce08","modified":1638770290565},{"_id":"public/pic/半同步半异步模式.png","hash":"e9f3a067d2dc930fcad20638a98c0d5217fb11e4","modified":1638770290565},{"_id":"public/pic/单继承但不重写虚函数表.png","hash":"407e490de0a65b63cca67cbe832aaf7fe08108d1","modified":1638770290565},{"_id":"public/pic/异步IO.png","hash":"429c255ee7963de06342c1a27d6de6dd4c6b4323","modified":1638770290565},{"_id":"public/pic/抓包带外数据.png","hash":"da44d30a3b76e4355d3f10ec35d5a259941e2f4b","modified":1638770290565},{"_id":"public/pic/单继承重写虚函数.png","hash":"4f512ba6f5900fc0816aaed497f31dfcacc75270","modified":1638770290565},{"_id":"public/pic/查询问题格式.png","hash":"4939d137529c2e93f854d01384688724ae645b4a","modified":1638770290565},{"_id":"public/pic/知名端口号.png","hash":"ef53b7e0c68b6b0d05eb8dd4e10969724086656e","modified":1638770290565},{"_id":"public/pic/汉诺塔.png","hash":"83d24f40618a3ada51b518469f1514d08c681ae7","modified":1638770290565},{"_id":"public/pic/资源记录格式.png","hash":"c9c991d886e9b20f90df8af710ad6ea4cdaffd12","modified":1638770290565},{"_id":"public/pic/虚函数表.png","hash":"d977dc9ee9eb61353830dbe3634e358b9e9af81a","modified":1638770290565},{"_id":"public/pic/线程状态图.png","hash":"58dd74c37e124b72728be0603b306354bbd0cadc","modified":1638770290565},{"_id":"public/pic/进程池模型.png","hash":"87e163ef8eb5bbf1a058210666f204f83a36ed76","modified":1638770290565},{"_id":"public/pic/CGI调试7.png","hash":"3fd38d0fadb3b8604b175a48eac411a01dab508e","modified":1638770290565},{"_id":"public/pic/DNS报文.png","hash":"f43a47d427141923d7254101e278099d5c56567b","modified":1638770290565},{"_id":"public/pic/CGI调试6.png","hash":"1febebf95af6b1adb8a6466ef6b89c0825d121e7","modified":1638770290565},{"_id":"public/pic/IPv4头部.png","hash":"f69e4eed6b6d84f7d02fa753c14d16190efb4a77","modified":1638770290565},{"_id":"public/pic/DNS_tcpdump2.png","hash":"d14d6447e7949a482adb39e12c80692c86af63d6","modified":1638770290565},{"_id":"public/pic/IP分片.png","hash":"c26cc97bd98913ca5fb360d546bd91174728ae44","modified":1638770290565},{"_id":"public/pic/Proactor.png","hash":"8e1ab1ab0f856b39d88dcd4201bde8b8161d0b0a","modified":1638770290565},{"_id":"public/pic/IPv6头部.png","hash":"e838f6d1951c77b233cb6b06a12dd7ccb9dc4c4d","modified":1638770290565},{"_id":"public/pic/TCP三次握手建立连接.png","hash":"5c515a2e54324a3c1db3c288fb4a97f05fc89c2e","modified":1638770290565},{"_id":"public/pic/Proactor1.png","hash":"1182abf78b13ff2a5b6507fc42191168e20a5e3a","modified":1638770290565},{"_id":"public/pic/TCP首部.png","hash":"2301d7f7cb7f37bd081f44bbc020e993b015131d","modified":1638770290565},{"_id":"public/pic/listen测试3.png","hash":"d13c796325e959c6d4fd5da7e0055b1eaeebdf47","modified":1638770290565},{"_id":"public/pic/Web调试1.png","hash":"b9870bfe043ffdf1aee0961738def9e9974ed0a3","modified":1638770290565},{"_id":"public/pic/splice函数flag参数.png","hash":"8be2d21d0682ad79d5da3b40a7a34b15e8b9b841","modified":1638770290565},{"_id":"public/pic/poll事件表.png","hash":"c7f3e0ab5f1ca32649f9a053b12faae5f67bd2a8","modified":1638770290565},{"_id":"public/pic/tcpdump抓取四次挥手.png","hash":"07ac62485d60b69813caa27eb707c5cd69022eb6","modified":1638770290565},{"_id":"public/pic/常见TCP头部选项.png","hash":"dea9a20075315ef542c624e189f97fb9acb3fd96","modified":1638770290565},{"_id":"public/pic/发送方滑动窗口.png","hash":"454472b46a7aac90e2351e480e44b524d99a321e","modified":1638770290565},{"_id":"public/pic/并发模式同步异步.png","hash":"13c688dc3d9ae8edfdadbd3bd9a5f37f7329f707","modified":1638770290565},{"_id":"public/pic/快重传.png","hash":"5ed460ba1e9f46337401f48176a4182badcb6ecc","modified":1638770290565},{"_id":"public/pic/慢开始.png","hash":"94c924848f657775088c1e4174e5a78cf72fe9eb","modified":1638770290565},{"_id":"public/pic/模板方法3.png","hash":"e597205b920544a005bd4824119d7c5433d69b3e","modified":1638770290565},{"_id":"public/pic/模板方法2.png","hash":"68f005b776843121677438d8e0caaeef12fa85a7","modified":1638770290565},{"_id":"public/pic/模板方法1.png","hash":"7d4745c02a5fb05d6668ac4592944a70cab45489","modified":1638770290565},{"_id":"public/pic/模板方法类图.png","hash":"6ce9488d31e8e7f12f2e3149d1ca0f97b90ee19a","modified":1638770290565},{"_id":"public/pic/策略模式类图.png","hash":"a2c66e26a7082463e0df114c70410fed3db1bf95","modified":1638770290565},{"_id":"public/pic/阻塞型网络IO.png","hash":"17999d12032cf799ae5a7c5ab6c84a4b2328710c","modified":1638770290565},{"_id":"public/pic/IP模块工作流程图.png","hash":"cc063ae4734f6b0fecf114a5640a9d31e2d6eefd","modified":1638770290565},{"_id":"public/pic/Cookie.png","hash":"5d8e10462b77930b79e0f8163e3c50a70f3900a0","modified":1638770290565},{"_id":"public/pic/STL容器.png","hash":"1fde177e74e8d0b580dfa402e02a8335b1584fb2","modified":1638770290565},{"_id":"public/pic/TCP四次挥手释放连接.png","hash":"c125a34c538bebfdc828a0c482e37463fc4c7e1e","modified":1638770290565},{"_id":"public/pic/getnameinfo_flags.png","hash":"8b50b4593e8c89d37f68e69954392b55cae62744","modified":1638770290565},{"_id":"public/pic/Web调试4.png","hash":"4c8b2b0a854812e8d7babce6890e8893429aaa51","modified":1638770290565},{"_id":"public/pic/deque结构.png","hash":"ec831ba886fd0c1b07351d6e6e88505a33cec0dd","modified":1638770290565},{"_id":"public/pic/linux进程内存分布.png","hash":"55fa3e25fa9dfb79fac978679c3227f980ff757a","modified":1638770290565},{"_id":"public/pic/listen测试2.png","hash":"bacdcb6bc7a33b0b4a9ac262f944b520aff08b5e","modified":1638770290565},{"_id":"public/pic/地址信息错误码.png","hash":"6fb95e17e8850cb8a670017bf2cdfb55f2e7930f","modified":1638770290565},{"_id":"public/pic/socket选项.png","hash":"e8d5d3ba33e3f3dec65306e4b4839bd86af75b83","modified":1638770290565},{"_id":"public/pic/多重继承无虚函数覆盖.png","hash":"1deb110b6161093c8b9510862754f9eb9a37ba41","modified":1638770290565},{"_id":"public/pic/多继承无虚函数覆盖的虚函数表.png","hash":"fd3b8b1d24bc3b953018019983c8243b0ee1ccc0","modified":1638770290565},{"_id":"public/pic/多重继承有虚函数重写.png","hash":"883017b99ef8e9f0716f7ac3dcd3774c6f659278","modified":1638770290565},{"_id":"public/pic/多重继承有虚函数重写的虚函数表.png","hash":"2942cdec1aa636837f7e889de112fa1b553629cb","modified":1638770290565},{"_id":"public/pic/快恢复.png","hash":"49cfcec07c0fdb1e83ac3d01005a4402eb58e679","modified":1638770290565},{"_id":"public/pic/慢开始和拥塞避免.png","hash":"9ddcf24a8df3b8a88729d805e8e7be68f1f1422c","modified":1638770290565},{"_id":"public/pic/接收方滑动窗口.png","hash":"62cb7092ed0a72cd2f0a0658997ca748923bafcf","modified":1638770290565},{"_id":"public/pic/网络IO复用.png","hash":"e154403298ad25ef8394202bd553b14e7dee6b11","modified":1638770290565},{"_id":"public/pic/非阻塞型网络IO.png","hash":"d17183835a9bff2e6e9292d940594f4fcddcf952","modified":1638770290565},{"_id":"public/pic/HTTP请求方法.png","hash":"215ac7f12a58b3a60ea287ae2698f99cf67df83a","modified":1638770290565},{"_id":"public/pic/ai_flags.png","hash":"80b27ad4964fabd582596813e564a235dfe3a90e","modified":1638770290565},{"_id":"public/pic/数据读写flags.png","hash":"1dbafa1e1522e04ced61e838a7f6f6011dbfbeca","modified":1638770290565},{"_id":"public/pic/pycharm分屏.png","hash":"fab766433d83b1c28b8f900a8c586f4e90492174","modified":1638770290565},{"_id":"public/pic/线程内核对象.png","hash":"c3cbc1ab97f90857aee05bb6deb5318349a95e46","modified":1638770290565},{"_id":"public/pic/TCP状态转移过程.png","hash":"2e6b89ef796ea9977e5d574f6cd159dff6ae1040","modified":1638770290565},{"_id":"public/pic/路由表.png","hash":"a7e24c900be0782d44fcd6197fce0191a4417056","modified":1638770290565},{"_id":"public/pic/IPv6扩展头部.png","hash":"cf5527323f01fe4e9a45feac37df723ca4ea54d0","modified":1638770290565},{"_id":"public/pic/HTTP状态码.png","hash":"4579cbf34238fe60821e58ccf58d07272500dd02","modified":1638770290565},{"_id":"public/pic/简单工厂.png","hash":"58706876003b634c0e2e4c083c15abce714ac77f","modified":1638770290565},{"_id":"public/pic/initializer_list.png","hash":"871a215cd72623c21e58195f91912c8cecb01b5f","modified":1638770290565},{"_id":"public/pic/lsof输出.png","hash":"8047a379e7b96c22b89bcc651a0a8df5b803e3a5","modified":1638770290565},{"_id":"public/pic/STL组件之间的关系.png","hash":"c997f98c0e039b6756fc932e9038c51d2b8d775b","modified":1638770290565},{"_id":"public/pic/菱形虚继承.png","hash":"3e9aed9c9b7593a64100cc1663df86a441998d09","modified":1638770290565},{"_id":"public/pic/简单虚继承对象模型.png","hash":"0da2f102cd5e67f4f7d42feac56a285bf8f18f47","modified":1638770290565},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1638800270532},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1638800270534},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1638800270533},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1638800270533},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1638800270534},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1638800270534},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1638800270534},{"_id":"themes/yilia/_config.yml","hash":"c3a1694c111e2e1f05a174bd893fe951038fbda2","modified":1638800270535},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1638800270550},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1638800270578},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1638800270535},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1638800270535},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1638800270535},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1638800270536},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1638800270536},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1638800270536},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1638800270536},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1638800270546},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1638800270547},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1638800270547},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1638800270549},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1638800270549},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1638800270549},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1638800270549},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1638800270575},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1638800270578},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1638800270550},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1638800270569},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1638800270544},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1638800270576},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1638800270578},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1638800270537},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1638800270537},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1638800270538},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1638800270538},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1638800270538},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1638800270538},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1638800270539},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1638800270538},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1638800270539},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1638800270540},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1638800270540},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1638800270540},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1638800270541},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1638800270540},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1638800270546},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1638800270545},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1638800270569},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1638800270571},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1638800270572},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1638800270573},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1638800270570},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1638800270574},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1638800270573},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1638800270551},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1638800270551},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1638800270551},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1638800270551},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1638800270552},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1638800270552},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1638800270553},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1638800270552},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1638800270553},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1638800270557},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1638800270559},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1638800270560},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1638800270560},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1638800270575},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1638800270575},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1638800270560},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1638800270562},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1638800270562},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1638800270563},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1638800270563},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1638800270563},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1638800270564},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1638800270564},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1638800270564},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1638800270565},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1638800270565},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1638800270565},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1638800270565},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1638800270565},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1638800270567},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1638800270566},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1638800270567},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1638800270567},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1638800270567},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1638800270567},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1638800270568},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1638800270568},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1638800270568},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1638800270568},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1638800270569},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1638800270569},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1638800270544},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1638800270541},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1638800270541},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1638800270541},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1638800270542},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1638800270542},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1638800270542},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1638800270542},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1638800270543},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1638800270543},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1638800270543},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1638800270554},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1638800270554},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1638800270555},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1638800270556},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1638800270556},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1638800270558},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1638800270559},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1638800270558},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1638800270559},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1638800270561},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1638800270561},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1638800270561}],"Category":[],"Data":[],"Page":[{"layout":"404","title":"[404]","description":"May the Force be with you :&#41;","_content":"","source":"404/404.md","raw":"---\nlayout: 404\ntitle: \"[404]\"\ndescription: \"May the Force be with you :&#41;\"\n---","date":"2021-12-06T05:32:04.766Z","updated":"2021-12-06T05:30:36.989Z","path":"404/404.html","comments":1,"_id":"ckwu9ip6w000096ca5e7gddr0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"To be a better man","layout":"about","date":"2018-09-19T11:54:43.000Z","_content":"\n我叫高犇，来自江苏苏州，在哈尔滨理工大学测控专业学习，在做出职业和专业的选择之后，我开通了这个博客，用来复习和记录学习生涯，给自己的定位是C++后端工程师。\n\n\n\n> 有时候，我们不得不坚强，于是乎，在假装坚强中，就真的越来越坚强。这是真的。——杨绛 \n\n","source":"about/index.md","raw":"---\ntitle: To be a better man \nlayout: about\ndate: 2018-09-19 19:54:43\n---\n\n我叫高犇，来自江苏苏州，在哈尔滨理工大学测控专业学习，在做出职业和专业的选择之后，我开通了这个博客，用来复习和记录学习生涯，给自己的定位是C++后端工程师。\n\n\n\n> 有时候，我们不得不坚强，于是乎，在假装坚强中，就真的越来越坚强。这是真的。——杨绛 \n\n","updated":"2021-12-06T05:30:36.995Z","path":"about/index.html","comments":1,"_id":"ckwu9ip73000296cadls119dh","content":"<p>我叫高犇，来自江苏苏州，在哈尔滨理工大学测控专业学习，在做出职业和专业的选择之后，我开通了这个博客，用来复习和记录学习生涯，给自己的定位是C++后端工程师。</p>\n<blockquote>\n<p>有时候，我们不得不坚强，于是乎，在假装坚强中，就真的越来越坚强。这是真的。——杨绛 </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>我叫高犇，来自江苏苏州，在哈尔滨理工大学测控专业学习，在做出职业和专业的选择之后，我开通了这个博客，用来复习和记录学习生涯，给自己的定位是C++后端工程师。</p>\n<blockquote>\n<p>有时候，我们不得不坚强，于是乎，在假装坚强中，就真的越来越坚强。这是真的。——杨绛 </p>\n</blockquote>\n"}],"Post":[{"title":"ARP协议分析","date":"2019-03-06T12:22:07.000Z","_content":"\n## ARP协议工作原理\n\nARP协议是TCP/IP栈中数据链路层很重要的一个协议，能实现任意网络层地址到任意物理地址的转换，比如ip地址到MAC地址的转换。ARP通信在TCP连接之前就建立完成。\n\n工作原理：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络中的其他极其都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。\n\n<!-- more -->\n\n## 以太网ARP请求/应答报文详解\n\n![ARP报文](/pic/ARP报文.png)\n\n1.硬件类型字段定义物理地址的类型，值为1表示MAC地址\n\n2.协议类型字段表示要映射的协议地址类型，值为0x800,表示IP地址\n\n3.硬件地址长度字段和协议地址长度字段，单位是字节，对MAC地址来说，长度为6，对IP(v4)地址来说，长度为4\n\n4.操作字段指出4种操作类型：ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）、RARP应答（值为4）\n\n5.最后4个字段指定通信双方的以太网地址和IP地址。\n\n## ARP高速缓存\n\n在现实情况中，ARP的工作方式就是，先在ARP缓存中找，找不到了再在局域网上“发帖求助”。也就是说ARP维护一个高速缓存，其中包含经常访问或者最近访问的机器的IP地址和物理地址的映射。\n\n**这样避免了重复的ARP请求，提高了发送数据包的效率**\n\nLinux下可以用arp命令来查看和修改ARP高速缓存\n\n使用 arp　　当没有参数时打印（到屏幕上）当前表中的内容。\n\n![](/pic/arp命令1.png)\n\narp -a　　　以BSD风格输出ARP缓存中的内容\n\n![](/pic/arp命令1.png)\n\nsudo arp -d  ip　　　　　　　 #删除该ip对应的主机所对应的ARP缓存项\n\nsudo arp -s   ip  MAC 　　　　#添加该ip对应的主机所对应的ARP缓存项\n\n## 使用场景\n\nARP协议使用场景：网络层使用IP地址寻址一台机器，但是数据链路层使用物理地址来寻址一台机器，因此网络层必须先将目标机器的IP地址转化成物理地址，才能使用数据链路层提供的服务。\n\nRARP协议使用场景：仅用于网络上的某些无盘工作站，因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上的所有机器的物理地址到IP地址的映射。\n\n\n\n\n\n","source":"_posts/ARP协议分析.md","raw":"---\ntitle: ARP协议分析\ndate: 2019-03-06 20:22:07\ntags:\n- 网络\n- Linux高性能服务器编程\n---\n\n## ARP协议工作原理\n\nARP协议是TCP/IP栈中数据链路层很重要的一个协议，能实现任意网络层地址到任意物理地址的转换，比如ip地址到MAC地址的转换。ARP通信在TCP连接之前就建立完成。\n\n工作原理：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络中的其他极其都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。\n\n<!-- more -->\n\n## 以太网ARP请求/应答报文详解\n\n![ARP报文](/pic/ARP报文.png)\n\n1.硬件类型字段定义物理地址的类型，值为1表示MAC地址\n\n2.协议类型字段表示要映射的协议地址类型，值为0x800,表示IP地址\n\n3.硬件地址长度字段和协议地址长度字段，单位是字节，对MAC地址来说，长度为6，对IP(v4)地址来说，长度为4\n\n4.操作字段指出4种操作类型：ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）、RARP应答（值为4）\n\n5.最后4个字段指定通信双方的以太网地址和IP地址。\n\n## ARP高速缓存\n\n在现实情况中，ARP的工作方式就是，先在ARP缓存中找，找不到了再在局域网上“发帖求助”。也就是说ARP维护一个高速缓存，其中包含经常访问或者最近访问的机器的IP地址和物理地址的映射。\n\n**这样避免了重复的ARP请求，提高了发送数据包的效率**\n\nLinux下可以用arp命令来查看和修改ARP高速缓存\n\n使用 arp　　当没有参数时打印（到屏幕上）当前表中的内容。\n\n![](/pic/arp命令1.png)\n\narp -a　　　以BSD风格输出ARP缓存中的内容\n\n![](/pic/arp命令1.png)\n\nsudo arp -d  ip　　　　　　　 #删除该ip对应的主机所对应的ARP缓存项\n\nsudo arp -s   ip  MAC 　　　　#添加该ip对应的主机所对应的ARP缓存项\n\n## 使用场景\n\nARP协议使用场景：网络层使用IP地址寻址一台机器，但是数据链路层使用物理地址来寻址一台机器，因此网络层必须先将目标机器的IP地址转化成物理地址，才能使用数据链路层提供的服务。\n\nRARP协议使用场景：仅用于网络上的某些无盘工作站，因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上的所有机器的物理地址到IP地址的映射。\n\n\n\n\n\n","slug":"ARP协议分析","published":1,"updated":"2021-12-06T05:30:36.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip70000196ca7iw0bme7","content":"<h2 id=\"ARP协议工作原理\"><a href=\"#ARP协议工作原理\" class=\"headerlink\" title=\"ARP协议工作原理\"></a>ARP协议工作原理</h2><p>ARP协议是TCP/IP栈中数据链路层很重要的一个协议，能实现任意网络层地址到任意物理地址的转换，比如ip地址到MAC地址的转换。ARP通信在TCP连接之前就建立完成。</p>\n<p>工作原理：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络中的其他极其都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"以太网ARP请求-应答报文详解\"><a href=\"#以太网ARP请求-应答报文详解\" class=\"headerlink\" title=\"以太网ARP请求/应答报文详解\"></a>以太网ARP请求/应答报文详解</h2><p><img src=\"/pic/ARP%E6%8A%A5%E6%96%87.png\" alt=\"ARP报文\"></p>\n<p>1.硬件类型字段定义物理地址的类型，值为1表示MAC地址</p>\n<p>2.协议类型字段表示要映射的协议地址类型，值为0x800,表示IP地址</p>\n<p>3.硬件地址长度字段和协议地址长度字段，单位是字节，对MAC地址来说，长度为6，对IP(v4)地址来说，长度为4</p>\n<p>4.操作字段指出4种操作类型：ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）、RARP应答（值为4）</p>\n<p>5.最后4个字段指定通信双方的以太网地址和IP地址。</p>\n<h2 id=\"ARP高速缓存\"><a href=\"#ARP高速缓存\" class=\"headerlink\" title=\"ARP高速缓存\"></a>ARP高速缓存</h2><p>在现实情况中，ARP的工作方式就是，先在ARP缓存中找，找不到了再在局域网上“发帖求助”。也就是说ARP维护一个高速缓存，其中包含经常访问或者最近访问的机器的IP地址和物理地址的映射。</p>\n<p><strong>这样避免了重复的ARP请求，提高了发送数据包的效率</strong></p>\n<p>Linux下可以用arp命令来查看和修改ARP高速缓存</p>\n<p>使用 arp　　当没有参数时打印（到屏幕上）当前表中的内容。</p>\n<p><img src=\"/pic/arp%E5%91%BD%E4%BB%A41.png\" alt=\"\"></p>\n<p>arp -a　　　以BSD风格输出ARP缓存中的内容</p>\n<p><img src=\"/pic/arp%E5%91%BD%E4%BB%A41.png\" alt=\"\"></p>\n<p>sudo arp -d  ip　　　　　　　 #删除该ip对应的主机所对应的ARP缓存项</p>\n<p>sudo arp -s   ip  MAC 　　　　#添加该ip对应的主机所对应的ARP缓存项</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>ARP协议使用场景：网络层使用IP地址寻址一台机器，但是数据链路层使用物理地址来寻址一台机器，因此网络层必须先将目标机器的IP地址转化成物理地址，才能使用数据链路层提供的服务。</p>\n<p>RARP协议使用场景：仅用于网络上的某些无盘工作站，因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上的所有机器的物理地址到IP地址的映射。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"ARP协议工作原理\"><a href=\"#ARP协议工作原理\" class=\"headerlink\" title=\"ARP协议工作原理\"></a>ARP协议工作原理</h2><p>ARP协议是TCP/IP栈中数据链路层很重要的一个协议，能实现任意网络层地址到任意物理地址的转换，比如ip地址到MAC地址的转换。ARP通信在TCP连接之前就建立完成。</p>\n<p>工作原理：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络中的其他极其都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。</p>","more":"<h2 id=\"以太网ARP请求-应答报文详解\"><a href=\"#以太网ARP请求-应答报文详解\" class=\"headerlink\" title=\"以太网ARP请求/应答报文详解\"></a>以太网ARP请求/应答报文详解</h2><p><img src=\"/pic/ARP%E6%8A%A5%E6%96%87.png\" alt=\"ARP报文\"></p>\n<p>1.硬件类型字段定义物理地址的类型，值为1表示MAC地址</p>\n<p>2.协议类型字段表示要映射的协议地址类型，值为0x800,表示IP地址</p>\n<p>3.硬件地址长度字段和协议地址长度字段，单位是字节，对MAC地址来说，长度为6，对IP(v4)地址来说，长度为4</p>\n<p>4.操作字段指出4种操作类型：ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）、RARP应答（值为4）</p>\n<p>5.最后4个字段指定通信双方的以太网地址和IP地址。</p>\n<h2 id=\"ARP高速缓存\"><a href=\"#ARP高速缓存\" class=\"headerlink\" title=\"ARP高速缓存\"></a>ARP高速缓存</h2><p>在现实情况中，ARP的工作方式就是，先在ARP缓存中找，找不到了再在局域网上“发帖求助”。也就是说ARP维护一个高速缓存，其中包含经常访问或者最近访问的机器的IP地址和物理地址的映射。</p>\n<p><strong>这样避免了重复的ARP请求，提高了发送数据包的效率</strong></p>\n<p>Linux下可以用arp命令来查看和修改ARP高速缓存</p>\n<p>使用 arp　　当没有参数时打印（到屏幕上）当前表中的内容。</p>\n<p><img src=\"/pic/arp%E5%91%BD%E4%BB%A41.png\" alt=\"\"></p>\n<p>arp -a　　　以BSD风格输出ARP缓存中的内容</p>\n<p><img src=\"/pic/arp%E5%91%BD%E4%BB%A41.png\" alt=\"\"></p>\n<p>sudo arp -d  ip　　　　　　　 #删除该ip对应的主机所对应的ARP缓存项</p>\n<p>sudo arp -s   ip  MAC 　　　　#添加该ip对应的主机所对应的ARP缓存项</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>ARP协议使用场景：网络层使用IP地址寻址一台机器，但是数据链路层使用物理地址来寻址一台机器，因此网络层必须先将目标机器的IP地址转化成物理地址，才能使用数据链路层提供的服务。</p>\n<p>RARP协议使用场景：仅用于网络上的某些无盘工作站，因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上的所有机器的物理地址到IP地址的映射。</p>"},{"title":"DNS","date":"2019-03-07T01:23:40.000Z","_content":"\n## DNS工作原理\n\nDNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。\n\n\n\n<!-- more -->\n\n## DNS查询和应答报文详解\n\n![DNS查询和应答报文](/pic/DNS报文.png)\n\n16位标识：标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应\n\n16位标记：协商具体的通信方式和反馈通信状态。\n\n标志字段细节如下：\n\n![](/pic/DNS报文标志字段.png)\n\n- QR：查询/应答标志。0表示这是一个查询报文，1表示这个一个应答报文\n- opcode：定义查询和应答的类型。0表示标准查询，1表示反向查询(由IP获得域名)，2表示请求服务器状态\n- AA：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器\n- TC：截断标志，仅当DNS报文使用UDP服务时使用，因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。\n- RD：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，知道获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考\n- RA：允许递归标志，仅供应答报文使用,1表示支持递归查询\n- zero：这3位未用，必须都置0\n- rcode：4位返回码，表示应答的状态。常用值0（无错误），3（域名不存在）\n\n接下来的4个字段分别指出DNS报文的最后4个字段的资源记录数目。对查询报文而言，一般包含一个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。\n\n查询问题的格式如下：\n\n![](/pic/查询问题格式.png)\n\n查询名：以一定的格式封装了要查询的主机域名。\n\n查询类型：表示如何执行查询操作\n\n- 类型A：值为1，表示获取目标主机的IP地址\n- 类型CNAME：值为5，表示获得目标主机的别名\n- 类型PTR：值为12，表示反向查询\n\n查询类：通常是1，表示获取因特网地址（IP地址）\n\n应答字段、授权字段和额外信息字段都使用资源记录格式。\n\n资源记录格式如下：\n\n![](/pic/资源记录格式.png)\n\n域名：该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同\n\n类型和类字段与DNS查询问题的对应字段相同\n\n生存时间：表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒\n\n资源数据长度和资源数据字段的内容取决于类型字段。对类型A而言，资源数据是\n\n32位的IPv4地址，资源数据长度时4(字节)。\n\n## 访问DNS服务\n\nLinux下使用/etc/resolv.conf文件来存放DNS服务器的IP地址\n\nLinux下常用的访问DNS服务器的客户端程序是host，host使用DNS协议和DNS服务器通信\n\n![](/pic/host命令.png)\n\n-t选项告诉DNS协议使用哪种查询类型，这里用A，通过域名查询IP地址\n\n由结果可见，www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。\n\n## tcpdump抓包\n\n![](/pic/DNS_tcpdump1.png)\n\n这两个数据包开始的\"IP\"指出，它们后面的内容是IP数据包\n\ntcpdump以“IP 地址.端口号”的形式来描述通信的某一端；以\">\"表示数据传输方向，\">\"前面是源端，后面是目的端。\n\n由此可见第一个数据包是从我的虚拟机(IP为\"192.168.152.129\")向其首选DNS服务器(IP地址是192.168.152.2)发送的DNS查询报文(目标端口53是DNS服务器使用的端口)，第二个数据包是服务器反馈的DNS应答报文。\n\n在第一个数据包中，数值61258是DNS查询报文的16位标识值，因此该值也出现在应答报文中。“+“表示开启递归查询标志，”A?“表示使用A类型的查询方式。\"www.baidu.com\"是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度(以字节为单位)。\n\n第二个数据包中的 3/0/0 表示该报文中包含3个应答资源记录、0个授权资源记录、0个额外信息记录。后面的三项就是表示3个应答资源记录，该报文长度时90字节。\n\n书上没有展示-x之后的效果，自己试了一下\n\n![](/pic/DNS_tcpdump2.png)\n\n由于抓取的是IP数据包，因此还封装了IP头和UDP头，定位DNS数据包不太容易。\n\n根据DNS查询报文的标识值10807，算出16进制0x2a37，在数据包中能找到2a37\n\n观察2a37后两个字节0x0100代表DNS查询标志字段，对比DNS标志字段的详细信息可见第7位(从0开始)正是RD字段，1表示执行递归查询。接下来两个字节0x0001表示1个问题个数，然后六个字节都是0x00，表示0个应答资源记录、0个授权资源记录、0个额外资源数目。然后分析遇到了问题(很难受，先码上吧，以后解决)。","source":"_posts/DNS.md","raw":"---\ntitle: DNS\ndate: 2019-03-07 09:23:40\ntags:\n- 网络\n- Linux高性能服务器编程\n---\n\n## DNS工作原理\n\nDNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。\n\n\n\n<!-- more -->\n\n## DNS查询和应答报文详解\n\n![DNS查询和应答报文](/pic/DNS报文.png)\n\n16位标识：标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应\n\n16位标记：协商具体的通信方式和反馈通信状态。\n\n标志字段细节如下：\n\n![](/pic/DNS报文标志字段.png)\n\n- QR：查询/应答标志。0表示这是一个查询报文，1表示这个一个应答报文\n- opcode：定义查询和应答的类型。0表示标准查询，1表示反向查询(由IP获得域名)，2表示请求服务器状态\n- AA：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器\n- TC：截断标志，仅当DNS报文使用UDP服务时使用，因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。\n- RD：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，知道获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考\n- RA：允许递归标志，仅供应答报文使用,1表示支持递归查询\n- zero：这3位未用，必须都置0\n- rcode：4位返回码，表示应答的状态。常用值0（无错误），3（域名不存在）\n\n接下来的4个字段分别指出DNS报文的最后4个字段的资源记录数目。对查询报文而言，一般包含一个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。\n\n查询问题的格式如下：\n\n![](/pic/查询问题格式.png)\n\n查询名：以一定的格式封装了要查询的主机域名。\n\n查询类型：表示如何执行查询操作\n\n- 类型A：值为1，表示获取目标主机的IP地址\n- 类型CNAME：值为5，表示获得目标主机的别名\n- 类型PTR：值为12，表示反向查询\n\n查询类：通常是1，表示获取因特网地址（IP地址）\n\n应答字段、授权字段和额外信息字段都使用资源记录格式。\n\n资源记录格式如下：\n\n![](/pic/资源记录格式.png)\n\n域名：该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同\n\n类型和类字段与DNS查询问题的对应字段相同\n\n生存时间：表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒\n\n资源数据长度和资源数据字段的内容取决于类型字段。对类型A而言，资源数据是\n\n32位的IPv4地址，资源数据长度时4(字节)。\n\n## 访问DNS服务\n\nLinux下使用/etc/resolv.conf文件来存放DNS服务器的IP地址\n\nLinux下常用的访问DNS服务器的客户端程序是host，host使用DNS协议和DNS服务器通信\n\n![](/pic/host命令.png)\n\n-t选项告诉DNS协议使用哪种查询类型，这里用A，通过域名查询IP地址\n\n由结果可见，www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。\n\n## tcpdump抓包\n\n![](/pic/DNS_tcpdump1.png)\n\n这两个数据包开始的\"IP\"指出，它们后面的内容是IP数据包\n\ntcpdump以“IP 地址.端口号”的形式来描述通信的某一端；以\">\"表示数据传输方向，\">\"前面是源端，后面是目的端。\n\n由此可见第一个数据包是从我的虚拟机(IP为\"192.168.152.129\")向其首选DNS服务器(IP地址是192.168.152.2)发送的DNS查询报文(目标端口53是DNS服务器使用的端口)，第二个数据包是服务器反馈的DNS应答报文。\n\n在第一个数据包中，数值61258是DNS查询报文的16位标识值，因此该值也出现在应答报文中。“+“表示开启递归查询标志，”A?“表示使用A类型的查询方式。\"www.baidu.com\"是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度(以字节为单位)。\n\n第二个数据包中的 3/0/0 表示该报文中包含3个应答资源记录、0个授权资源记录、0个额外信息记录。后面的三项就是表示3个应答资源记录，该报文长度时90字节。\n\n书上没有展示-x之后的效果，自己试了一下\n\n![](/pic/DNS_tcpdump2.png)\n\n由于抓取的是IP数据包，因此还封装了IP头和UDP头，定位DNS数据包不太容易。\n\n根据DNS查询报文的标识值10807，算出16进制0x2a37，在数据包中能找到2a37\n\n观察2a37后两个字节0x0100代表DNS查询标志字段，对比DNS标志字段的详细信息可见第7位(从0开始)正是RD字段，1表示执行递归查询。接下来两个字节0x0001表示1个问题个数，然后六个字节都是0x00，表示0个应答资源记录、0个授权资源记录、0个额外资源数目。然后分析遇到了问题(很难受，先码上吧，以后解决)。","slug":"DNS","published":1,"updated":"2021-12-06T05:30:36.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip73000396caabpj41i6","content":"<h2 id=\"DNS工作原理\"><a href=\"#DNS工作原理\" class=\"headerlink\" title=\"DNS工作原理\"></a>DNS工作原理</h2><p>DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"DNS查询和应答报文详解\"><a href=\"#DNS查询和应答报文详解\" class=\"headerlink\" title=\"DNS查询和应答报文详解\"></a>DNS查询和应答报文详解</h2><p><img src=\"/pic/DNS%E6%8A%A5%E6%96%87.png\" alt=\"DNS查询和应答报文\"></p>\n<p>16位标识：标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应</p>\n<p>16位标记：协商具体的通信方式和反馈通信状态。</p>\n<p>标志字段细节如下：</p>\n<p><img src=\"/pic/DNS%E6%8A%A5%E6%96%87%E6%A0%87%E5%BF%97%E5%AD%97%E6%AE%B5.png\" alt=\"\"></p>\n<ul>\n<li>QR：查询/应答标志。0表示这是一个查询报文，1表示这个一个应答报文</li>\n<li>opcode：定义查询和应答的类型。0表示标准查询，1表示反向查询(由IP获得域名)，2表示请求服务器状态</li>\n<li>AA：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器</li>\n<li>TC：截断标志，仅当DNS报文使用UDP服务时使用，因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。</li>\n<li>RD：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，知道获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考</li>\n<li>RA：允许递归标志，仅供应答报文使用,1表示支持递归查询</li>\n<li>zero：这3位未用，必须都置0</li>\n<li>rcode：4位返回码，表示应答的状态。常用值0（无错误），3（域名不存在）</li>\n</ul>\n<p>接下来的4个字段分别指出DNS报文的最后4个字段的资源记录数目。对查询报文而言，一般包含一个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p>\n<p>查询问题的格式如下：</p>\n<p><img src=\"/pic/%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98%E6%A0%BC%E5%BC%8F.png\" alt=\"\"></p>\n<p>查询名：以一定的格式封装了要查询的主机域名。</p>\n<p>查询类型：表示如何执行查询操作</p>\n<ul>\n<li>类型A：值为1，表示获取目标主机的IP地址</li>\n<li>类型CNAME：值为5，表示获得目标主机的别名</li>\n<li>类型PTR：值为12，表示反向查询</li>\n</ul>\n<p>查询类：通常是1，表示获取因特网地址（IP地址）</p>\n<p>应答字段、授权字段和额外信息字段都使用资源记录格式。</p>\n<p>资源记录格式如下：</p>\n<p><img src=\"/pic/%E8%B5%84%E6%BA%90%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png\" alt=\"\"></p>\n<p>域名：该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同</p>\n<p>类型和类字段与DNS查询问题的对应字段相同</p>\n<p>生存时间：表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒</p>\n<p>资源数据长度和资源数据字段的内容取决于类型字段。对类型A而言，资源数据是</p>\n<p>32位的IPv4地址，资源数据长度时4(字节)。</p>\n<h2 id=\"访问DNS服务\"><a href=\"#访问DNS服务\" class=\"headerlink\" title=\"访问DNS服务\"></a>访问DNS服务</h2><p>Linux下使用/etc/resolv.conf文件来存放DNS服务器的IP地址</p>\n<p>Linux下常用的访问DNS服务器的客户端程序是host，host使用DNS协议和DNS服务器通信</p>\n<p><img src=\"/pic/host%E5%91%BD%E4%BB%A4.png\" alt=\"\"></p>\n<p>-t选项告诉DNS协议使用哪种查询类型，这里用A，通过域名查询IP地址</p>\n<p>由结果可见，<a href=\"http://www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。\" target=\"_blank\" rel=\"noopener\">www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。</a></p>\n<h2 id=\"tcpdump抓包\"><a href=\"#tcpdump抓包\" class=\"headerlink\" title=\"tcpdump抓包\"></a>tcpdump抓包</h2><p><img src=\"/pic/DNS_tcpdump1.png\" alt=\"\"></p>\n<p>这两个数据包开始的”IP”指出，它们后面的内容是IP数据包</p>\n<p>tcpdump以“IP 地址.端口号”的形式来描述通信的某一端；以”&gt;”表示数据传输方向，”&gt;”前面是源端，后面是目的端。</p>\n<p>由此可见第一个数据包是从我的虚拟机(IP为”192.168.152.129”)向其首选DNS服务器(IP地址是192.168.152.2)发送的DNS查询报文(目标端口53是DNS服务器使用的端口)，第二个数据包是服务器反馈的DNS应答报文。</p>\n<p>在第一个数据包中，数值61258是DNS查询报文的16位标识值，因此该值也出现在应答报文中。“+“表示开启递归查询标志，”A?“表示使用A类型的查询方式。”<a href=\"http://www.baidu.com&quot;是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度(以字节为单位)。\" target=\"_blank\" rel=\"noopener\">www.baidu.com&quot;是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度(以字节为单位)。</a></p>\n<p>第二个数据包中的 3/0/0 表示该报文中包含3个应答资源记录、0个授权资源记录、0个额外信息记录。后面的三项就是表示3个应答资源记录，该报文长度时90字节。</p>\n<p>书上没有展示-x之后的效果，自己试了一下</p>\n<p><img src=\"/pic/DNS_tcpdump2.png\" alt=\"\"></p>\n<p>由于抓取的是IP数据包，因此还封装了IP头和UDP头，定位DNS数据包不太容易。</p>\n<p>根据DNS查询报文的标识值10807，算出16进制0x2a37，在数据包中能找到2a37</p>\n<p>观察2a37后两个字节0x0100代表DNS查询标志字段，对比DNS标志字段的详细信息可见第7位(从0开始)正是RD字段，1表示执行递归查询。接下来两个字节0x0001表示1个问题个数，然后六个字节都是0x00，表示0个应答资源记录、0个授权资源记录、0个额外资源数目。然后分析遇到了问题(很难受，先码上吧，以后解决)。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"DNS工作原理\"><a href=\"#DNS工作原理\" class=\"headerlink\" title=\"DNS工作原理\"></a>DNS工作原理</h2><p>DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。</p>","more":"<h2 id=\"DNS查询和应答报文详解\"><a href=\"#DNS查询和应答报文详解\" class=\"headerlink\" title=\"DNS查询和应答报文详解\"></a>DNS查询和应答报文详解</h2><p><img src=\"/pic/DNS%E6%8A%A5%E6%96%87.png\" alt=\"DNS查询和应答报文\"></p>\n<p>16位标识：标记一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应</p>\n<p>16位标记：协商具体的通信方式和反馈通信状态。</p>\n<p>标志字段细节如下：</p>\n<p><img src=\"/pic/DNS%E6%8A%A5%E6%96%87%E6%A0%87%E5%BF%97%E5%AD%97%E6%AE%B5.png\" alt=\"\"></p>\n<ul>\n<li>QR：查询/应答标志。0表示这是一个查询报文，1表示这个一个应答报文</li>\n<li>opcode：定义查询和应答的类型。0表示标准查询，1表示反向查询(由IP获得域名)，2表示请求服务器状态</li>\n<li>AA：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器</li>\n<li>TC：截断标志，仅当DNS报文使用UDP服务时使用，因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。</li>\n<li>RD：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，知道获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考</li>\n<li>RA：允许递归标志，仅供应答报文使用,1表示支持递归查询</li>\n<li>zero：这3位未用，必须都置0</li>\n<li>rcode：4位返回码，表示应答的状态。常用值0（无错误），3（域名不存在）</li>\n</ul>\n<p>接下来的4个字段分别指出DNS报文的最后4个字段的资源记录数目。对查询报文而言，一般包含一个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p>\n<p>查询问题的格式如下：</p>\n<p><img src=\"/pic/%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98%E6%A0%BC%E5%BC%8F.png\" alt=\"\"></p>\n<p>查询名：以一定的格式封装了要查询的主机域名。</p>\n<p>查询类型：表示如何执行查询操作</p>\n<ul>\n<li>类型A：值为1，表示获取目标主机的IP地址</li>\n<li>类型CNAME：值为5，表示获得目标主机的别名</li>\n<li>类型PTR：值为12，表示反向查询</li>\n</ul>\n<p>查询类：通常是1，表示获取因特网地址（IP地址）</p>\n<p>应答字段、授权字段和额外信息字段都使用资源记录格式。</p>\n<p>资源记录格式如下：</p>\n<p><img src=\"/pic/%E8%B5%84%E6%BA%90%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png\" alt=\"\"></p>\n<p>域名：该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同</p>\n<p>类型和类字段与DNS查询问题的对应字段相同</p>\n<p>生存时间：表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒</p>\n<p>资源数据长度和资源数据字段的内容取决于类型字段。对类型A而言，资源数据是</p>\n<p>32位的IPv4地址，资源数据长度时4(字节)。</p>\n<h2 id=\"访问DNS服务\"><a href=\"#访问DNS服务\" class=\"headerlink\" title=\"访问DNS服务\"></a>访问DNS服务</h2><p>Linux下使用/etc/resolv.conf文件来存放DNS服务器的IP地址</p>\n<p>Linux下常用的访问DNS服务器的客户端程序是host，host使用DNS协议和DNS服务器通信</p>\n<p><img src=\"/pic/host%E5%91%BD%E4%BB%A4.png\" alt=\"\"></p>\n<p>-t选项告诉DNS协议使用哪种查询类型，这里用A，通过域名查询IP地址</p>\n<p>由结果可见，<a href=\"http://www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。\" target=\"_blank\" rel=\"noopener\">www.baidu.com是www.a.shifen.com.的别名，并且该机器名对应两个IP地址。</a></p>\n<h2 id=\"tcpdump抓包\"><a href=\"#tcpdump抓包\" class=\"headerlink\" title=\"tcpdump抓包\"></a>tcpdump抓包</h2><p><img src=\"/pic/DNS_tcpdump1.png\" alt=\"\"></p>\n<p>这两个数据包开始的”IP”指出，它们后面的内容是IP数据包</p>\n<p>tcpdump以“IP 地址.端口号”的形式来描述通信的某一端；以”&gt;”表示数据传输方向，”&gt;”前面是源端，后面是目的端。</p>\n<p>由此可见第一个数据包是从我的虚拟机(IP为”192.168.152.129”)向其首选DNS服务器(IP地址是192.168.152.2)发送的DNS查询报文(目标端口53是DNS服务器使用的端口)，第二个数据包是服务器反馈的DNS应答报文。</p>\n<p>在第一个数据包中，数值61258是DNS查询报文的16位标识值，因此该值也出现在应答报文中。“+“表示开启递归查询标志，”A?“表示使用A类型的查询方式。”<a href=\"http://www.baidu.com&quot;是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度(以字节为单位)。\" target=\"_blank\" rel=\"noopener\">www.baidu.com&quot;是DNS查询问题中的查询名。括号中的数值31是DNS查询报文的长度(以字节为单位)。</a></p>\n<p>第二个数据包中的 3/0/0 表示该报文中包含3个应答资源记录、0个授权资源记录、0个额外信息记录。后面的三项就是表示3个应答资源记录，该报文长度时90字节。</p>\n<p>书上没有展示-x之后的效果，自己试了一下</p>\n<p><img src=\"/pic/DNS_tcpdump2.png\" alt=\"\"></p>\n<p>由于抓取的是IP数据包，因此还封装了IP头和UDP头，定位DNS数据包不太容易。</p>\n<p>根据DNS查询报文的标识值10807，算出16进制0x2a37，在数据包中能找到2a37</p>\n<p>观察2a37后两个字节0x0100代表DNS查询标志字段，对比DNS标志字段的详细信息可见第7位(从0开始)正是RD字段，1表示执行递归查询。接下来两个字节0x0001表示1个问题个数，然后六个字节都是0x00，表示0个应答资源记录、0个授权资源记录、0个额外资源数目。然后分析遇到了问题(很难受，先码上吧，以后解决)。</p>"},{"title":"C++11的一些小知识点","date":"2019-04-26T11:19:52.000Z","_content":"\n#### 模板中的空格(C++ Primer p87)\n\n在之前的C++版本中，如果在容器中装的是又是一个容器，比如\n\n```\nvector<list<int> >  //最后两个>之间的空格不能省略\n```\n\n这是因为如果没有这个空格，编译器会认为这是一个>>操作符，编译会出错。\n\n在C++11之后，\n\n```\nvector<list<int>>  //这样写就可以了 \n```\n\n<!--more-->\n\n#### nullptr and std::nullptr_t(C++ Primer p48)\n\n```\nint* p1 = nullptr; //等价于int* p1 = 0;\nint* p2 = 0;       //直接将p2初始化为字面常量0\nint* p3 = NULL;   //需要#include<cstdlib>  等价于int* p3 = 0;\n```\n\n```\nvoid  f(int);\nvoid f(void*);\n\nf(0);       //掉用f(int)\nf(NULL);    //掉用f(int)\nf(nullptr); //调用f(void*)\n```\n\nnullptr的类型是std::nullptr_t，定义在<cstddef>\n\n```\n//4.92\\include\\stddef.h\n#if defined(__cplusplus) && __cplusplus >= 201103L\n#ifndef _GXX_NULLPTR_T\n#define _GXX_NULLPTR_T\ntypedef decltype(nullptr) nullptr_t;\n```\n\n#### auto(C++ Primer p61)\n\n之前讲auto是指，一个函数的local变量类型是auto的，因为一个函数的局部变量，在函数结束的时候自动释放。\n\n而在C++11中，auto能让编译器替我们去分析表达式所属的类型。\n\n一般用于类型很长或者类型很复杂，一时想不起来的时候。\n\n```\nauto i = 42;  //i---------->int\ndouble f();\nauto d = f(); //d----------->double\nvector<string> v;\nauto pos = v.begin();  //pos----->vector<string>::iterator\nauto I = [](int x)->bool{  //I是lambda类型\n  ...,   //传入int 返回bool\n};\n\n\n//使用auto变量能在一条语句中声明多个变量\n//因为一条声明语句只能有一个基本数据类型\n//所以该语句中所有变量的初始基本数据类型都必须一样\nauto i = 0,*p = &i;  //i是整数  p是整型指针  正确\nauto sz = 0,pi = 3.14; //错误，sz和pi类型不一致\n```\n\n#### Uniform Initialization(C++ Primer p129)\n\n之前的初始化手法：\n\n```\nRect r1 = {3,7,20,25,&area,&print};\nRect r2(3,7,20,25);\nint ia[6] = {1,2,3,4,5,6};\n```\n\nC++11介绍了一致化初始化方式，就是提供一样的初始化方法，知道就行，具体采用哪种初始化方式根据习惯就好。\n\n```\nint values[] {1,2,3};    //注意和以前的区别  少去了=\nvector<int> v{2,3,4};\ncomplex<double> c{4.0,3.0}; //等价于c(4.0,3.0)\n```\n\n原理就是：编译器看到{t1,t2,...,tn}就会做出一个initializer_list<T>,它关联到一个array<T,n>,调用函数(例如ctor)时该array内的元素可以被编译器逐一分解传给函数。但是如果构造函数有一个版本的参数接受initializer_list<T>，那么就整体传入。\n\n#### Initializer Lists(C++ Primer p197)\n\n```\nint i;  //i未定义的值\nint j{}; //j = 0;\nint *p; //p未定义的指针\nint *q{}; //q = nullptr\n\nint x1(5.3); //OK x1 = 5  warning\nint x2 = 5.3; //OK  x2 = 5  warning\n\n//不允许的窄化转换\nint x3{5.3};  //error\nint x4 = {5.3}; //error\nchar c2{99999};  //error\nvector<int> v{1,2.5,3,4.8}; //error\n```\n\n{}背后的原理:类模板std::initializer_list<>\n\n在C++11中，如果要编写处理不同数量的实参的函数的时候，有两种办法\n\n- 如果所有实参类型相同，可以传递一个initializer_list的标准库类型\n- 如果实参类型不同，可以用可变参数模板编写\n\n第一点就是现在在介绍的东西。\n\n```\nvoid print(initializer_list<int> vals){\n    for(auto p = vals.begin();p != vals.end();p++){\n        cout<<*p<<endl;\n    }\n}\n\nprint({12,3,5,7,11,13});\n```\n\n下图很好的展示了initializer_list构造的调用：\n\n![](/pic/initializer_list.png)\n\n实质上当{}出现，编译器就生成一个initializer_list对象，这个模板类需要一个array容器作为支持。\n\n在STL源码中，initializer_list被大量运用在容器的初始化，赋值，插入等操作上，因为这些情况下大多操作不定数量的相同类型的数据。在算法中，比如min，max,之前只之前两个元素，有了initializer_list就能获取不定数量的列表中的最大值和最小值\n\n```\nvector<int> v1{1,2,3};\nvector<int> v2({4,5,6});\nvector<int> v3;\nv3 = {7,8,9};\nv3.insert(v3.begin()+2,{10,11});\n\nfor(auto i: v3)\n\tcout<<i<<\" \";\ncout<<endl;     // 7 8 10 11 9\ncout<<max({string(\"abc\"),string(\"xyz\"),string(\"qrt\")})<<endl;  //xyz\ncout<<min({string(\"abc\"),string(\"xyz\"),string(\"qrt\")})<<endl;  //abc\ncout<<max({1,5,7,8,9})<<endl;   //9\ncout<<min({1,5,7,8,9})<<endl;   //1\n```\n\n#### explicit(C++ Primer p516)\n\n这个关键字主要用在构造函数之上，主要为了防止隐式类型转换，一般发生在一个对象和另一个类型的变量做某种操作的时候。\n\nC++11之前，只有non-explicit one-argument 构造函数才能进行隐式类型转换，在C++11之后，多个实参的构造函数也提供explicit \n\n[参考博文](https://www.cnblogs.com/diligenceday/p/5781408.html)\n\n#### 范围for(C++ Primer p168)\n\n用法:\n\n```\nvector<double> vec;\n...\nfor(auto elem : vec)\n\tcout<<elem << endl;\nfor(auto &elem : vec)\n\telem *= 3;\n```\n\n需要注意的是：如果要改变容器中的值，必须加引用\n\n原理,借助了迭代器\n\n```\nfor(decl : coll){\n    statement\n}\n//编译器转换成\nfor(auto _pos=coll.begin(),_end=coll.end();_pos!=_end;_pos++）{\n    decl = *_pos;\n    statement\n}\n/*------------------------------------------*/\nfor(const auto &elem : coll)\n\tcout<<elem<<endl;\n//编译器转换成\nfor(auto _pos=coll.begin();_pos!=coll.end();_pos++){\n    const auto &elem = *_pos;\n    cout<<elem<<endl;\n}\n\n```\n\n#### Alias Template\n\nalias declaration(C++ Primer p60)\n\n```\ntemplate<typename T>\nusing Vec = vector<T, allocator<T>>;\n\nVec<int>  v; //等价于vector<int, allocator<int>> v\n/*------------不能用宏---------------------*/\n#define Vec<T> template<typename T> vector<T,allocator<T>>\n//这样会变成\nVec<int> v; //---->template<typename int> vector<int,allocator<int>> v;\n/*-------------不能用typedef----------------*/\ntypedef vector<int,allocator<int>> Vec;\nVec v;//Vec不能带参数了  只能是int\n```\n\n注意点：模板化名不能做特化(偏或者全)\n\n\n\n","source":"_posts/C-11的一些小知识点.md","raw":"---\ntitle: C++11的一些小知识点\ndate: 2019-04-26 19:19:52\ntags:\n- C++\n- C++11\n---\n\n#### 模板中的空格(C++ Primer p87)\n\n在之前的C++版本中，如果在容器中装的是又是一个容器，比如\n\n```\nvector<list<int> >  //最后两个>之间的空格不能省略\n```\n\n这是因为如果没有这个空格，编译器会认为这是一个>>操作符，编译会出错。\n\n在C++11之后，\n\n```\nvector<list<int>>  //这样写就可以了 \n```\n\n<!--more-->\n\n#### nullptr and std::nullptr_t(C++ Primer p48)\n\n```\nint* p1 = nullptr; //等价于int* p1 = 0;\nint* p2 = 0;       //直接将p2初始化为字面常量0\nint* p3 = NULL;   //需要#include<cstdlib>  等价于int* p3 = 0;\n```\n\n```\nvoid  f(int);\nvoid f(void*);\n\nf(0);       //掉用f(int)\nf(NULL);    //掉用f(int)\nf(nullptr); //调用f(void*)\n```\n\nnullptr的类型是std::nullptr_t，定义在<cstddef>\n\n```\n//4.92\\include\\stddef.h\n#if defined(__cplusplus) && __cplusplus >= 201103L\n#ifndef _GXX_NULLPTR_T\n#define _GXX_NULLPTR_T\ntypedef decltype(nullptr) nullptr_t;\n```\n\n#### auto(C++ Primer p61)\n\n之前讲auto是指，一个函数的local变量类型是auto的，因为一个函数的局部变量，在函数结束的时候自动释放。\n\n而在C++11中，auto能让编译器替我们去分析表达式所属的类型。\n\n一般用于类型很长或者类型很复杂，一时想不起来的时候。\n\n```\nauto i = 42;  //i---------->int\ndouble f();\nauto d = f(); //d----------->double\nvector<string> v;\nauto pos = v.begin();  //pos----->vector<string>::iterator\nauto I = [](int x)->bool{  //I是lambda类型\n  ...,   //传入int 返回bool\n};\n\n\n//使用auto变量能在一条语句中声明多个变量\n//因为一条声明语句只能有一个基本数据类型\n//所以该语句中所有变量的初始基本数据类型都必须一样\nauto i = 0,*p = &i;  //i是整数  p是整型指针  正确\nauto sz = 0,pi = 3.14; //错误，sz和pi类型不一致\n```\n\n#### Uniform Initialization(C++ Primer p129)\n\n之前的初始化手法：\n\n```\nRect r1 = {3,7,20,25,&area,&print};\nRect r2(3,7,20,25);\nint ia[6] = {1,2,3,4,5,6};\n```\n\nC++11介绍了一致化初始化方式，就是提供一样的初始化方法，知道就行，具体采用哪种初始化方式根据习惯就好。\n\n```\nint values[] {1,2,3};    //注意和以前的区别  少去了=\nvector<int> v{2,3,4};\ncomplex<double> c{4.0,3.0}; //等价于c(4.0,3.0)\n```\n\n原理就是：编译器看到{t1,t2,...,tn}就会做出一个initializer_list<T>,它关联到一个array<T,n>,调用函数(例如ctor)时该array内的元素可以被编译器逐一分解传给函数。但是如果构造函数有一个版本的参数接受initializer_list<T>，那么就整体传入。\n\n#### Initializer Lists(C++ Primer p197)\n\n```\nint i;  //i未定义的值\nint j{}; //j = 0;\nint *p; //p未定义的指针\nint *q{}; //q = nullptr\n\nint x1(5.3); //OK x1 = 5  warning\nint x2 = 5.3; //OK  x2 = 5  warning\n\n//不允许的窄化转换\nint x3{5.3};  //error\nint x4 = {5.3}; //error\nchar c2{99999};  //error\nvector<int> v{1,2.5,3,4.8}; //error\n```\n\n{}背后的原理:类模板std::initializer_list<>\n\n在C++11中，如果要编写处理不同数量的实参的函数的时候，有两种办法\n\n- 如果所有实参类型相同，可以传递一个initializer_list的标准库类型\n- 如果实参类型不同，可以用可变参数模板编写\n\n第一点就是现在在介绍的东西。\n\n```\nvoid print(initializer_list<int> vals){\n    for(auto p = vals.begin();p != vals.end();p++){\n        cout<<*p<<endl;\n    }\n}\n\nprint({12,3,5,7,11,13});\n```\n\n下图很好的展示了initializer_list构造的调用：\n\n![](/pic/initializer_list.png)\n\n实质上当{}出现，编译器就生成一个initializer_list对象，这个模板类需要一个array容器作为支持。\n\n在STL源码中，initializer_list被大量运用在容器的初始化，赋值，插入等操作上，因为这些情况下大多操作不定数量的相同类型的数据。在算法中，比如min，max,之前只之前两个元素，有了initializer_list就能获取不定数量的列表中的最大值和最小值\n\n```\nvector<int> v1{1,2,3};\nvector<int> v2({4,5,6});\nvector<int> v3;\nv3 = {7,8,9};\nv3.insert(v3.begin()+2,{10,11});\n\nfor(auto i: v3)\n\tcout<<i<<\" \";\ncout<<endl;     // 7 8 10 11 9\ncout<<max({string(\"abc\"),string(\"xyz\"),string(\"qrt\")})<<endl;  //xyz\ncout<<min({string(\"abc\"),string(\"xyz\"),string(\"qrt\")})<<endl;  //abc\ncout<<max({1,5,7,8,9})<<endl;   //9\ncout<<min({1,5,7,8,9})<<endl;   //1\n```\n\n#### explicit(C++ Primer p516)\n\n这个关键字主要用在构造函数之上，主要为了防止隐式类型转换，一般发生在一个对象和另一个类型的变量做某种操作的时候。\n\nC++11之前，只有non-explicit one-argument 构造函数才能进行隐式类型转换，在C++11之后，多个实参的构造函数也提供explicit \n\n[参考博文](https://www.cnblogs.com/diligenceday/p/5781408.html)\n\n#### 范围for(C++ Primer p168)\n\n用法:\n\n```\nvector<double> vec;\n...\nfor(auto elem : vec)\n\tcout<<elem << endl;\nfor(auto &elem : vec)\n\telem *= 3;\n```\n\n需要注意的是：如果要改变容器中的值，必须加引用\n\n原理,借助了迭代器\n\n```\nfor(decl : coll){\n    statement\n}\n//编译器转换成\nfor(auto _pos=coll.begin(),_end=coll.end();_pos!=_end;_pos++）{\n    decl = *_pos;\n    statement\n}\n/*------------------------------------------*/\nfor(const auto &elem : coll)\n\tcout<<elem<<endl;\n//编译器转换成\nfor(auto _pos=coll.begin();_pos!=coll.end();_pos++){\n    const auto &elem = *_pos;\n    cout<<elem<<endl;\n}\n\n```\n\n#### Alias Template\n\nalias declaration(C++ Primer p60)\n\n```\ntemplate<typename T>\nusing Vec = vector<T, allocator<T>>;\n\nVec<int>  v; //等价于vector<int, allocator<int>> v\n/*------------不能用宏---------------------*/\n#define Vec<T> template<typename T> vector<T,allocator<T>>\n//这样会变成\nVec<int> v; //---->template<typename int> vector<int,allocator<int>> v;\n/*-------------不能用typedef----------------*/\ntypedef vector<int,allocator<int>> Vec;\nVec v;//Vec不能带参数了  只能是int\n```\n\n注意点：模板化名不能做特化(偏或者全)\n\n\n\n","slug":"C-11的一些小知识点","published":1,"updated":"2021-12-06T05:30:36.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip76000596cadw7rara4","content":"<h4 id=\"模板中的空格-C-Primer-p87\"><a href=\"#模板中的空格-C-Primer-p87\" class=\"headerlink\" title=\"模板中的空格(C++ Primer p87)\"></a>模板中的空格(C++ Primer p87)</h4><p>在之前的C++版本中，如果在容器中装的是又是一个容器，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;list&lt;int&gt; &gt;  &#x2F;&#x2F;最后两个&gt;之间的空格不能省略</span><br></pre></td></tr></table></figure>\n\n<p>这是因为如果没有这个空格，编译器会认为这是一个&gt;&gt;操作符，编译会出错。</p>\n<p>在C++11之后，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;list&lt;int&gt;&gt;  &#x2F;&#x2F;这样写就可以了</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h4 id=\"nullptr-and-std-nullptr-t-C-Primer-p48\"><a href=\"#nullptr-and-std-nullptr-t-C-Primer-p48\" class=\"headerlink\" title=\"nullptr and std::nullptr_t(C++ Primer p48)\"></a>nullptr and std::nullptr_t(C++ Primer p48)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* p1 &#x3D; nullptr; &#x2F;&#x2F;等价于int* p1 &#x3D; 0;</span><br><span class=\"line\">int* p2 &#x3D; 0;       &#x2F;&#x2F;直接将p2初始化为字面常量0</span><br><span class=\"line\">int* p3 &#x3D; NULL;   &#x2F;&#x2F;需要#include&lt;cstdlib&gt;  等价于int* p3 &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void  f(int);</span><br><span class=\"line\">void f(void*);</span><br><span class=\"line\"></span><br><span class=\"line\">f(0);       &#x2F;&#x2F;掉用f(int)</span><br><span class=\"line\">f(NULL);    &#x2F;&#x2F;掉用f(int)</span><br><span class=\"line\">f(nullptr); &#x2F;&#x2F;调用f(void*)</span><br></pre></td></tr></table></figure>\n\n<p>nullptr的类型是std::nullptr_t，定义在<cstddef></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;4.92\\include\\stddef.h</span><br><span class=\"line\">#if defined(__cplusplus) &amp;&amp; __cplusplus &gt;&#x3D; 201103L</span><br><span class=\"line\">#ifndef _GXX_NULLPTR_T</span><br><span class=\"line\">#define _GXX_NULLPTR_T</span><br><span class=\"line\">typedef decltype(nullptr) nullptr_t;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"auto-C-Primer-p61\"><a href=\"#auto-C-Primer-p61\" class=\"headerlink\" title=\"auto(C++ Primer p61)\"></a>auto(C++ Primer p61)</h4><p>之前讲auto是指，一个函数的local变量类型是auto的，因为一个函数的局部变量，在函数结束的时候自动释放。</p>\n<p>而在C++11中，auto能让编译器替我们去分析表达式所属的类型。</p>\n<p>一般用于类型很长或者类型很复杂，一时想不起来的时候。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto i &#x3D; 42;  &#x2F;&#x2F;i----------&gt;int</span><br><span class=\"line\">double f();</span><br><span class=\"line\">auto d &#x3D; f(); &#x2F;&#x2F;d-----------&gt;double</span><br><span class=\"line\">vector&lt;string&gt; v;</span><br><span class=\"line\">auto pos &#x3D; v.begin();  &#x2F;&#x2F;pos-----&gt;vector&lt;string&gt;::iterator</span><br><span class=\"line\">auto I &#x3D; [](int x)-&gt;bool&#123;  &#x2F;&#x2F;I是lambda类型</span><br><span class=\"line\">  ...,   &#x2F;&#x2F;传入int 返回bool</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;使用auto变量能在一条语句中声明多个变量</span><br><span class=\"line\">&#x2F;&#x2F;因为一条声明语句只能有一个基本数据类型</span><br><span class=\"line\">&#x2F;&#x2F;所以该语句中所有变量的初始基本数据类型都必须一样</span><br><span class=\"line\">auto i &#x3D; 0,*p &#x3D; &amp;i;  &#x2F;&#x2F;i是整数  p是整型指针  正确</span><br><span class=\"line\">auto sz &#x3D; 0,pi &#x3D; 3.14; &#x2F;&#x2F;错误，sz和pi类型不一致</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Uniform-Initialization-C-Primer-p129\"><a href=\"#Uniform-Initialization-C-Primer-p129\" class=\"headerlink\" title=\"Uniform Initialization(C++ Primer p129)\"></a>Uniform Initialization(C++ Primer p129)</h4><p>之前的初始化手法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rect r1 &#x3D; &#123;3,7,20,25,&amp;area,&amp;print&#125;;</span><br><span class=\"line\">Rect r2(3,7,20,25);</span><br><span class=\"line\">int ia[6] &#x3D; &#123;1,2,3,4,5,6&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>C++11介绍了一致化初始化方式，就是提供一样的初始化方法，知道就行，具体采用哪种初始化方式根据习惯就好。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int values[] &#123;1,2,3&#125;;    &#x2F;&#x2F;注意和以前的区别  少去了&#x3D;</span><br><span class=\"line\">vector&lt;int&gt; v&#123;2,3,4&#125;;</span><br><span class=\"line\">complex&lt;double&gt; c&#123;4.0,3.0&#125;; &#x2F;&#x2F;等价于c(4.0,3.0)</span><br></pre></td></tr></table></figure>\n\n<p>原理就是：编译器看到{t1,t2,…,tn}就会做出一个initializer_list<T>,它关联到一个array&lt;T,n&gt;,调用函数(例如ctor)时该array内的元素可以被编译器逐一分解传给函数。但是如果构造函数有一个版本的参数接受initializer_list<T>，那么就整体传入。</p>\n<h4 id=\"Initializer-Lists-C-Primer-p197\"><a href=\"#Initializer-Lists-C-Primer-p197\" class=\"headerlink\" title=\"Initializer Lists(C++ Primer p197)\"></a>Initializer Lists(C++ Primer p197)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i;  &#x2F;&#x2F;i未定义的值</span><br><span class=\"line\">int j&#123;&#125;; &#x2F;&#x2F;j &#x3D; 0;</span><br><span class=\"line\">int *p; &#x2F;&#x2F;p未定义的指针</span><br><span class=\"line\">int *q&#123;&#125;; &#x2F;&#x2F;q &#x3D; nullptr</span><br><span class=\"line\"></span><br><span class=\"line\">int x1(5.3); &#x2F;&#x2F;OK x1 &#x3D; 5  warning</span><br><span class=\"line\">int x2 &#x3D; 5.3; &#x2F;&#x2F;OK  x2 &#x3D; 5  warning</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;不允许的窄化转换</span><br><span class=\"line\">int x3&#123;5.3&#125;;  &#x2F;&#x2F;error</span><br><span class=\"line\">int x4 &#x3D; &#123;5.3&#125;; &#x2F;&#x2F;error</span><br><span class=\"line\">char c2&#123;99999&#125;;  &#x2F;&#x2F;error</span><br><span class=\"line\">vector&lt;int&gt; v&#123;1,2.5,3,4.8&#125;; &#x2F;&#x2F;error</span><br></pre></td></tr></table></figure>\n\n<p>{}背后的原理:类模板std::initializer_list&lt;&gt;</p>\n<p>在C++11中，如果要编写处理不同数量的实参的函数的时候，有两种办法</p>\n<ul>\n<li>如果所有实参类型相同，可以传递一个initializer_list的标准库类型</li>\n<li>如果实参类型不同，可以用可变参数模板编写</li>\n</ul>\n<p>第一点就是现在在介绍的东西。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void print(initializer_list&lt;int&gt; vals)&#123;</span><br><span class=\"line\">    for(auto p &#x3D; vals.begin();p !&#x3D; vals.end();p++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">print(&#123;12,3,5,7,11,13&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>下图很好的展示了initializer_list构造的调用：</p>\n<p><img src=\"/pic/initializer_list.png\" alt=\"\"></p>\n<p>实质上当{}出现，编译器就生成一个initializer_list对象，这个模板类需要一个array容器作为支持。</p>\n<p>在STL源码中，initializer_list被大量运用在容器的初始化，赋值，插入等操作上，因为这些情况下大多操作不定数量的相同类型的数据。在算法中，比如min，max,之前只之前两个元素，有了initializer_list就能获取不定数量的列表中的最大值和最小值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; v1&#123;1,2,3&#125;;</span><br><span class=\"line\">vector&lt;int&gt; v2(&#123;4,5,6&#125;);</span><br><span class=\"line\">vector&lt;int&gt; v3;</span><br><span class=\"line\">v3 &#x3D; &#123;7,8,9&#125;;</span><br><span class=\"line\">v3.insert(v3.begin()+2,&#123;10,11&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">for(auto i: v3)</span><br><span class=\"line\">\tcout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class=\"line\">cout&lt;&lt;endl;     &#x2F;&#x2F; 7 8 10 11 9</span><br><span class=\"line\">cout&lt;&lt;max(&#123;string(&quot;abc&quot;),string(&quot;xyz&quot;),string(&quot;qrt&quot;)&#125;)&lt;&lt;endl;  &#x2F;&#x2F;xyz</span><br><span class=\"line\">cout&lt;&lt;min(&#123;string(&quot;abc&quot;),string(&quot;xyz&quot;),string(&quot;qrt&quot;)&#125;)&lt;&lt;endl;  &#x2F;&#x2F;abc</span><br><span class=\"line\">cout&lt;&lt;max(&#123;1,5,7,8,9&#125;)&lt;&lt;endl;   &#x2F;&#x2F;9</span><br><span class=\"line\">cout&lt;&lt;min(&#123;1,5,7,8,9&#125;)&lt;&lt;endl;   &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"explicit-C-Primer-p516\"><a href=\"#explicit-C-Primer-p516\" class=\"headerlink\" title=\"explicit(C++ Primer p516)\"></a>explicit(C++ Primer p516)</h4><p>这个关键字主要用在构造函数之上，主要为了防止隐式类型转换，一般发生在一个对象和另一个类型的变量做某种操作的时候。</p>\n<p>C++11之前，只有non-explicit one-argument 构造函数才能进行隐式类型转换，在C++11之后，多个实参的构造函数也提供explicit </p>\n<p><a href=\"https://www.cnblogs.com/diligenceday/p/5781408.html\" target=\"_blank\" rel=\"noopener\">参考博文</a></p>\n<h4 id=\"范围for-C-Primer-p168\"><a href=\"#范围for-C-Primer-p168\" class=\"headerlink\" title=\"范围for(C++ Primer p168)\"></a>范围for(C++ Primer p168)</h4><p>用法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;double&gt; vec;</span><br><span class=\"line\">...</span><br><span class=\"line\">for(auto elem : vec)</span><br><span class=\"line\">\tcout&lt;&lt;elem &lt;&lt; endl;</span><br><span class=\"line\">for(auto &amp;elem : vec)</span><br><span class=\"line\">\telem *&#x3D; 3;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：如果要改变容器中的值，必须加引用</p>\n<p>原理,借助了迭代器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(decl : coll)&#123;</span><br><span class=\"line\">    statement</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;编译器转换成</span><br><span class=\"line\">for(auto _pos&#x3D;coll.begin(),_end&#x3D;coll.end();_pos!&#x3D;_end;_pos++）&#123;</span><br><span class=\"line\">    decl &#x3D; *_pos;</span><br><span class=\"line\">    statement</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;*------------------------------------------*&#x2F;</span><br><span class=\"line\">for(const auto &amp;elem : coll)</span><br><span class=\"line\">\tcout&lt;&lt;elem&lt;&lt;endl;</span><br><span class=\"line\">&#x2F;&#x2F;编译器转换成</span><br><span class=\"line\">for(auto _pos&#x3D;coll.begin();_pos!&#x3D;coll.end();_pos++)&#123;</span><br><span class=\"line\">    const auto &amp;elem &#x3D; *_pos;</span><br><span class=\"line\">    cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Alias-Template\"><a href=\"#Alias-Template\" class=\"headerlink\" title=\"Alias Template\"></a>Alias Template</h4><p>alias declaration(C++ Primer p60)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">using Vec &#x3D; vector&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">Vec&lt;int&gt;  v; &#x2F;&#x2F;等价于vector&lt;int, allocator&lt;int&gt;&gt; v</span><br><span class=\"line\">&#x2F;*------------不能用宏---------------------*&#x2F;</span><br><span class=\"line\">#define Vec&lt;T&gt; template&lt;typename T&gt; vector&lt;T,allocator&lt;T&gt;&gt;</span><br><span class=\"line\">&#x2F;&#x2F;这样会变成</span><br><span class=\"line\">Vec&lt;int&gt; v; &#x2F;&#x2F;----&gt;template&lt;typename int&gt; vector&lt;int,allocator&lt;int&gt;&gt; v;</span><br><span class=\"line\">&#x2F;*-------------不能用typedef----------------*&#x2F;</span><br><span class=\"line\">typedef vector&lt;int,allocator&lt;int&gt;&gt; Vec;</span><br><span class=\"line\">Vec v;&#x2F;&#x2F;Vec不能带参数了  只能是int</span><br></pre></td></tr></table></figure>\n\n<p>注意点：模板化名不能做特化(偏或者全)</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"模板中的空格-C-Primer-p87\"><a href=\"#模板中的空格-C-Primer-p87\" class=\"headerlink\" title=\"模板中的空格(C++ Primer p87)\"></a>模板中的空格(C++ Primer p87)</h4><p>在之前的C++版本中，如果在容器中装的是又是一个容器，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;list&lt;int&gt; &gt;  &#x2F;&#x2F;最后两个&gt;之间的空格不能省略</span><br></pre></td></tr></table></figure>\n\n<p>这是因为如果没有这个空格，编译器会认为这是一个&gt;&gt;操作符，编译会出错。</p>\n<p>在C++11之后，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;list&lt;int&gt;&gt;  &#x2F;&#x2F;这样写就可以了</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"nullptr-and-std-nullptr-t-C-Primer-p48\"><a href=\"#nullptr-and-std-nullptr-t-C-Primer-p48\" class=\"headerlink\" title=\"nullptr and std::nullptr_t(C++ Primer p48)\"></a>nullptr and std::nullptr_t(C++ Primer p48)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* p1 &#x3D; nullptr; &#x2F;&#x2F;等价于int* p1 &#x3D; 0;</span><br><span class=\"line\">int* p2 &#x3D; 0;       &#x2F;&#x2F;直接将p2初始化为字面常量0</span><br><span class=\"line\">int* p3 &#x3D; NULL;   &#x2F;&#x2F;需要#include&lt;cstdlib&gt;  等价于int* p3 &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void  f(int);</span><br><span class=\"line\">void f(void*);</span><br><span class=\"line\"></span><br><span class=\"line\">f(0);       &#x2F;&#x2F;掉用f(int)</span><br><span class=\"line\">f(NULL);    &#x2F;&#x2F;掉用f(int)</span><br><span class=\"line\">f(nullptr); &#x2F;&#x2F;调用f(void*)</span><br></pre></td></tr></table></figure>\n\n<p>nullptr的类型是std::nullptr_t，定义在<cstddef></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;4.92\\include\\stddef.h</span><br><span class=\"line\">#if defined(__cplusplus) &amp;&amp; __cplusplus &gt;&#x3D; 201103L</span><br><span class=\"line\">#ifndef _GXX_NULLPTR_T</span><br><span class=\"line\">#define _GXX_NULLPTR_T</span><br><span class=\"line\">typedef decltype(nullptr) nullptr_t;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"auto-C-Primer-p61\"><a href=\"#auto-C-Primer-p61\" class=\"headerlink\" title=\"auto(C++ Primer p61)\"></a>auto(C++ Primer p61)</h4><p>之前讲auto是指，一个函数的local变量类型是auto的，因为一个函数的局部变量，在函数结束的时候自动释放。</p>\n<p>而在C++11中，auto能让编译器替我们去分析表达式所属的类型。</p>\n<p>一般用于类型很长或者类型很复杂，一时想不起来的时候。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto i &#x3D; 42;  &#x2F;&#x2F;i----------&gt;int</span><br><span class=\"line\">double f();</span><br><span class=\"line\">auto d &#x3D; f(); &#x2F;&#x2F;d-----------&gt;double</span><br><span class=\"line\">vector&lt;string&gt; v;</span><br><span class=\"line\">auto pos &#x3D; v.begin();  &#x2F;&#x2F;pos-----&gt;vector&lt;string&gt;::iterator</span><br><span class=\"line\">auto I &#x3D; [](int x)-&gt;bool&#123;  &#x2F;&#x2F;I是lambda类型</span><br><span class=\"line\">  ...,   &#x2F;&#x2F;传入int 返回bool</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;使用auto变量能在一条语句中声明多个变量</span><br><span class=\"line\">&#x2F;&#x2F;因为一条声明语句只能有一个基本数据类型</span><br><span class=\"line\">&#x2F;&#x2F;所以该语句中所有变量的初始基本数据类型都必须一样</span><br><span class=\"line\">auto i &#x3D; 0,*p &#x3D; &amp;i;  &#x2F;&#x2F;i是整数  p是整型指针  正确</span><br><span class=\"line\">auto sz &#x3D; 0,pi &#x3D; 3.14; &#x2F;&#x2F;错误，sz和pi类型不一致</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Uniform-Initialization-C-Primer-p129\"><a href=\"#Uniform-Initialization-C-Primer-p129\" class=\"headerlink\" title=\"Uniform Initialization(C++ Primer p129)\"></a>Uniform Initialization(C++ Primer p129)</h4><p>之前的初始化手法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rect r1 &#x3D; &#123;3,7,20,25,&amp;area,&amp;print&#125;;</span><br><span class=\"line\">Rect r2(3,7,20,25);</span><br><span class=\"line\">int ia[6] &#x3D; &#123;1,2,3,4,5,6&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>C++11介绍了一致化初始化方式，就是提供一样的初始化方法，知道就行，具体采用哪种初始化方式根据习惯就好。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int values[] &#123;1,2,3&#125;;    &#x2F;&#x2F;注意和以前的区别  少去了&#x3D;</span><br><span class=\"line\">vector&lt;int&gt; v&#123;2,3,4&#125;;</span><br><span class=\"line\">complex&lt;double&gt; c&#123;4.0,3.0&#125;; &#x2F;&#x2F;等价于c(4.0,3.0)</span><br></pre></td></tr></table></figure>\n\n<p>原理就是：编译器看到{t1,t2,…,tn}就会做出一个initializer_list<T>,它关联到一个array&lt;T,n&gt;,调用函数(例如ctor)时该array内的元素可以被编译器逐一分解传给函数。但是如果构造函数有一个版本的参数接受initializer_list<T>，那么就整体传入。</p>\n<h4 id=\"Initializer-Lists-C-Primer-p197\"><a href=\"#Initializer-Lists-C-Primer-p197\" class=\"headerlink\" title=\"Initializer Lists(C++ Primer p197)\"></a>Initializer Lists(C++ Primer p197)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i;  &#x2F;&#x2F;i未定义的值</span><br><span class=\"line\">int j&#123;&#125;; &#x2F;&#x2F;j &#x3D; 0;</span><br><span class=\"line\">int *p; &#x2F;&#x2F;p未定义的指针</span><br><span class=\"line\">int *q&#123;&#125;; &#x2F;&#x2F;q &#x3D; nullptr</span><br><span class=\"line\"></span><br><span class=\"line\">int x1(5.3); &#x2F;&#x2F;OK x1 &#x3D; 5  warning</span><br><span class=\"line\">int x2 &#x3D; 5.3; &#x2F;&#x2F;OK  x2 &#x3D; 5  warning</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;不允许的窄化转换</span><br><span class=\"line\">int x3&#123;5.3&#125;;  &#x2F;&#x2F;error</span><br><span class=\"line\">int x4 &#x3D; &#123;5.3&#125;; &#x2F;&#x2F;error</span><br><span class=\"line\">char c2&#123;99999&#125;;  &#x2F;&#x2F;error</span><br><span class=\"line\">vector&lt;int&gt; v&#123;1,2.5,3,4.8&#125;; &#x2F;&#x2F;error</span><br></pre></td></tr></table></figure>\n\n<p>{}背后的原理:类模板std::initializer_list&lt;&gt;</p>\n<p>在C++11中，如果要编写处理不同数量的实参的函数的时候，有两种办法</p>\n<ul>\n<li>如果所有实参类型相同，可以传递一个initializer_list的标准库类型</li>\n<li>如果实参类型不同，可以用可变参数模板编写</li>\n</ul>\n<p>第一点就是现在在介绍的东西。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void print(initializer_list&lt;int&gt; vals)&#123;</span><br><span class=\"line\">    for(auto p &#x3D; vals.begin();p !&#x3D; vals.end();p++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">print(&#123;12,3,5,7,11,13&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>下图很好的展示了initializer_list构造的调用：</p>\n<p><img src=\"/pic/initializer_list.png\" alt=\"\"></p>\n<p>实质上当{}出现，编译器就生成一个initializer_list对象，这个模板类需要一个array容器作为支持。</p>\n<p>在STL源码中，initializer_list被大量运用在容器的初始化，赋值，插入等操作上，因为这些情况下大多操作不定数量的相同类型的数据。在算法中，比如min，max,之前只之前两个元素，有了initializer_list就能获取不定数量的列表中的最大值和最小值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; v1&#123;1,2,3&#125;;</span><br><span class=\"line\">vector&lt;int&gt; v2(&#123;4,5,6&#125;);</span><br><span class=\"line\">vector&lt;int&gt; v3;</span><br><span class=\"line\">v3 &#x3D; &#123;7,8,9&#125;;</span><br><span class=\"line\">v3.insert(v3.begin()+2,&#123;10,11&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">for(auto i: v3)</span><br><span class=\"line\">\tcout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class=\"line\">cout&lt;&lt;endl;     &#x2F;&#x2F; 7 8 10 11 9</span><br><span class=\"line\">cout&lt;&lt;max(&#123;string(&quot;abc&quot;),string(&quot;xyz&quot;),string(&quot;qrt&quot;)&#125;)&lt;&lt;endl;  &#x2F;&#x2F;xyz</span><br><span class=\"line\">cout&lt;&lt;min(&#123;string(&quot;abc&quot;),string(&quot;xyz&quot;),string(&quot;qrt&quot;)&#125;)&lt;&lt;endl;  &#x2F;&#x2F;abc</span><br><span class=\"line\">cout&lt;&lt;max(&#123;1,5,7,8,9&#125;)&lt;&lt;endl;   &#x2F;&#x2F;9</span><br><span class=\"line\">cout&lt;&lt;min(&#123;1,5,7,8,9&#125;)&lt;&lt;endl;   &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"explicit-C-Primer-p516\"><a href=\"#explicit-C-Primer-p516\" class=\"headerlink\" title=\"explicit(C++ Primer p516)\"></a>explicit(C++ Primer p516)</h4><p>这个关键字主要用在构造函数之上，主要为了防止隐式类型转换，一般发生在一个对象和另一个类型的变量做某种操作的时候。</p>\n<p>C++11之前，只有non-explicit one-argument 构造函数才能进行隐式类型转换，在C++11之后，多个实参的构造函数也提供explicit </p>\n<p><a href=\"https://www.cnblogs.com/diligenceday/p/5781408.html\" target=\"_blank\" rel=\"noopener\">参考博文</a></p>\n<h4 id=\"范围for-C-Primer-p168\"><a href=\"#范围for-C-Primer-p168\" class=\"headerlink\" title=\"范围for(C++ Primer p168)\"></a>范围for(C++ Primer p168)</h4><p>用法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;double&gt; vec;</span><br><span class=\"line\">...</span><br><span class=\"line\">for(auto elem : vec)</span><br><span class=\"line\">\tcout&lt;&lt;elem &lt;&lt; endl;</span><br><span class=\"line\">for(auto &amp;elem : vec)</span><br><span class=\"line\">\telem *&#x3D; 3;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：如果要改变容器中的值，必须加引用</p>\n<p>原理,借助了迭代器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(decl : coll)&#123;</span><br><span class=\"line\">    statement</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;编译器转换成</span><br><span class=\"line\">for(auto _pos&#x3D;coll.begin(),_end&#x3D;coll.end();_pos!&#x3D;_end;_pos++）&#123;</span><br><span class=\"line\">    decl &#x3D; *_pos;</span><br><span class=\"line\">    statement</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;*------------------------------------------*&#x2F;</span><br><span class=\"line\">for(const auto &amp;elem : coll)</span><br><span class=\"line\">\tcout&lt;&lt;elem&lt;&lt;endl;</span><br><span class=\"line\">&#x2F;&#x2F;编译器转换成</span><br><span class=\"line\">for(auto _pos&#x3D;coll.begin();_pos!&#x3D;coll.end();_pos++)&#123;</span><br><span class=\"line\">    const auto &amp;elem &#x3D; *_pos;</span><br><span class=\"line\">    cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Alias-Template\"><a href=\"#Alias-Template\" class=\"headerlink\" title=\"Alias Template\"></a>Alias Template</h4><p>alias declaration(C++ Primer p60)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">using Vec &#x3D; vector&lt;T, allocator&lt;T&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">Vec&lt;int&gt;  v; &#x2F;&#x2F;等价于vector&lt;int, allocator&lt;int&gt;&gt; v</span><br><span class=\"line\">&#x2F;*------------不能用宏---------------------*&#x2F;</span><br><span class=\"line\">#define Vec&lt;T&gt; template&lt;typename T&gt; vector&lt;T,allocator&lt;T&gt;&gt;</span><br><span class=\"line\">&#x2F;&#x2F;这样会变成</span><br><span class=\"line\">Vec&lt;int&gt; v; &#x2F;&#x2F;----&gt;template&lt;typename int&gt; vector&lt;int,allocator&lt;int&gt;&gt; v;</span><br><span class=\"line\">&#x2F;*-------------不能用typedef----------------*&#x2F;</span><br><span class=\"line\">typedef vector&lt;int,allocator&lt;int&gt;&gt; Vec;</span><br><span class=\"line\">Vec v;&#x2F;&#x2F;Vec不能带参数了  只能是int</span><br></pre></td></tr></table></figure>\n\n<p>注意点：模板化名不能做特化(偏或者全)</p>"},{"title":"HTTP协议","date":"2019-03-12T07:58:31.000Z","_content":"\n## HTTP请求\n\n例子：\n\n![](/pic/HTTP请求.png)\n\n第一行是请求行，格式为方法+URL+协议版本（主流版本是HTTP/1.1）\n\n第二行开始是请求头部，格式为头部选项：实体内容\n\n请求方法有很多种，如下图：\n\n![](/pic/HTTP请求方法.png)\n\n具体字段就不赘述了。\n\n## HTTP应答\n\n例子：\n\n![](/pic/HTTP应答.png)\n\n第一行是状态行，格式为协议版本+状态码+状态信息\n\n第二行开始是应答头部。格式为头部选项： 实体内容\n\n状态码和状态信息如下：\n\n![](/pic/HTTP状态码.png)\n\n有一些字段需要注意一下，比如Cookie。\n\n#### Cookie\n\nHTTP是一种无状态的协议，每个HTTP请求之间没有上下文关系。但是，在交互式Web应用程序兴起，很多时候需要之前的信息。因此，就需要用额外的手段来保持HTTP连接状态，Cookie起的就是这个作用。Cookie是服务器发给客户端的特殊信息(通过HTTP应答头部选项Set-Cookie),通知客户端保存Cookie,客户端每次想服务器发送给客户端都需要带上这些信息(通过请求头部选项Cookie)，服务器发现客户端发过来Cookie以后，会去检查是哪个客户端发来的，对比服务器上的记录得到状态信息。浏览器的自动登录就是这么实现的。\n\n![](/pic/Cookie.png)\n\n","source":"_posts/HTTP协议.md","raw":"---\ntitle: HTTP协议\ndate: 2019-03-12 15:58:31\ntags:\n- HTTP\n- 网络\n- Linux高性能服务器编程\n---\n\n## HTTP请求\n\n例子：\n\n![](/pic/HTTP请求.png)\n\n第一行是请求行，格式为方法+URL+协议版本（主流版本是HTTP/1.1）\n\n第二行开始是请求头部，格式为头部选项：实体内容\n\n请求方法有很多种，如下图：\n\n![](/pic/HTTP请求方法.png)\n\n具体字段就不赘述了。\n\n## HTTP应答\n\n例子：\n\n![](/pic/HTTP应答.png)\n\n第一行是状态行，格式为协议版本+状态码+状态信息\n\n第二行开始是应答头部。格式为头部选项： 实体内容\n\n状态码和状态信息如下：\n\n![](/pic/HTTP状态码.png)\n\n有一些字段需要注意一下，比如Cookie。\n\n#### Cookie\n\nHTTP是一种无状态的协议，每个HTTP请求之间没有上下文关系。但是，在交互式Web应用程序兴起，很多时候需要之前的信息。因此，就需要用额外的手段来保持HTTP连接状态，Cookie起的就是这个作用。Cookie是服务器发给客户端的特殊信息(通过HTTP应答头部选项Set-Cookie),通知客户端保存Cookie,客户端每次想服务器发送给客户端都需要带上这些信息(通过请求头部选项Cookie)，服务器发现客户端发过来Cookie以后，会去检查是哪个客户端发来的，对比服务器上的记录得到状态信息。浏览器的自动登录就是这么实现的。\n\n![](/pic/Cookie.png)\n\n","slug":"HTTP协议","published":1,"updated":"2021-12-06T05:30:36.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip77000696ca8qd6c9rr","content":"<h2 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h2><p>例子：</p>\n<p><img src=\"/pic/HTTP%E8%AF%B7%E6%B1%82.png\" alt=\"\"></p>\n<p>第一行是请求行，格式为方法+URL+协议版本（主流版本是HTTP/1.1）</p>\n<p>第二行开始是请求头部，格式为头部选项：实体内容</p>\n<p>请求方法有很多种，如下图：</p>\n<p><img src=\"/pic/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>具体字段就不赘述了。</p>\n<h2 id=\"HTTP应答\"><a href=\"#HTTP应答\" class=\"headerlink\" title=\"HTTP应答\"></a>HTTP应答</h2><p>例子：</p>\n<p><img src=\"/pic/HTTP%E5%BA%94%E7%AD%94.png\" alt=\"\"></p>\n<p>第一行是状态行，格式为协议版本+状态码+状态信息</p>\n<p>第二行开始是应答头部。格式为头部选项： 实体内容</p>\n<p>状态码和状态信息如下：</p>\n<p><img src=\"/pic/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.png\" alt=\"\"></p>\n<p>有一些字段需要注意一下，比如Cookie。</p>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p>HTTP是一种无状态的协议，每个HTTP请求之间没有上下文关系。但是，在交互式Web应用程序兴起，很多时候需要之前的信息。因此，就需要用额外的手段来保持HTTP连接状态，Cookie起的就是这个作用。Cookie是服务器发给客户端的特殊信息(通过HTTP应答头部选项Set-Cookie),通知客户端保存Cookie,客户端每次想服务器发送给客户端都需要带上这些信息(通过请求头部选项Cookie)，服务器发现客户端发过来Cookie以后，会去检查是哪个客户端发来的，对比服务器上的记录得到状态信息。浏览器的自动登录就是这么实现的。</p>\n<p><img src=\"/pic/Cookie.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h2><p>例子：</p>\n<p><img src=\"/pic/HTTP%E8%AF%B7%E6%B1%82.png\" alt=\"\"></p>\n<p>第一行是请求行，格式为方法+URL+协议版本（主流版本是HTTP/1.1）</p>\n<p>第二行开始是请求头部，格式为头部选项：实体内容</p>\n<p>请求方法有很多种，如下图：</p>\n<p><img src=\"/pic/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95.png\" alt=\"\"></p>\n<p>具体字段就不赘述了。</p>\n<h2 id=\"HTTP应答\"><a href=\"#HTTP应答\" class=\"headerlink\" title=\"HTTP应答\"></a>HTTP应答</h2><p>例子：</p>\n<p><img src=\"/pic/HTTP%E5%BA%94%E7%AD%94.png\" alt=\"\"></p>\n<p>第一行是状态行，格式为协议版本+状态码+状态信息</p>\n<p>第二行开始是应答头部。格式为头部选项： 实体内容</p>\n<p>状态码和状态信息如下：</p>\n<p><img src=\"/pic/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.png\" alt=\"\"></p>\n<p>有一些字段需要注意一下，比如Cookie。</p>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p>HTTP是一种无状态的协议，每个HTTP请求之间没有上下文关系。但是，在交互式Web应用程序兴起，很多时候需要之前的信息。因此，就需要用额外的手段来保持HTTP连接状态，Cookie起的就是这个作用。Cookie是服务器发给客户端的特殊信息(通过HTTP应答头部选项Set-Cookie),通知客户端保存Cookie,客户端每次想服务器发送给客户端都需要带上这些信息(通过请求头部选项Cookie)，服务器发现客户端发过来Cookie以后，会去检查是哪个客户端发来的，对比服务器上的记录得到状态信息。浏览器的自动登录就是这么实现的。</p>\n<p><img src=\"/pic/Cookie.png\" alt=\"\"></p>\n"},{"title":"HTTP代理服务器","date":"2019-03-10T12:20:53.000Z","_content":"\n## HTTP代理服务器工作原理\n\n代理服务器的作用是实现对目标资源的中转访问，一般部署在客户端和目标服务器之间。\n\n按照使用方式和作用分为：正向代理服务器、反向代理服务器、透明代理服务器\n\n代理服务器通常提供缓存目标资源的功能，这样用户下次访问同一资源时速度会很快。\n\n#### 正向代理\n\n要求客户端自己设置代理服务器的地址。\n\n客户端每次请求都直接发送到该代理服务器，并由代理服务器来请求目标资源。\n\n比如处于局域网内的机器要访问Internet、访问一些被屏蔽掉的外网。\n\n#### 反向代理\n\n设置在服务器端，客户端无须进行任何设置。\n\n用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器得到的结果返回给客户端。这种情况下，代理服务器对外就表现为一个真实的服务器。\n\n很多时候，ping同一个域名，有多个ip地址，这是因为设置了反向代理服务器。\n\n![](/pic/代理服务器.png)\n\n上图很形象得反映了两者的区别。\n\n#### 透明代理\n\n只能设置在网关。用户访问Internet的数据报必然要经过网关，如果在网关上设置了代理，则该代理对用户来说显然是透明的，透明代理可以看做正向代理的一种特殊情况。\n\n\n\n#### 开源软件\n\nsquid、varnish都是提供了缓存能力的代理服务器软件‘\n\nsquid支持所有代理方式,varnish仅能做反向代理\n\n#### 部署squid代理服务器\n\n以后码上","source":"_posts/HTTP代理服务器.md","raw":"---\ntitle: HTTP代理服务器\ndate: 2019-03-10 20:20:53\ntags:\n- HTTP\n- 网络\n- Linux高性能服务器编程\n---\n\n## HTTP代理服务器工作原理\n\n代理服务器的作用是实现对目标资源的中转访问，一般部署在客户端和目标服务器之间。\n\n按照使用方式和作用分为：正向代理服务器、反向代理服务器、透明代理服务器\n\n代理服务器通常提供缓存目标资源的功能，这样用户下次访问同一资源时速度会很快。\n\n#### 正向代理\n\n要求客户端自己设置代理服务器的地址。\n\n客户端每次请求都直接发送到该代理服务器，并由代理服务器来请求目标资源。\n\n比如处于局域网内的机器要访问Internet、访问一些被屏蔽掉的外网。\n\n#### 反向代理\n\n设置在服务器端，客户端无须进行任何设置。\n\n用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器得到的结果返回给客户端。这种情况下，代理服务器对外就表现为一个真实的服务器。\n\n很多时候，ping同一个域名，有多个ip地址，这是因为设置了反向代理服务器。\n\n![](/pic/代理服务器.png)\n\n上图很形象得反映了两者的区别。\n\n#### 透明代理\n\n只能设置在网关。用户访问Internet的数据报必然要经过网关，如果在网关上设置了代理，则该代理对用户来说显然是透明的，透明代理可以看做正向代理的一种特殊情况。\n\n\n\n#### 开源软件\n\nsquid、varnish都是提供了缓存能力的代理服务器软件‘\n\nsquid支持所有代理方式,varnish仅能做反向代理\n\n#### 部署squid代理服务器\n\n以后码上","slug":"HTTP代理服务器","published":1,"updated":"2021-12-06T05:30:36.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip78000796ca79w765bk","content":"<h2 id=\"HTTP代理服务器工作原理\"><a href=\"#HTTP代理服务器工作原理\" class=\"headerlink\" title=\"HTTP代理服务器工作原理\"></a>HTTP代理服务器工作原理</h2><p>代理服务器的作用是实现对目标资源的中转访问，一般部署在客户端和目标服务器之间。</p>\n<p>按照使用方式和作用分为：正向代理服务器、反向代理服务器、透明代理服务器</p>\n<p>代理服务器通常提供缓存目标资源的功能，这样用户下次访问同一资源时速度会很快。</p>\n<h4 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h4><p>要求客户端自己设置代理服务器的地址。</p>\n<p>客户端每次请求都直接发送到该代理服务器，并由代理服务器来请求目标资源。</p>\n<p>比如处于局域网内的机器要访问Internet、访问一些被屏蔽掉的外网。</p>\n<h4 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h4><p>设置在服务器端，客户端无须进行任何设置。</p>\n<p>用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器得到的结果返回给客户端。这种情况下，代理服务器对外就表现为一个真实的服务器。</p>\n<p>很多时候，ping同一个域名，有多个ip地址，这是因为设置了反向代理服务器。</p>\n<p><img src=\"/pic/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.png\" alt=\"\"></p>\n<p>上图很形象得反映了两者的区别。</p>\n<h4 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h4><p>只能设置在网关。用户访问Internet的数据报必然要经过网关，如果在网关上设置了代理，则该代理对用户来说显然是透明的，透明代理可以看做正向代理的一种特殊情况。</p>\n<h4 id=\"开源软件\"><a href=\"#开源软件\" class=\"headerlink\" title=\"开源软件\"></a>开源软件</h4><p>squid、varnish都是提供了缓存能力的代理服务器软件‘</p>\n<p>squid支持所有代理方式,varnish仅能做反向代理</p>\n<h4 id=\"部署squid代理服务器\"><a href=\"#部署squid代理服务器\" class=\"headerlink\" title=\"部署squid代理服务器\"></a>部署squid代理服务器</h4><p>以后码上</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HTTP代理服务器工作原理\"><a href=\"#HTTP代理服务器工作原理\" class=\"headerlink\" title=\"HTTP代理服务器工作原理\"></a>HTTP代理服务器工作原理</h2><p>代理服务器的作用是实现对目标资源的中转访问，一般部署在客户端和目标服务器之间。</p>\n<p>按照使用方式和作用分为：正向代理服务器、反向代理服务器、透明代理服务器</p>\n<p>代理服务器通常提供缓存目标资源的功能，这样用户下次访问同一资源时速度会很快。</p>\n<h4 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h4><p>要求客户端自己设置代理服务器的地址。</p>\n<p>客户端每次请求都直接发送到该代理服务器，并由代理服务器来请求目标资源。</p>\n<p>比如处于局域网内的机器要访问Internet、访问一些被屏蔽掉的外网。</p>\n<h4 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h4><p>设置在服务器端，客户端无须进行任何设置。</p>\n<p>用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器得到的结果返回给客户端。这种情况下，代理服务器对外就表现为一个真实的服务器。</p>\n<p>很多时候，ping同一个域名，有多个ip地址，这是因为设置了反向代理服务器。</p>\n<p><img src=\"/pic/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.png\" alt=\"\"></p>\n<p>上图很形象得反映了两者的区别。</p>\n<h4 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h4><p>只能设置在网关。用户访问Internet的数据报必然要经过网关，如果在网关上设置了代理，则该代理对用户来说显然是透明的，透明代理可以看做正向代理的一种特殊情况。</p>\n<h4 id=\"开源软件\"><a href=\"#开源软件\" class=\"headerlink\" title=\"开源软件\"></a>开源软件</h4><p>squid、varnish都是提供了缓存能力的代理服务器软件‘</p>\n<p>squid支持所有代理方式,varnish仅能做反向代理</p>\n<h4 id=\"部署squid代理服务器\"><a href=\"#部署squid代理服务器\" class=\"headerlink\" title=\"部署squid代理服务器\"></a>部署squid代理服务器</h4><p>以后码上</p>\n"},{"layout":"w","title":"Linux下的网络I/O模型","date":"2018-11-26T12:40:40.000Z","_content":"\n在进行网络通信的过程中，接收方在读取数据的时候主要做了两件事情:\n1.等待数据准备好(从网络中抵达内核缓冲区)\n\n2.数据从内核缓冲区拷贝到进程的用户缓冲区\n\n## 概念区分\n\n1.同步/异步\n\n在UNP中POSIX的定义是：\n- 同步I/O操作导致请求进程阻塞，直到I/O操作完成\n- 异步I/O操作不导致请求进程阻塞\n在我看来，同步就是发生调用之后等待结果的返回，异步就是不等待结果的返回，继而做别的事情\n\n2.阻塞/非阻塞\n\n阻塞和非阻塞关心的是调用发生之后获取调用结果时的状态。\n阻塞是指调用结果返回之前，当前线程挂起，知道结果返回。\n非阻塞则不挂起当前线程，采用轮询的方式查看调用结果是否返回。\n\n<!-- more -->\n\n**举个例子**\n\n1.我准备烧一壶水，一直在水壶旁边等水开。(同步阻塞)\n2.我把水壶放好之后，就去做自己的事情，每隔一段时间来看看水开了没有(同步非阻塞)\n3.这次我用响水壶烧水，水开了之后自动就响，但是我比较傻，担心它不响，一直等水开(异步阻塞)\n4.我把响水壶放好之后，就去专心地做自己的事情，知道响水壶响了通知我去拿壶。(异步非阻塞)\n显然异步阻塞只是一种理论上的存在。在效率上看，异步显然明显优于同步。\n\n## 网络模型\n\n1.阻塞型IO\n![阻塞型网络IO](/pic/阻塞型网络IO.png)\n\n2.非阻塞型IO\n![非阻塞型网络IO](/pic/非阻塞型网络IO.png)\n\n这里需要设置套接字的非阻塞选项\n\n- 创建套接字的时候指定 socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP)\n- linux在一切皆文件  fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) |O_NONBLOCK）\n- ioctl(sockfd, FIONBIO, 1);  //1:非阻塞 0:阻塞\n\n阻塞型IO和非阻塞型IO一般配合多进程或者多线程模型，一个客户端对应一个进程或线程，开销大。\n\n3.IO复用(select、poll、epoll)\n![网络IO复用](/pic/网络IO复用.png)\n\n阻塞在IO模型调用函数上，等待对应的套接字的IO操作，可以监控多个套接字。\nIO复用一个进程就可以监控多个套接字，但是实现的是伪并发，客户端的请求只能一个一个处理，并且处理流程不宜过程。\n\n4.信号驱动型IO\n![信号驱动型IO](/pic/信号驱动型IO.png)\n\n需要开启套接字的信号驱动式I/O功能，通过fcntl将socket和SIGIO关联，当被关联的socket可读或可写的时候，系统触发SIGIO信号。(SIGURG是带外数据可读触发，也需要关联)。fcntl做的事情是为socket指定宿主进程或进程组，被指定的进程或进程组将捕获这两个信号。使用SIGIO时，还需要利用fcntl设置O_ASYNC标志，并且需要准备一个信号捕捉函数，在网络数据抵达内核缓冲区的时候会发出一个SIGIO的信号。\n\n5.异步IO\n![](/pic/异步IO.png)\n\n网络数据抵达内核缓冲区的时候，内核再帮我们完成从内核缓冲区到用户缓冲区的拷贝，然后再通知用户。使用aio_read函数给内核传递文件描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉当整个操作完成时如何通知我们(比如通过信号通知)。\n\n## 总结\n![](/pic/5种IO模型的比较.png)\n\n前4种IO模型都是同步IO，最后一种才是异步IO。\n\n前4种模型的主要区别在于第一个阶段，因为第二个阶段是一样的，都是recvfrom阻塞从内核缓冲区拷贝到用户缓冲区。异步IO则两个阶段都与前四种不同。\n\n换言之，同步I/O向应用程序通知的是I/O就绪事件，用户需要自己读取数据。\n\n异步I/O向应用程序通知的是I/O完成事件，内核帮用户完成了数据的读写。\n\n\n\n","source":"_posts/Linux下的网络IO模型 .md","raw":"---\nlayout: w\ntitle: Linux下的网络I/O模型\ndate: 2018-11-26 20:40:40\ntags: \n- 网络\n- Linux\n---\n\n在进行网络通信的过程中，接收方在读取数据的时候主要做了两件事情:\n1.等待数据准备好(从网络中抵达内核缓冲区)\n\n2.数据从内核缓冲区拷贝到进程的用户缓冲区\n\n## 概念区分\n\n1.同步/异步\n\n在UNP中POSIX的定义是：\n- 同步I/O操作导致请求进程阻塞，直到I/O操作完成\n- 异步I/O操作不导致请求进程阻塞\n在我看来，同步就是发生调用之后等待结果的返回，异步就是不等待结果的返回，继而做别的事情\n\n2.阻塞/非阻塞\n\n阻塞和非阻塞关心的是调用发生之后获取调用结果时的状态。\n阻塞是指调用结果返回之前，当前线程挂起，知道结果返回。\n非阻塞则不挂起当前线程，采用轮询的方式查看调用结果是否返回。\n\n<!-- more -->\n\n**举个例子**\n\n1.我准备烧一壶水，一直在水壶旁边等水开。(同步阻塞)\n2.我把水壶放好之后，就去做自己的事情，每隔一段时间来看看水开了没有(同步非阻塞)\n3.这次我用响水壶烧水，水开了之后自动就响，但是我比较傻，担心它不响，一直等水开(异步阻塞)\n4.我把响水壶放好之后，就去专心地做自己的事情，知道响水壶响了通知我去拿壶。(异步非阻塞)\n显然异步阻塞只是一种理论上的存在。在效率上看，异步显然明显优于同步。\n\n## 网络模型\n\n1.阻塞型IO\n![阻塞型网络IO](/pic/阻塞型网络IO.png)\n\n2.非阻塞型IO\n![非阻塞型网络IO](/pic/非阻塞型网络IO.png)\n\n这里需要设置套接字的非阻塞选项\n\n- 创建套接字的时候指定 socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP)\n- linux在一切皆文件  fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) |O_NONBLOCK）\n- ioctl(sockfd, FIONBIO, 1);  //1:非阻塞 0:阻塞\n\n阻塞型IO和非阻塞型IO一般配合多进程或者多线程模型，一个客户端对应一个进程或线程，开销大。\n\n3.IO复用(select、poll、epoll)\n![网络IO复用](/pic/网络IO复用.png)\n\n阻塞在IO模型调用函数上，等待对应的套接字的IO操作，可以监控多个套接字。\nIO复用一个进程就可以监控多个套接字，但是实现的是伪并发，客户端的请求只能一个一个处理，并且处理流程不宜过程。\n\n4.信号驱动型IO\n![信号驱动型IO](/pic/信号驱动型IO.png)\n\n需要开启套接字的信号驱动式I/O功能，通过fcntl将socket和SIGIO关联，当被关联的socket可读或可写的时候，系统触发SIGIO信号。(SIGURG是带外数据可读触发，也需要关联)。fcntl做的事情是为socket指定宿主进程或进程组，被指定的进程或进程组将捕获这两个信号。使用SIGIO时，还需要利用fcntl设置O_ASYNC标志，并且需要准备一个信号捕捉函数，在网络数据抵达内核缓冲区的时候会发出一个SIGIO的信号。\n\n5.异步IO\n![](/pic/异步IO.png)\n\n网络数据抵达内核缓冲区的时候，内核再帮我们完成从内核缓冲区到用户缓冲区的拷贝，然后再通知用户。使用aio_read函数给内核传递文件描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉当整个操作完成时如何通知我们(比如通过信号通知)。\n\n## 总结\n![](/pic/5种IO模型的比较.png)\n\n前4种IO模型都是同步IO，最后一种才是异步IO。\n\n前4种模型的主要区别在于第一个阶段，因为第二个阶段是一样的，都是recvfrom阻塞从内核缓冲区拷贝到用户缓冲区。异步IO则两个阶段都与前四种不同。\n\n换言之，同步I/O向应用程序通知的是I/O就绪事件，用户需要自己读取数据。\n\n异步I/O向应用程序通知的是I/O完成事件，内核帮用户完成了数据的读写。\n\n\n\n","slug":"Linux下的网络IO模型","published":1,"updated":"2021-12-06T05:30:36.990Z","comments":1,"photos":[],"link":"","_id":"ckwu9ip79000996ca724p3r8l","content":"<p>在进行网络通信的过程中，接收方在读取数据的时候主要做了两件事情:<br>1.等待数据准备好(从网络中抵达内核缓冲区)</p>\n<p>2.数据从内核缓冲区拷贝到进程的用户缓冲区</p>\n<h2 id=\"概念区分\"><a href=\"#概念区分\" class=\"headerlink\" title=\"概念区分\"></a>概念区分</h2><p>1.同步/异步</p>\n<p>在UNP中POSIX的定义是：</p>\n<ul>\n<li>同步I/O操作导致请求进程阻塞，直到I/O操作完成</li>\n<li>异步I/O操作不导致请求进程阻塞<br>在我看来，同步就是发生调用之后等待结果的返回，异步就是不等待结果的返回，继而做别的事情</li>\n</ul>\n<p>2.阻塞/非阻塞</p>\n<p>阻塞和非阻塞关心的是调用发生之后获取调用结果时的状态。<br>阻塞是指调用结果返回之前，当前线程挂起，知道结果返回。<br>非阻塞则不挂起当前线程，采用轮询的方式查看调用结果是否返回。</p>\n<a id=\"more\"></a>\n\n<p><strong>举个例子</strong></p>\n<p>1.我准备烧一壶水，一直在水壶旁边等水开。(同步阻塞)<br>2.我把水壶放好之后，就去做自己的事情，每隔一段时间来看看水开了没有(同步非阻塞)<br>3.这次我用响水壶烧水，水开了之后自动就响，但是我比较傻，担心它不响，一直等水开(异步阻塞)<br>4.我把响水壶放好之后，就去专心地做自己的事情，知道响水壶响了通知我去拿壶。(异步非阻塞)<br>显然异步阻塞只是一种理论上的存在。在效率上看，异步显然明显优于同步。</p>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><p>1.阻塞型IO<br><img src=\"/pic/%E9%98%BB%E5%A1%9E%E5%9E%8B%E7%BD%91%E7%BB%9CIO.png\" alt=\"阻塞型网络IO\"></p>\n<p>2.非阻塞型IO<br><img src=\"/pic/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%9E%8B%E7%BD%91%E7%BB%9CIO.png\" alt=\"非阻塞型网络IO\"></p>\n<p>这里需要设置套接字的非阻塞选项</p>\n<ul>\n<li>创建套接字的时候指定 socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP)</li>\n<li>linux在一切皆文件  fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) |O_NONBLOCK）</li>\n<li>ioctl(sockfd, FIONBIO, 1);  //1:非阻塞 0:阻塞</li>\n</ul>\n<p>阻塞型IO和非阻塞型IO一般配合多进程或者多线程模型，一个客户端对应一个进程或线程，开销大。</p>\n<p>3.IO复用(select、poll、epoll)<br><img src=\"/pic/%E7%BD%91%E7%BB%9CIO%E5%A4%8D%E7%94%A8.png\" alt=\"网络IO复用\"></p>\n<p>阻塞在IO模型调用函数上，等待对应的套接字的IO操作，可以监控多个套接字。<br>IO复用一个进程就可以监控多个套接字，但是实现的是伪并发，客户端的请求只能一个一个处理，并且处理流程不宜过程。</p>\n<p>4.信号驱动型IO<br><img src=\"/pic/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%9E%8BIO.png\" alt=\"信号驱动型IO\"></p>\n<p>需要开启套接字的信号驱动式I/O功能，通过fcntl将socket和SIGIO关联，当被关联的socket可读或可写的时候，系统触发SIGIO信号。(SIGURG是带外数据可读触发，也需要关联)。fcntl做的事情是为socket指定宿主进程或进程组，被指定的进程或进程组将捕获这两个信号。使用SIGIO时，还需要利用fcntl设置O_ASYNC标志，并且需要准备一个信号捕捉函数，在网络数据抵达内核缓冲区的时候会发出一个SIGIO的信号。</p>\n<p>5.异步IO<br><img src=\"/pic/%E5%BC%82%E6%AD%A5IO.png\" alt=\"\"></p>\n<p>网络数据抵达内核缓冲区的时候，内核再帮我们完成从内核缓冲区到用户缓冲区的拷贝，然后再通知用户。使用aio_read函数给内核传递文件描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉当整个操作完成时如何通知我们(比如通过信号通知)。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/pic/5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83.png\" alt=\"\"></p>\n<p>前4种IO模型都是同步IO，最后一种才是异步IO。</p>\n<p>前4种模型的主要区别在于第一个阶段，因为第二个阶段是一样的，都是recvfrom阻塞从内核缓冲区拷贝到用户缓冲区。异步IO则两个阶段都与前四种不同。</p>\n<p>换言之，同步I/O向应用程序通知的是I/O就绪事件，用户需要自己读取数据。</p>\n<p>异步I/O向应用程序通知的是I/O完成事件，内核帮用户完成了数据的读写。</p>\n","site":{"data":{}},"excerpt":"<p>在进行网络通信的过程中，接收方在读取数据的时候主要做了两件事情:<br>1.等待数据准备好(从网络中抵达内核缓冲区)</p>\n<p>2.数据从内核缓冲区拷贝到进程的用户缓冲区</p>\n<h2 id=\"概念区分\"><a href=\"#概念区分\" class=\"headerlink\" title=\"概念区分\"></a>概念区分</h2><p>1.同步/异步</p>\n<p>在UNP中POSIX的定义是：</p>\n<ul>\n<li>同步I/O操作导致请求进程阻塞，直到I/O操作完成</li>\n<li>异步I/O操作不导致请求进程阻塞<br>在我看来，同步就是发生调用之后等待结果的返回，异步就是不等待结果的返回，继而做别的事情</li>\n</ul>\n<p>2.阻塞/非阻塞</p>\n<p>阻塞和非阻塞关心的是调用发生之后获取调用结果时的状态。<br>阻塞是指调用结果返回之前，当前线程挂起，知道结果返回。<br>非阻塞则不挂起当前线程，采用轮询的方式查看调用结果是否返回。</p>","more":"<p><strong>举个例子</strong></p>\n<p>1.我准备烧一壶水，一直在水壶旁边等水开。(同步阻塞)<br>2.我把水壶放好之后，就去做自己的事情，每隔一段时间来看看水开了没有(同步非阻塞)<br>3.这次我用响水壶烧水，水开了之后自动就响，但是我比较傻，担心它不响，一直等水开(异步阻塞)<br>4.我把响水壶放好之后，就去专心地做自己的事情，知道响水壶响了通知我去拿壶。(异步非阻塞)<br>显然异步阻塞只是一种理论上的存在。在效率上看，异步显然明显优于同步。</p>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><p>1.阻塞型IO<br><img src=\"/pic/%E9%98%BB%E5%A1%9E%E5%9E%8B%E7%BD%91%E7%BB%9CIO.png\" alt=\"阻塞型网络IO\"></p>\n<p>2.非阻塞型IO<br><img src=\"/pic/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%9E%8B%E7%BD%91%E7%BB%9CIO.png\" alt=\"非阻塞型网络IO\"></p>\n<p>这里需要设置套接字的非阻塞选项</p>\n<ul>\n<li>创建套接字的时候指定 socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP)</li>\n<li>linux在一切皆文件  fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) |O_NONBLOCK）</li>\n<li>ioctl(sockfd, FIONBIO, 1);  //1:非阻塞 0:阻塞</li>\n</ul>\n<p>阻塞型IO和非阻塞型IO一般配合多进程或者多线程模型，一个客户端对应一个进程或线程，开销大。</p>\n<p>3.IO复用(select、poll、epoll)<br><img src=\"/pic/%E7%BD%91%E7%BB%9CIO%E5%A4%8D%E7%94%A8.png\" alt=\"网络IO复用\"></p>\n<p>阻塞在IO模型调用函数上，等待对应的套接字的IO操作，可以监控多个套接字。<br>IO复用一个进程就可以监控多个套接字，但是实现的是伪并发，客户端的请求只能一个一个处理，并且处理流程不宜过程。</p>\n<p>4.信号驱动型IO<br><img src=\"/pic/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%9E%8BIO.png\" alt=\"信号驱动型IO\"></p>\n<p>需要开启套接字的信号驱动式I/O功能，通过fcntl将socket和SIGIO关联，当被关联的socket可读或可写的时候，系统触发SIGIO信号。(SIGURG是带外数据可读触发，也需要关联)。fcntl做的事情是为socket指定宿主进程或进程组，被指定的进程或进程组将捕获这两个信号。使用SIGIO时，还需要利用fcntl设置O_ASYNC标志，并且需要准备一个信号捕捉函数，在网络数据抵达内核缓冲区的时候会发出一个SIGIO的信号。</p>\n<p>5.异步IO<br><img src=\"/pic/%E5%BC%82%E6%AD%A5IO.png\" alt=\"\"></p>\n<p>网络数据抵达内核缓冲区的时候，内核再帮我们完成从内核缓冲区到用户缓冲区的拷贝，然后再通知用户。使用aio_read函数给内核传递文件描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉当整个操作完成时如何通知我们(比如通过信号通知)。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/pic/5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83.png\" alt=\"\"></p>\n<p>前4种IO模型都是同步IO，最后一种才是异步IO。</p>\n<p>前4种模型的主要区别在于第一个阶段，因为第二个阶段是一样的，都是recvfrom阻塞从内核缓冲区拷贝到用户缓冲区。异步IO则两个阶段都与前四种不同。</p>\n<p>换言之，同步I/O向应用程序通知的是I/O就绪事件，用户需要自己读取数据。</p>\n<p>异步I/O向应用程序通知的是I/O完成事件，内核帮用户完成了数据的读写。</p>"},{"title":"STL六大部件","date":"2019-04-25T12:37:20.000Z","_content":"\nC++中很重要的一个库就是STL(Standard Template Library),叫做标准模板库，是C++标准库的一部分。\n\n六大组件\n\n- 容器(Containers)\n- 分配器(Allocator)\n- 算法(Algorithms)\n- 迭代器(Iterators)\n- 适配器(Adapters)\n- 仿函数(Functors)\n\n<!--more-->\n\n![](/pic/STL组件之间的关系.png)\n\n容器的作用是存储数据，数据需要占用内存，但是不需要我们管理内存，所以背后需要有分配器去支持容器。\n\n有一些操作是在容器本身做的，但是更多的操作被独立出来写成一个一个模板函数，封装在算法模块中。\n\n这里有一个观念需要注意：在面向对象编程中，我们希望数据和对数据的操作封装在一个类中，而STL将数据存储在容器中，对数据的操作写在算法中，做到了数据结构和算法的分离，这是模板编程的思想(generic programming)。\n\n迭代器是容器和算法之间的桥梁，迭代器就像是一种泛化的指针。\n\n仿函数作用像是一种函数\n\n适配器，adapter在英文中就是变压器，变压器做的就是电压的转换工作。因此适配器做的也是转换工作。\n\n实例程序：\n\n```\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n\tint ia[6] = { 27,210,12,47,109,40 };\n\tvector<int, allocator<int>> iv(ia, ia + 6); //allocator可以不写，底层默认有分配器\n\n\tcout << count_if(iv.begin(), iv.end(),\n\t\tnot1(bind2nd(less<int>(), 40)));\n\t//count_if 满足条件的元素的数量\n\t//less<int>() 仿函数 比较两个元素  但是现在是和40比较 因此用bind2nd固定第二个参数\n\t//bind2nd是一个仿函数适配器，bind2nd(less<int>(), 40)表示小于40\n\t//not1也是仿函数适配器，表示对条件取反，也就是编程大于等于40\n\t//最终输出的是数组中大于等于40的元素个数 也就是4\n\treturn 0;\n}\n```\n\n遍历容器的方法：\n\n```\nContainer<T> c;  //这里Container只是泛指，没有具体指哪个容器\n...\nContainer<T>::iterator ite = c.begin();\nfor(;ite != c.end();ite++)\n\t...\n\t\nlist<string> l;\n...\nlist<string>::iterator ite;\nite = ::find(l.begin(),l.end(),target);\n\n//C++11之后的简便写法   range-based for的应用以及auto关键字\nfor(int i : {2,3,4,7,9})\n\tcout<<i<<endl;\n\nvector<double> vec;\n...\nfor(auto elem : vec)\n\tcout<<elem<<endl;\n\nfor(auto &elem : vec)\n\telem *= 3;\t\n\nlist<string> l;\n...\nauto ite = ::find(l.begin(),l.end(),target);\n\n\n```\n\n","source":"_posts/STL六大部件.md","raw":"---\ntitle: STL六大部件\ndate: 2019-04-25 20:37:20\ntags:\n- C++\n- STL\n---\n\nC++中很重要的一个库就是STL(Standard Template Library),叫做标准模板库，是C++标准库的一部分。\n\n六大组件\n\n- 容器(Containers)\n- 分配器(Allocator)\n- 算法(Algorithms)\n- 迭代器(Iterators)\n- 适配器(Adapters)\n- 仿函数(Functors)\n\n<!--more-->\n\n![](/pic/STL组件之间的关系.png)\n\n容器的作用是存储数据，数据需要占用内存，但是不需要我们管理内存，所以背后需要有分配器去支持容器。\n\n有一些操作是在容器本身做的，但是更多的操作被独立出来写成一个一个模板函数，封装在算法模块中。\n\n这里有一个观念需要注意：在面向对象编程中，我们希望数据和对数据的操作封装在一个类中，而STL将数据存储在容器中，对数据的操作写在算法中，做到了数据结构和算法的分离，这是模板编程的思想(generic programming)。\n\n迭代器是容器和算法之间的桥梁，迭代器就像是一种泛化的指针。\n\n仿函数作用像是一种函数\n\n适配器，adapter在英文中就是变压器，变压器做的就是电压的转换工作。因此适配器做的也是转换工作。\n\n实例程序：\n\n```\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n\tint ia[6] = { 27,210,12,47,109,40 };\n\tvector<int, allocator<int>> iv(ia, ia + 6); //allocator可以不写，底层默认有分配器\n\n\tcout << count_if(iv.begin(), iv.end(),\n\t\tnot1(bind2nd(less<int>(), 40)));\n\t//count_if 满足条件的元素的数量\n\t//less<int>() 仿函数 比较两个元素  但是现在是和40比较 因此用bind2nd固定第二个参数\n\t//bind2nd是一个仿函数适配器，bind2nd(less<int>(), 40)表示小于40\n\t//not1也是仿函数适配器，表示对条件取反，也就是编程大于等于40\n\t//最终输出的是数组中大于等于40的元素个数 也就是4\n\treturn 0;\n}\n```\n\n遍历容器的方法：\n\n```\nContainer<T> c;  //这里Container只是泛指，没有具体指哪个容器\n...\nContainer<T>::iterator ite = c.begin();\nfor(;ite != c.end();ite++)\n\t...\n\t\nlist<string> l;\n...\nlist<string>::iterator ite;\nite = ::find(l.begin(),l.end(),target);\n\n//C++11之后的简便写法   range-based for的应用以及auto关键字\nfor(int i : {2,3,4,7,9})\n\tcout<<i<<endl;\n\nvector<double> vec;\n...\nfor(auto elem : vec)\n\tcout<<elem<<endl;\n\nfor(auto &elem : vec)\n\telem *= 3;\t\n\nlist<string> l;\n...\nauto ite = ::find(l.begin(),l.end(),target);\n\n\n```\n\n","slug":"STL六大部件","published":1,"updated":"2021-12-06T05:30:36.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7a000a96cadx0z85cw","content":"<p>C++中很重要的一个库就是STL(Standard Template Library),叫做标准模板库，是C++标准库的一部分。</p>\n<p>六大组件</p>\n<ul>\n<li>容器(Containers)</li>\n<li>分配器(Allocator)</li>\n<li>算法(Algorithms)</li>\n<li>迭代器(Iterators)</li>\n<li>适配器(Adapters)</li>\n<li>仿函数(Functors)</li>\n</ul>\n<a id=\"more\"></a>\n\n<p><img src=\"/pic/STL%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"\"></p>\n<p>容器的作用是存储数据，数据需要占用内存，但是不需要我们管理内存，所以背后需要有分配器去支持容器。</p>\n<p>有一些操作是在容器本身做的，但是更多的操作被独立出来写成一个一个模板函数，封装在算法模块中。</p>\n<p>这里有一个观念需要注意：在面向对象编程中，我们希望数据和对数据的操作封装在一个类中，而STL将数据存储在容器中，对数据的操作写在算法中，做到了数据结构和算法的分离，这是模板编程的思想(generic programming)。</p>\n<p>迭代器是容器和算法之间的桥梁，迭代器就像是一种泛化的指针。</p>\n<p>仿函数作用像是一种函数</p>\n<p>适配器，adapter在英文中就是变压器，变压器做的就是电压的转换工作。因此适配器做的也是转换工作。</p>\n<p>实例程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;vector&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">#include&lt;functional&gt;</span><br><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint ia[6] &#x3D; &#123; 27,210,12,47,109,40 &#125;;</span><br><span class=\"line\">\tvector&lt;int, allocator&lt;int&gt;&gt; iv(ia, ia + 6); &#x2F;&#x2F;allocator可以不写，底层默认有分配器</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; count_if(iv.begin(), iv.end(),</span><br><span class=\"line\">\t\tnot1(bind2nd(less&lt;int&gt;(), 40)));</span><br><span class=\"line\">\t&#x2F;&#x2F;count_if 满足条件的元素的数量</span><br><span class=\"line\">\t&#x2F;&#x2F;less&lt;int&gt;() 仿函数 比较两个元素  但是现在是和40比较 因此用bind2nd固定第二个参数</span><br><span class=\"line\">\t&#x2F;&#x2F;bind2nd是一个仿函数适配器，bind2nd(less&lt;int&gt;(), 40)表示小于40</span><br><span class=\"line\">\t&#x2F;&#x2F;not1也是仿函数适配器，表示对条件取反，也就是编程大于等于40</span><br><span class=\"line\">\t&#x2F;&#x2F;最终输出的是数组中大于等于40的元素个数 也就是4</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遍历容器的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container&lt;T&gt; c;  &#x2F;&#x2F;这里Container只是泛指，没有具体指哪个容器</span><br><span class=\"line\">...</span><br><span class=\"line\">Container&lt;T&gt;::iterator ite &#x3D; c.begin();</span><br><span class=\"line\">for(;ite !&#x3D; c.end();ite++)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t</span><br><span class=\"line\">list&lt;string&gt; l;</span><br><span class=\"line\">...</span><br><span class=\"line\">list&lt;string&gt;::iterator ite;</span><br><span class=\"line\">ite &#x3D; ::find(l.begin(),l.end(),target);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;C++11之后的简便写法   range-based for的应用以及auto关键字</span><br><span class=\"line\">for(int i : &#123;2,3,4,7,9&#125;)</span><br><span class=\"line\">\tcout&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;double&gt; vec;</span><br><span class=\"line\">...</span><br><span class=\"line\">for(auto elem : vec)</span><br><span class=\"line\">\tcout&lt;&lt;elem&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">for(auto &amp;elem : vec)</span><br><span class=\"line\">\telem *&#x3D; 3;\t</span><br><span class=\"line\"></span><br><span class=\"line\">list&lt;string&gt; l;</span><br><span class=\"line\">...</span><br><span class=\"line\">auto ite &#x3D; ::find(l.begin(),l.end(),target);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>C++中很重要的一个库就是STL(Standard Template Library),叫做标准模板库，是C++标准库的一部分。</p>\n<p>六大组件</p>\n<ul>\n<li>容器(Containers)</li>\n<li>分配器(Allocator)</li>\n<li>算法(Algorithms)</li>\n<li>迭代器(Iterators)</li>\n<li>适配器(Adapters)</li>\n<li>仿函数(Functors)</li>\n</ul>","more":"<p><img src=\"/pic/STL%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png\" alt=\"\"></p>\n<p>容器的作用是存储数据，数据需要占用内存，但是不需要我们管理内存，所以背后需要有分配器去支持容器。</p>\n<p>有一些操作是在容器本身做的，但是更多的操作被独立出来写成一个一个模板函数，封装在算法模块中。</p>\n<p>这里有一个观念需要注意：在面向对象编程中，我们希望数据和对数据的操作封装在一个类中，而STL将数据存储在容器中，对数据的操作写在算法中，做到了数据结构和算法的分离，这是模板编程的思想(generic programming)。</p>\n<p>迭代器是容器和算法之间的桥梁，迭代器就像是一种泛化的指针。</p>\n<p>仿函数作用像是一种函数</p>\n<p>适配器，adapter在英文中就是变压器，变压器做的就是电压的转换工作。因此适配器做的也是转换工作。</p>\n<p>实例程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;vector&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">#include&lt;functional&gt;</span><br><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint ia[6] &#x3D; &#123; 27,210,12,47,109,40 &#125;;</span><br><span class=\"line\">\tvector&lt;int, allocator&lt;int&gt;&gt; iv(ia, ia + 6); &#x2F;&#x2F;allocator可以不写，底层默认有分配器</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; count_if(iv.begin(), iv.end(),</span><br><span class=\"line\">\t\tnot1(bind2nd(less&lt;int&gt;(), 40)));</span><br><span class=\"line\">\t&#x2F;&#x2F;count_if 满足条件的元素的数量</span><br><span class=\"line\">\t&#x2F;&#x2F;less&lt;int&gt;() 仿函数 比较两个元素  但是现在是和40比较 因此用bind2nd固定第二个参数</span><br><span class=\"line\">\t&#x2F;&#x2F;bind2nd是一个仿函数适配器，bind2nd(less&lt;int&gt;(), 40)表示小于40</span><br><span class=\"line\">\t&#x2F;&#x2F;not1也是仿函数适配器，表示对条件取反，也就是编程大于等于40</span><br><span class=\"line\">\t&#x2F;&#x2F;最终输出的是数组中大于等于40的元素个数 也就是4</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遍历容器的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container&lt;T&gt; c;  &#x2F;&#x2F;这里Container只是泛指，没有具体指哪个容器</span><br><span class=\"line\">...</span><br><span class=\"line\">Container&lt;T&gt;::iterator ite &#x3D; c.begin();</span><br><span class=\"line\">for(;ite !&#x3D; c.end();ite++)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t</span><br><span class=\"line\">list&lt;string&gt; l;</span><br><span class=\"line\">...</span><br><span class=\"line\">list&lt;string&gt;::iterator ite;</span><br><span class=\"line\">ite &#x3D; ::find(l.begin(),l.end(),target);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;C++11之后的简便写法   range-based for的应用以及auto关键字</span><br><span class=\"line\">for(int i : &#123;2,3,4,7,9&#125;)</span><br><span class=\"line\">\tcout&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;double&gt; vec;</span><br><span class=\"line\">...</span><br><span class=\"line\">for(auto elem : vec)</span><br><span class=\"line\">\tcout&lt;&lt;elem&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">for(auto &amp;elem : vec)</span><br><span class=\"line\">\telem *&#x3D; 3;\t</span><br><span class=\"line\"></span><br><span class=\"line\">list&lt;string&gt; l;</span><br><span class=\"line\">...</span><br><span class=\"line\">auto ite &#x3D; ::find(l.begin(),l.end(),target);</span><br></pre></td></tr></table></figure>"},{"title":"TCP协议","date":"2018-11-17T11:50:26.000Z","_content":"\n## TCP特点\n\nTCP全称叫传输控制协议，是传输层两大协议之一。\n\nTCP是一种面向连接的、可靠的、数据流的协议。连接方式是一对一，类似于打电话，数据交互之前需要连接，然后才可以通信。\n\nTCP的可靠体现在:\n\n- 传输数据之前需要建立连接\n- 发送应答机制(数据需要确认)\n- 发送端超时重传(丢包)\n- 乱序重组(根据序列号)\n- 校验码校验\n- 滑动窗口\n- 拥塞控制\n\n<!-- more -->\n\n## TCP首部\n\n![TCP首部](/pic/TCP首部.png)\n\n1.源端口和目标端口很好理解，传输层就是实现端到端的通信的。\n简单介绍一下端口号。端口就是用来标识一个网络应用的。范围是0-66635,\n1-1023是知名端口号，由Internet号分配机构管理。\n1024-5000是临时端口，大于5000的是为其他服务器预留的\n\n一些知名端口号:\n![知名端口号](/pic/知名端口号.png)\n\n2.序号 :《TCP/IP:协议》上是这么解释的，用来标识从TCP发端向TCP收端发送的数据字节流，它标识在这个报文段中的第一个数据字节。用序号对每个字节进行技术，序号到达最大值(2的32次-1)再从0开始。初始序号是随机的。\n\n简而言之，序号就是对已发数据字节进行计数的。\n\n3.确认序号 :确认接收端已经收到了发送端前n个字节，请求第n+1个字节开始的数据\n因此确认序号是上次已成功收到数据字节序号加1\n\n4.首部长度: 给出首部中32bit字(4字节)的数目，由于不加选项的TCP首部至少是20个字节，因此首部长度最小为5，由于首部长度这个字段占4位，因此TCP首部最多有60个字节。\n\n5.六个标志位   置1代表触发\n\nURG  紧急指针有效\nACK   确认序号有效\nPSH   接收方应该尽快将这个报文段交给应用层\nRST   重建连接\nSYN  同步序号用来发起一个连接\nFIN   发端完成发送任务\n\n6.窗口大小   TCP利用滑动窗口进行流量控制\n\n7.检验和  强制性字段   用于收端进行验证\n\n8.紧急指针  是一个正的偏移量(很少用)\n\n9.选项     \n\n- 比较常见的是最长报文大小(MSS) ,在建立连接的第一个报文指定\n- 窗口扩大选项(3个字节，每个字节表示移位值)\n- 时间戳选项(10个字节)   时间戳值和时间戳回送回答字段\n\n## TCP头部选项\n\n选项最多40字节，加上固定头部20字节，TCP头部最多60字节\n\nTCP头部选项一般结构：\n\n![](/pic/TCP头部选项一般结构.png)\n\n常见的7种TCP头部选项：\n\n![](/pic/常见TCP头部选项.png)\n\n- kind = 0 选项表结束选项\n\n- kind = 1 空操作选项，没什么含义，一般用来将TCP选项总长度填充为4字节整数倍\n\n- kind = 2 最大报文段长度选项(MSS)，在连接初始化协商，TCP模块通常设置成(MTU-40)字节，去除20字节的TCP头部和20字节的IP头部（假设都不加选项），避免本机IP分片，对以太网而言，MSS一般为1460\n\n- kind = 3 窗口扩大因子选项。在连接初始化协商。在TCP头部接收通告窗口大小是16位表示，最大是65536字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数(为了提高TCP吞吐量)，窗口扩大因子(移位数，取值范围0-14)，假设接收窗口一开始大小为M，窗口扩大因子是N，实际接收窗口大小为M*2^N。\n\n  可以修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或者关闭窗口扩大因子选项\n\n  注意点：和MSS选项一样，窗口扩大因子只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立之后，每个数据传输方向的窗口扩大因子就固定不变了。(我懵逼了，不懂什么意思)\n\n- kind = 4 ，选择性确认(SACK)。如果某个TCP报文段丢失，TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先有些已经正确传输但在丢失报文段之后的报文就会被重复发送，从而降低TCP性能。SACK能够改善这种情况，使TCP模块只重新发送丢失的TCP报文段。\n\n  可以修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项\n\n- kind = 5 ，SACK实际工作的选项。该选项的参数告诉发送方已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。块左边沿表示不连续块的第一个数据序号，块右边沿表示不连续块的最后一个数据序号的下一个序号，这一对参数之间的数据是没有收到的，占用8字节。\n\n- kind = 8 ,时间戳选项。提供较为精确的计算通信双方之间的回路时间(RTT)的方法，从而为TCP流量控制提供重要信息。\n\n  可以修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项\n\n## tcpdump抓包观察TCP头部\n\n![](/pic/tcp抓包1.png)\n\n抓取到的数据包：\n\n![](/pic/tcp抓包2.png)\n\nFlags[S]:表示TCP报文段中有SYN标志，是一个同步报文段\n\nseq:序号值。该同步报文值是从127.0.0.1.34278（客户端）到127.0.0.1.23（服务器）这个传输方向上的第一个TCP报文段，所以这个序号值也是这次通信过程中该传输方向上的ISN值。\n\nwin:接收通告窗口大小。因为这是一个同步报文段，所以反映的是实际接收通告大小\n\noptions：TCP选项。mss是发送端(客户端通告的最大报文段长度)、sackOK表示发送端支持并同意使用SACK选项、TS val是发送端的时间戳、ecr是时间戳回显应答、nop是一个空操作选项、wscale是发送端使用的窗口扩大因子。\n\n前20字节是IP头部，后40字节是TCP头部\n\n因此从第21字节开始分析\n\n| 十六进制数 | 十进制表示 | TCP头部信息                               |\n| ---------- | ---------- | ----------------------------------------- |\n| 0x85e6     | 34278      | 源端口号                                  |\n| 0x0017     | 23         | 目的端口号                                |\n| 0x599d891d | 1503496477 | 序号                                      |\n| 0x00000000 | 0          | 确认号                                    |\n| 0xa        | 10         | 头部长度时10*4字节                        |\n| 0x002      |            | 设置了SYN标志                             |\n| 0xaaaa     | 43690      | 接收通告窗口大小                          |\n| 0xfe30     |            | 头部校验和                                |\n| 0x0000     |            | 没设置URG标志，所以紧急指针无意义         |\n| 0x0204     |            | 最大报文段长度(MSS)选项的kind值和length值 |\n| 0xffd7     | 65495      | 最大报文段长度                            |\n| 0x0402     |            | 允许SACK选项                              |\n| 0x080a     |            | 时间戳选项的kind值和length值              |\n| 0x001cdf6d | 1892205    | 时间戳                                    |\n| 0x00000000 | 0          | 时间戳回显应答                            |\n| 0x01       |            | 空操作选项(nop)                           |\n| 0x0303     |            | 窗口扩大因子选项的kind值和length值        |\n| 0x07       | 7          | 窗口扩大因子为7(移位数)                   |\n\n\n\n\n\n\n\n","source":"_posts/TCP协议.md","raw":"---\ntitle: TCP协议\ndate: 2018-11-17 19:50:26\ntags: \n- TCP\n- 网络\n- Linux高性能服务器编程\n---\n\n## TCP特点\n\nTCP全称叫传输控制协议，是传输层两大协议之一。\n\nTCP是一种面向连接的、可靠的、数据流的协议。连接方式是一对一，类似于打电话，数据交互之前需要连接，然后才可以通信。\n\nTCP的可靠体现在:\n\n- 传输数据之前需要建立连接\n- 发送应答机制(数据需要确认)\n- 发送端超时重传(丢包)\n- 乱序重组(根据序列号)\n- 校验码校验\n- 滑动窗口\n- 拥塞控制\n\n<!-- more -->\n\n## TCP首部\n\n![TCP首部](/pic/TCP首部.png)\n\n1.源端口和目标端口很好理解，传输层就是实现端到端的通信的。\n简单介绍一下端口号。端口就是用来标识一个网络应用的。范围是0-66635,\n1-1023是知名端口号，由Internet号分配机构管理。\n1024-5000是临时端口，大于5000的是为其他服务器预留的\n\n一些知名端口号:\n![知名端口号](/pic/知名端口号.png)\n\n2.序号 :《TCP/IP:协议》上是这么解释的，用来标识从TCP发端向TCP收端发送的数据字节流，它标识在这个报文段中的第一个数据字节。用序号对每个字节进行技术，序号到达最大值(2的32次-1)再从0开始。初始序号是随机的。\n\n简而言之，序号就是对已发数据字节进行计数的。\n\n3.确认序号 :确认接收端已经收到了发送端前n个字节，请求第n+1个字节开始的数据\n因此确认序号是上次已成功收到数据字节序号加1\n\n4.首部长度: 给出首部中32bit字(4字节)的数目，由于不加选项的TCP首部至少是20个字节，因此首部长度最小为5，由于首部长度这个字段占4位，因此TCP首部最多有60个字节。\n\n5.六个标志位   置1代表触发\n\nURG  紧急指针有效\nACK   确认序号有效\nPSH   接收方应该尽快将这个报文段交给应用层\nRST   重建连接\nSYN  同步序号用来发起一个连接\nFIN   发端完成发送任务\n\n6.窗口大小   TCP利用滑动窗口进行流量控制\n\n7.检验和  强制性字段   用于收端进行验证\n\n8.紧急指针  是一个正的偏移量(很少用)\n\n9.选项     \n\n- 比较常见的是最长报文大小(MSS) ,在建立连接的第一个报文指定\n- 窗口扩大选项(3个字节，每个字节表示移位值)\n- 时间戳选项(10个字节)   时间戳值和时间戳回送回答字段\n\n## TCP头部选项\n\n选项最多40字节，加上固定头部20字节，TCP头部最多60字节\n\nTCP头部选项一般结构：\n\n![](/pic/TCP头部选项一般结构.png)\n\n常见的7种TCP头部选项：\n\n![](/pic/常见TCP头部选项.png)\n\n- kind = 0 选项表结束选项\n\n- kind = 1 空操作选项，没什么含义，一般用来将TCP选项总长度填充为4字节整数倍\n\n- kind = 2 最大报文段长度选项(MSS)，在连接初始化协商，TCP模块通常设置成(MTU-40)字节，去除20字节的TCP头部和20字节的IP头部（假设都不加选项），避免本机IP分片，对以太网而言，MSS一般为1460\n\n- kind = 3 窗口扩大因子选项。在连接初始化协商。在TCP头部接收通告窗口大小是16位表示，最大是65536字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数(为了提高TCP吞吐量)，窗口扩大因子(移位数，取值范围0-14)，假设接收窗口一开始大小为M，窗口扩大因子是N，实际接收窗口大小为M*2^N。\n\n  可以修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或者关闭窗口扩大因子选项\n\n  注意点：和MSS选项一样，窗口扩大因子只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立之后，每个数据传输方向的窗口扩大因子就固定不变了。(我懵逼了，不懂什么意思)\n\n- kind = 4 ，选择性确认(SACK)。如果某个TCP报文段丢失，TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先有些已经正确传输但在丢失报文段之后的报文就会被重复发送，从而降低TCP性能。SACK能够改善这种情况，使TCP模块只重新发送丢失的TCP报文段。\n\n  可以修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项\n\n- kind = 5 ，SACK实际工作的选项。该选项的参数告诉发送方已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。块左边沿表示不连续块的第一个数据序号，块右边沿表示不连续块的最后一个数据序号的下一个序号，这一对参数之间的数据是没有收到的，占用8字节。\n\n- kind = 8 ,时间戳选项。提供较为精确的计算通信双方之间的回路时间(RTT)的方法，从而为TCP流量控制提供重要信息。\n\n  可以修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项\n\n## tcpdump抓包观察TCP头部\n\n![](/pic/tcp抓包1.png)\n\n抓取到的数据包：\n\n![](/pic/tcp抓包2.png)\n\nFlags[S]:表示TCP报文段中有SYN标志，是一个同步报文段\n\nseq:序号值。该同步报文值是从127.0.0.1.34278（客户端）到127.0.0.1.23（服务器）这个传输方向上的第一个TCP报文段，所以这个序号值也是这次通信过程中该传输方向上的ISN值。\n\nwin:接收通告窗口大小。因为这是一个同步报文段，所以反映的是实际接收通告大小\n\noptions：TCP选项。mss是发送端(客户端通告的最大报文段长度)、sackOK表示发送端支持并同意使用SACK选项、TS val是发送端的时间戳、ecr是时间戳回显应答、nop是一个空操作选项、wscale是发送端使用的窗口扩大因子。\n\n前20字节是IP头部，后40字节是TCP头部\n\n因此从第21字节开始分析\n\n| 十六进制数 | 十进制表示 | TCP头部信息                               |\n| ---------- | ---------- | ----------------------------------------- |\n| 0x85e6     | 34278      | 源端口号                                  |\n| 0x0017     | 23         | 目的端口号                                |\n| 0x599d891d | 1503496477 | 序号                                      |\n| 0x00000000 | 0          | 确认号                                    |\n| 0xa        | 10         | 头部长度时10*4字节                        |\n| 0x002      |            | 设置了SYN标志                             |\n| 0xaaaa     | 43690      | 接收通告窗口大小                          |\n| 0xfe30     |            | 头部校验和                                |\n| 0x0000     |            | 没设置URG标志，所以紧急指针无意义         |\n| 0x0204     |            | 最大报文段长度(MSS)选项的kind值和length值 |\n| 0xffd7     | 65495      | 最大报文段长度                            |\n| 0x0402     |            | 允许SACK选项                              |\n| 0x080a     |            | 时间戳选项的kind值和length值              |\n| 0x001cdf6d | 1892205    | 时间戳                                    |\n| 0x00000000 | 0          | 时间戳回显应答                            |\n| 0x01       |            | 空操作选项(nop)                           |\n| 0x0303     |            | 窗口扩大因子选项的kind值和length值        |\n| 0x07       | 7          | 窗口扩大因子为7(移位数)                   |\n\n\n\n\n\n\n\n","slug":"TCP协议","published":1,"updated":"2021-12-06T05:30:36.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7c000c96ca9yjmftli","content":"<h2 id=\"TCP特点\"><a href=\"#TCP特点\" class=\"headerlink\" title=\"TCP特点\"></a>TCP特点</h2><p>TCP全称叫传输控制协议，是传输层两大协议之一。</p>\n<p>TCP是一种面向连接的、可靠的、数据流的协议。连接方式是一对一，类似于打电话，数据交互之前需要连接，然后才可以通信。</p>\n<p>TCP的可靠体现在:</p>\n<ul>\n<li>传输数据之前需要建立连接</li>\n<li>发送应答机制(数据需要确认)</li>\n<li>发送端超时重传(丢包)</li>\n<li>乱序重组(根据序列号)</li>\n<li>校验码校验</li>\n<li>滑动窗口</li>\n<li>拥塞控制</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"TCP首部\"><a href=\"#TCP首部\" class=\"headerlink\" title=\"TCP首部\"></a>TCP首部</h2><p><img src=\"/pic/TCP%E9%A6%96%E9%83%A8.png\" alt=\"TCP首部\"></p>\n<p>1.源端口和目标端口很好理解，传输层就是实现端到端的通信的。<br>简单介绍一下端口号。端口就是用来标识一个网络应用的。范围是0-66635,<br>1-1023是知名端口号，由Internet号分配机构管理。<br>1024-5000是临时端口，大于5000的是为其他服务器预留的</p>\n<p>一些知名端口号:<br><img src=\"/pic/%E7%9F%A5%E5%90%8D%E7%AB%AF%E5%8F%A3%E5%8F%B7.png\" alt=\"知名端口号\"></p>\n<p>2.序号 :《TCP/IP:协议》上是这么解释的，用来标识从TCP发端向TCP收端发送的数据字节流，它标识在这个报文段中的第一个数据字节。用序号对每个字节进行技术，序号到达最大值(2的32次-1)再从0开始。初始序号是随机的。</p>\n<p>简而言之，序号就是对已发数据字节进行计数的。</p>\n<p>3.确认序号 :确认接收端已经收到了发送端前n个字节，请求第n+1个字节开始的数据<br>因此确认序号是上次已成功收到数据字节序号加1</p>\n<p>4.首部长度: 给出首部中32bit字(4字节)的数目，由于不加选项的TCP首部至少是20个字节，因此首部长度最小为5，由于首部长度这个字段占4位，因此TCP首部最多有60个字节。</p>\n<p>5.六个标志位   置1代表触发</p>\n<p>URG  紧急指针有效<br>ACK   确认序号有效<br>PSH   接收方应该尽快将这个报文段交给应用层<br>RST   重建连接<br>SYN  同步序号用来发起一个连接<br>FIN   发端完成发送任务</p>\n<p>6.窗口大小   TCP利用滑动窗口进行流量控制</p>\n<p>7.检验和  强制性字段   用于收端进行验证</p>\n<p>8.紧急指针  是一个正的偏移量(很少用)</p>\n<p>9.选项     </p>\n<ul>\n<li>比较常见的是最长报文大小(MSS) ,在建立连接的第一个报文指定</li>\n<li>窗口扩大选项(3个字节，每个字节表示移位值)</li>\n<li>时间戳选项(10个字节)   时间戳值和时间戳回送回答字段</li>\n</ul>\n<h2 id=\"TCP头部选项\"><a href=\"#TCP头部选项\" class=\"headerlink\" title=\"TCP头部选项\"></a>TCP头部选项</h2><p>选项最多40字节，加上固定头部20字节，TCP头部最多60字节</p>\n<p>TCP头部选项一般结构：</p>\n<p><img src=\"/pic/TCP%E5%A4%B4%E9%83%A8%E9%80%89%E9%A1%B9%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>常见的7种TCP头部选项：</p>\n<p><img src=\"/pic/%E5%B8%B8%E8%A7%81TCP%E5%A4%B4%E9%83%A8%E9%80%89%E9%A1%B9.png\" alt=\"\"></p>\n<ul>\n<li><p>kind = 0 选项表结束选项</p>\n</li>\n<li><p>kind = 1 空操作选项，没什么含义，一般用来将TCP选项总长度填充为4字节整数倍</p>\n</li>\n<li><p>kind = 2 最大报文段长度选项(MSS)，在连接初始化协商，TCP模块通常设置成(MTU-40)字节，去除20字节的TCP头部和20字节的IP头部（假设都不加选项），避免本机IP分片，对以太网而言，MSS一般为1460</p>\n</li>\n<li><p>kind = 3 窗口扩大因子选项。在连接初始化协商。在TCP头部接收通告窗口大小是16位表示，最大是65536字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数(为了提高TCP吞吐量)，窗口扩大因子(移位数，取值范围0-14)，假设接收窗口一开始大小为M，窗口扩大因子是N，实际接收窗口大小为M*2^N。</p>\n<p>可以修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或者关闭窗口扩大因子选项</p>\n<p>注意点：和MSS选项一样，窗口扩大因子只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立之后，每个数据传输方向的窗口扩大因子就固定不变了。(我懵逼了，不懂什么意思)</p>\n</li>\n<li><p>kind = 4 ，选择性确认(SACK)。如果某个TCP报文段丢失，TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先有些已经正确传输但在丢失报文段之后的报文就会被重复发送，从而降低TCP性能。SACK能够改善这种情况，使TCP模块只重新发送丢失的TCP报文段。</p>\n<p>可以修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项</p>\n</li>\n<li><p>kind = 5 ，SACK实际工作的选项。该选项的参数告诉发送方已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。块左边沿表示不连续块的第一个数据序号，块右边沿表示不连续块的最后一个数据序号的下一个序号，这一对参数之间的数据是没有收到的，占用8字节。</p>\n</li>\n<li><p>kind = 8 ,时间戳选项。提供较为精确的计算通信双方之间的回路时间(RTT)的方法，从而为TCP流量控制提供重要信息。</p>\n<p>可以修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项</p>\n</li>\n</ul>\n<h2 id=\"tcpdump抓包观察TCP头部\"><a href=\"#tcpdump抓包观察TCP头部\" class=\"headerlink\" title=\"tcpdump抓包观察TCP头部\"></a>tcpdump抓包观察TCP头部</h2><p><img src=\"/pic/tcp%E6%8A%93%E5%8C%851.png\" alt=\"\"></p>\n<p>抓取到的数据包：</p>\n<p><img src=\"/pic/tcp%E6%8A%93%E5%8C%852.png\" alt=\"\"></p>\n<p>Flags[S]:表示TCP报文段中有SYN标志，是一个同步报文段</p>\n<p>seq:序号值。该同步报文值是从127.0.0.1.34278（客户端）到127.0.0.1.23（服务器）这个传输方向上的第一个TCP报文段，所以这个序号值也是这次通信过程中该传输方向上的ISN值。</p>\n<p>win:接收通告窗口大小。因为这是一个同步报文段，所以反映的是实际接收通告大小</p>\n<p>options：TCP选项。mss是发送端(客户端通告的最大报文段长度)、sackOK表示发送端支持并同意使用SACK选项、TS val是发送端的时间戳、ecr是时间戳回显应答、nop是一个空操作选项、wscale是发送端使用的窗口扩大因子。</p>\n<p>前20字节是IP头部，后40字节是TCP头部</p>\n<p>因此从第21字节开始分析</p>\n<table>\n<thead>\n<tr>\n<th>十六进制数</th>\n<th>十进制表示</th>\n<th>TCP头部信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x85e6</td>\n<td>34278</td>\n<td>源端口号</td>\n</tr>\n<tr>\n<td>0x0017</td>\n<td>23</td>\n<td>目的端口号</td>\n</tr>\n<tr>\n<td>0x599d891d</td>\n<td>1503496477</td>\n<td>序号</td>\n</tr>\n<tr>\n<td>0x00000000</td>\n<td>0</td>\n<td>确认号</td>\n</tr>\n<tr>\n<td>0xa</td>\n<td>10</td>\n<td>头部长度时10*4字节</td>\n</tr>\n<tr>\n<td>0x002</td>\n<td></td>\n<td>设置了SYN标志</td>\n</tr>\n<tr>\n<td>0xaaaa</td>\n<td>43690</td>\n<td>接收通告窗口大小</td>\n</tr>\n<tr>\n<td>0xfe30</td>\n<td></td>\n<td>头部校验和</td>\n</tr>\n<tr>\n<td>0x0000</td>\n<td></td>\n<td>没设置URG标志，所以紧急指针无意义</td>\n</tr>\n<tr>\n<td>0x0204</td>\n<td></td>\n<td>最大报文段长度(MSS)选项的kind值和length值</td>\n</tr>\n<tr>\n<td>0xffd7</td>\n<td>65495</td>\n<td>最大报文段长度</td>\n</tr>\n<tr>\n<td>0x0402</td>\n<td></td>\n<td>允许SACK选项</td>\n</tr>\n<tr>\n<td>0x080a</td>\n<td></td>\n<td>时间戳选项的kind值和length值</td>\n</tr>\n<tr>\n<td>0x001cdf6d</td>\n<td>1892205</td>\n<td>时间戳</td>\n</tr>\n<tr>\n<td>0x00000000</td>\n<td>0</td>\n<td>时间戳回显应答</td>\n</tr>\n<tr>\n<td>0x01</td>\n<td></td>\n<td>空操作选项(nop)</td>\n</tr>\n<tr>\n<td>0x0303</td>\n<td></td>\n<td>窗口扩大因子选项的kind值和length值</td>\n</tr>\n<tr>\n<td>0x07</td>\n<td>7</td>\n<td>窗口扩大因子为7(移位数)</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<h2 id=\"TCP特点\"><a href=\"#TCP特点\" class=\"headerlink\" title=\"TCP特点\"></a>TCP特点</h2><p>TCP全称叫传输控制协议，是传输层两大协议之一。</p>\n<p>TCP是一种面向连接的、可靠的、数据流的协议。连接方式是一对一，类似于打电话，数据交互之前需要连接，然后才可以通信。</p>\n<p>TCP的可靠体现在:</p>\n<ul>\n<li>传输数据之前需要建立连接</li>\n<li>发送应答机制(数据需要确认)</li>\n<li>发送端超时重传(丢包)</li>\n<li>乱序重组(根据序列号)</li>\n<li>校验码校验</li>\n<li>滑动窗口</li>\n<li>拥塞控制</li>\n</ul>","more":"<h2 id=\"TCP首部\"><a href=\"#TCP首部\" class=\"headerlink\" title=\"TCP首部\"></a>TCP首部</h2><p><img src=\"/pic/TCP%E9%A6%96%E9%83%A8.png\" alt=\"TCP首部\"></p>\n<p>1.源端口和目标端口很好理解，传输层就是实现端到端的通信的。<br>简单介绍一下端口号。端口就是用来标识一个网络应用的。范围是0-66635,<br>1-1023是知名端口号，由Internet号分配机构管理。<br>1024-5000是临时端口，大于5000的是为其他服务器预留的</p>\n<p>一些知名端口号:<br><img src=\"/pic/%E7%9F%A5%E5%90%8D%E7%AB%AF%E5%8F%A3%E5%8F%B7.png\" alt=\"知名端口号\"></p>\n<p>2.序号 :《TCP/IP:协议》上是这么解释的，用来标识从TCP发端向TCP收端发送的数据字节流，它标识在这个报文段中的第一个数据字节。用序号对每个字节进行技术，序号到达最大值(2的32次-1)再从0开始。初始序号是随机的。</p>\n<p>简而言之，序号就是对已发数据字节进行计数的。</p>\n<p>3.确认序号 :确认接收端已经收到了发送端前n个字节，请求第n+1个字节开始的数据<br>因此确认序号是上次已成功收到数据字节序号加1</p>\n<p>4.首部长度: 给出首部中32bit字(4字节)的数目，由于不加选项的TCP首部至少是20个字节，因此首部长度最小为5，由于首部长度这个字段占4位，因此TCP首部最多有60个字节。</p>\n<p>5.六个标志位   置1代表触发</p>\n<p>URG  紧急指针有效<br>ACK   确认序号有效<br>PSH   接收方应该尽快将这个报文段交给应用层<br>RST   重建连接<br>SYN  同步序号用来发起一个连接<br>FIN   发端完成发送任务</p>\n<p>6.窗口大小   TCP利用滑动窗口进行流量控制</p>\n<p>7.检验和  强制性字段   用于收端进行验证</p>\n<p>8.紧急指针  是一个正的偏移量(很少用)</p>\n<p>9.选项     </p>\n<ul>\n<li>比较常见的是最长报文大小(MSS) ,在建立连接的第一个报文指定</li>\n<li>窗口扩大选项(3个字节，每个字节表示移位值)</li>\n<li>时间戳选项(10个字节)   时间戳值和时间戳回送回答字段</li>\n</ul>\n<h2 id=\"TCP头部选项\"><a href=\"#TCP头部选项\" class=\"headerlink\" title=\"TCP头部选项\"></a>TCP头部选项</h2><p>选项最多40字节，加上固定头部20字节，TCP头部最多60字节</p>\n<p>TCP头部选项一般结构：</p>\n<p><img src=\"/pic/TCP%E5%A4%B4%E9%83%A8%E9%80%89%E9%A1%B9%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>常见的7种TCP头部选项：</p>\n<p><img src=\"/pic/%E5%B8%B8%E8%A7%81TCP%E5%A4%B4%E9%83%A8%E9%80%89%E9%A1%B9.png\" alt=\"\"></p>\n<ul>\n<li><p>kind = 0 选项表结束选项</p>\n</li>\n<li><p>kind = 1 空操作选项，没什么含义，一般用来将TCP选项总长度填充为4字节整数倍</p>\n</li>\n<li><p>kind = 2 最大报文段长度选项(MSS)，在连接初始化协商，TCP模块通常设置成(MTU-40)字节，去除20字节的TCP头部和20字节的IP头部（假设都不加选项），避免本机IP分片，对以太网而言，MSS一般为1460</p>\n</li>\n<li><p>kind = 3 窗口扩大因子选项。在连接初始化协商。在TCP头部接收通告窗口大小是16位表示，最大是65536字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数(为了提高TCP吞吐量)，窗口扩大因子(移位数，取值范围0-14)，假设接收窗口一开始大小为M，窗口扩大因子是N，实际接收窗口大小为M*2^N。</p>\n<p>可以修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或者关闭窗口扩大因子选项</p>\n<p>注意点：和MSS选项一样，窗口扩大因子只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立之后，每个数据传输方向的窗口扩大因子就固定不变了。(我懵逼了，不懂什么意思)</p>\n</li>\n<li><p>kind = 4 ，选择性确认(SACK)。如果某个TCP报文段丢失，TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先有些已经正确传输但在丢失报文段之后的报文就会被重复发送，从而降低TCP性能。SACK能够改善这种情况，使TCP模块只重新发送丢失的TCP报文段。</p>\n<p>可以修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项</p>\n</li>\n<li><p>kind = 5 ，SACK实际工作的选项。该选项的参数告诉发送方已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。块左边沿表示不连续块的第一个数据序号，块右边沿表示不连续块的最后一个数据序号的下一个序号，这一对参数之间的数据是没有收到的，占用8字节。</p>\n</li>\n<li><p>kind = 8 ,时间戳选项。提供较为精确的计算通信双方之间的回路时间(RTT)的方法，从而为TCP流量控制提供重要信息。</p>\n<p>可以修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项</p>\n</li>\n</ul>\n<h2 id=\"tcpdump抓包观察TCP头部\"><a href=\"#tcpdump抓包观察TCP头部\" class=\"headerlink\" title=\"tcpdump抓包观察TCP头部\"></a>tcpdump抓包观察TCP头部</h2><p><img src=\"/pic/tcp%E6%8A%93%E5%8C%851.png\" alt=\"\"></p>\n<p>抓取到的数据包：</p>\n<p><img src=\"/pic/tcp%E6%8A%93%E5%8C%852.png\" alt=\"\"></p>\n<p>Flags[S]:表示TCP报文段中有SYN标志，是一个同步报文段</p>\n<p>seq:序号值。该同步报文值是从127.0.0.1.34278（客户端）到127.0.0.1.23（服务器）这个传输方向上的第一个TCP报文段，所以这个序号值也是这次通信过程中该传输方向上的ISN值。</p>\n<p>win:接收通告窗口大小。因为这是一个同步报文段，所以反映的是实际接收通告大小</p>\n<p>options：TCP选项。mss是发送端(客户端通告的最大报文段长度)、sackOK表示发送端支持并同意使用SACK选项、TS val是发送端的时间戳、ecr是时间戳回显应答、nop是一个空操作选项、wscale是发送端使用的窗口扩大因子。</p>\n<p>前20字节是IP头部，后40字节是TCP头部</p>\n<p>因此从第21字节开始分析</p>\n<table>\n<thead>\n<tr>\n<th>十六进制数</th>\n<th>十进制表示</th>\n<th>TCP头部信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x85e6</td>\n<td>34278</td>\n<td>源端口号</td>\n</tr>\n<tr>\n<td>0x0017</td>\n<td>23</td>\n<td>目的端口号</td>\n</tr>\n<tr>\n<td>0x599d891d</td>\n<td>1503496477</td>\n<td>序号</td>\n</tr>\n<tr>\n<td>0x00000000</td>\n<td>0</td>\n<td>确认号</td>\n</tr>\n<tr>\n<td>0xa</td>\n<td>10</td>\n<td>头部长度时10*4字节</td>\n</tr>\n<tr>\n<td>0x002</td>\n<td></td>\n<td>设置了SYN标志</td>\n</tr>\n<tr>\n<td>0xaaaa</td>\n<td>43690</td>\n<td>接收通告窗口大小</td>\n</tr>\n<tr>\n<td>0xfe30</td>\n<td></td>\n<td>头部校验和</td>\n</tr>\n<tr>\n<td>0x0000</td>\n<td></td>\n<td>没设置URG标志，所以紧急指针无意义</td>\n</tr>\n<tr>\n<td>0x0204</td>\n<td></td>\n<td>最大报文段长度(MSS)选项的kind值和length值</td>\n</tr>\n<tr>\n<td>0xffd7</td>\n<td>65495</td>\n<td>最大报文段长度</td>\n</tr>\n<tr>\n<td>0x0402</td>\n<td></td>\n<td>允许SACK选项</td>\n</tr>\n<tr>\n<td>0x080a</td>\n<td></td>\n<td>时间戳选项的kind值和length值</td>\n</tr>\n<tr>\n<td>0x001cdf6d</td>\n<td>1892205</td>\n<td>时间戳</td>\n</tr>\n<tr>\n<td>0x00000000</td>\n<td>0</td>\n<td>时间戳回显应答</td>\n</tr>\n<tr>\n<td>0x01</td>\n<td></td>\n<td>空操作选项(nop)</td>\n</tr>\n<tr>\n<td>0x0303</td>\n<td></td>\n<td>窗口扩大因子选项的kind值和length值</td>\n</tr>\n<tr>\n<td>0x07</td>\n<td>7</td>\n<td>窗口扩大因子为7(移位数)</td>\n</tr>\n</tbody></table>"},{"title":"STL容器性能测试","date":"2019-04-28T11:15:35.000Z","_content":"\n之前说到STL有六大部件，这里着重介绍一下容器部分。\n\n容器就是用来装数据的，难的地方就是需要根据数据的特征以及考虑要对数据进行的操作选择合适的容器，同时还要考虑容器的内存分布。\n\n#### STL容器总览图\n\n![](/pic/STL容器.png)\n\n其中主要分为顺序式和关联式。关联式的查找速度更快\n\narray、vector、deque底层数据结构都是数组\n\nlist、forward_list底层数据结构是链表\n\nset、multiset、map、multimap底层数据结构是红黑树\n\n其中set、map键值不允许重复，multiset、multimap允许重复\n\nunordered_set、unordered_multiset、unordered_map、unordered_multimap、\n\nhash_set、hash_multiset、hash_multimap、hash_map底层数据结构是hash表\n\n还有图中没写出来的stack、queue、priority_queue都是线性结构\n\n[STL容器详细文档](https://github.com/huihut/interview/blob/master/STL/STL.md)\n\n小技巧：在编写测试程序的时候，让每个单元在独立的命名空间里面\n\n<!--more-->\n\n## 顺序式容器\n\n#### array\n\n这是C++11新添加的容器，封装了最常用的数组\n\n[array测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/array_test.h)\n\n#### vector\n\n[vector测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/vector_test.h)\n\nvector只有push_back操作，而没有push_front操作，是因为push_front的话之后的元素都要后移，很耗费时间。在插入操作的时候不够的话自动扩展，二倍扩展，将原有数据拷贝到新的空间，然后释放旧空间。\n\n通过测试，发现STL算法中的find算法相比较于 先排序(快排)再二分查找  前者查找的速度快很多。\n\n#### list\n\n[list测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/list_test.h)\n\n双向链表，头尾都可以添加和删除\n\n#### forward_list\n\n[forward_list测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/forward_list_test.h)\n\n单向链表，这也是C++11新添加的容器，只能头添加和头删除，因为如果没有指针标记链表尾部的话，从末尾添加元素每次都需要遍历到末尾，效率很低。\n\n#### deque\n\n[deque测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/deque_test.h)\n\n双端队列,内存不是真正意味上的连续，每一段之间是连续的,头尾都能添加和删除\n\n![](/pic/deque结构.png)\n\n#### stack\n\n栈(先进后出) ，push和pop操作\n\n[stack测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/stack_test.h)\n\n#### queue\n\n队列(先进先出)，push和pop操作\n\n[queue测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/queue_test.h)\n\n需要注意的是:\n\n![](/pic/stack结构.png)\n\n由上图可见，deque也能够完成stack的功能\n\n![](/pic/queue结构.png)\n\n由上图可见，deque也能够完成queue的功能\n\n实际上，stack和queue的源代码内部拥有一个deque。也就是stack和queue本身没有去实现数据结构，而是用deque作为支撑。因此，stack和queue也能叫做容器的适配器。\n\n## 关联式容器(适合查找)\n\n### key值可以重复\n\n#### multiset\n\n[multiset测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/multiset_test.h)\n\n注意包含的是set头文件，插入元素用insert方法\n\n使用全局的find()和容器自带的find()函数进行查找效率的比较，发现容器自带的find速度更大。\n\n#### multimap\n\n[multimap测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/multimap_test.h)\n\n注意包含的是map头文件，插入元素用insert方法,用pair<>构建插入的键值对\n\n#### unordered_multiset\n\nC++11新加入的容器\n\n[unordered_multiset测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/ordered_multiset_test.h)\n\n注意包含的是unordered_set头文件，插入元素用insert方法\n\n使用全局的find()和容器自带的find()函数进行查找效率的比较，发现容器自带的find速度更大。\n\n#### unordered_multimap\n\nC++11新加入的容器\n\n[unordered_multimap测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/ordered_multimap_test.h)\n\n注意包含的是unordered_map头文件，插入元素用insert方法,用pair<>构建插入的键值对\n\n### key值不能重复\n\n#### set\n\n和上面的multiset和unordered_multiset的区别在于，key值唯一不能有重复\n\n[set测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/set_test.h)\n\n#### map\n\n和上面的multimap和unordered_multimap的区别在于，key值唯一不能有重复\n\n插入元素可以用[]和insert,而multimap只能用insert\n\n[map测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/map_test.h)\n\n#### unordered_set\n\nC++11新加入的容器\n\n[unordered_set测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/unordered_set.h)\n\n和上面的multiset和unordered_multiset的区别在于，key值唯一不能有重复\n\n#### unordered_map\n\nC++11新加入的容器\n\n和上面的multimap和unordered_multimap的区别在于，key值唯一不能有重复\n\n插入元素可以用[]和insert\n\n[unordered_map测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/unordered_map.h)\n\n注意点：各种类型的map都不支持全局的find函数\n\nGNU C的标准库带的hash_set、hash_map、hash_multiset、hash_multimap就是现在C++11中以unordered开头的容器，因此就不再进行测试了。\n\nGNU C 也有一个非标准库的单向链表类slist","source":"_posts/STL容器性能测试.md","raw":"---\ntitle: STL容器性能测试\ndate: 2019-04-28 19:15:35\ntags:\n- C++\n- STL\n---\n\n之前说到STL有六大部件，这里着重介绍一下容器部分。\n\n容器就是用来装数据的，难的地方就是需要根据数据的特征以及考虑要对数据进行的操作选择合适的容器，同时还要考虑容器的内存分布。\n\n#### STL容器总览图\n\n![](/pic/STL容器.png)\n\n其中主要分为顺序式和关联式。关联式的查找速度更快\n\narray、vector、deque底层数据结构都是数组\n\nlist、forward_list底层数据结构是链表\n\nset、multiset、map、multimap底层数据结构是红黑树\n\n其中set、map键值不允许重复，multiset、multimap允许重复\n\nunordered_set、unordered_multiset、unordered_map、unordered_multimap、\n\nhash_set、hash_multiset、hash_multimap、hash_map底层数据结构是hash表\n\n还有图中没写出来的stack、queue、priority_queue都是线性结构\n\n[STL容器详细文档](https://github.com/huihut/interview/blob/master/STL/STL.md)\n\n小技巧：在编写测试程序的时候，让每个单元在独立的命名空间里面\n\n<!--more-->\n\n## 顺序式容器\n\n#### array\n\n这是C++11新添加的容器，封装了最常用的数组\n\n[array测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/array_test.h)\n\n#### vector\n\n[vector测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/vector_test.h)\n\nvector只有push_back操作，而没有push_front操作，是因为push_front的话之后的元素都要后移，很耗费时间。在插入操作的时候不够的话自动扩展，二倍扩展，将原有数据拷贝到新的空间，然后释放旧空间。\n\n通过测试，发现STL算法中的find算法相比较于 先排序(快排)再二分查找  前者查找的速度快很多。\n\n#### list\n\n[list测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/list_test.h)\n\n双向链表，头尾都可以添加和删除\n\n#### forward_list\n\n[forward_list测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/forward_list_test.h)\n\n单向链表，这也是C++11新添加的容器，只能头添加和头删除，因为如果没有指针标记链表尾部的话，从末尾添加元素每次都需要遍历到末尾，效率很低。\n\n#### deque\n\n[deque测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/deque_test.h)\n\n双端队列,内存不是真正意味上的连续，每一段之间是连续的,头尾都能添加和删除\n\n![](/pic/deque结构.png)\n\n#### stack\n\n栈(先进后出) ，push和pop操作\n\n[stack测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/stack_test.h)\n\n#### queue\n\n队列(先进先出)，push和pop操作\n\n[queue测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/queue_test.h)\n\n需要注意的是:\n\n![](/pic/stack结构.png)\n\n由上图可见，deque也能够完成stack的功能\n\n![](/pic/queue结构.png)\n\n由上图可见，deque也能够完成queue的功能\n\n实际上，stack和queue的源代码内部拥有一个deque。也就是stack和queue本身没有去实现数据结构，而是用deque作为支撑。因此，stack和queue也能叫做容器的适配器。\n\n## 关联式容器(适合查找)\n\n### key值可以重复\n\n#### multiset\n\n[multiset测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/multiset_test.h)\n\n注意包含的是set头文件，插入元素用insert方法\n\n使用全局的find()和容器自带的find()函数进行查找效率的比较，发现容器自带的find速度更大。\n\n#### multimap\n\n[multimap测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/multimap_test.h)\n\n注意包含的是map头文件，插入元素用insert方法,用pair<>构建插入的键值对\n\n#### unordered_multiset\n\nC++11新加入的容器\n\n[unordered_multiset测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/ordered_multiset_test.h)\n\n注意包含的是unordered_set头文件，插入元素用insert方法\n\n使用全局的find()和容器自带的find()函数进行查找效率的比较，发现容器自带的find速度更大。\n\n#### unordered_multimap\n\nC++11新加入的容器\n\n[unordered_multimap测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/ordered_multimap_test.h)\n\n注意包含的是unordered_map头文件，插入元素用insert方法,用pair<>构建插入的键值对\n\n### key值不能重复\n\n#### set\n\n和上面的multiset和unordered_multiset的区别在于，key值唯一不能有重复\n\n[set测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/set_test.h)\n\n#### map\n\n和上面的multimap和unordered_multimap的区别在于，key值唯一不能有重复\n\n插入元素可以用[]和insert,而multimap只能用insert\n\n[map测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/map_test.h)\n\n#### unordered_set\n\nC++11新加入的容器\n\n[unordered_set测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/unordered_set.h)\n\n和上面的multiset和unordered_multiset的区别在于，key值唯一不能有重复\n\n#### unordered_map\n\nC++11新加入的容器\n\n和上面的multimap和unordered_multimap的区别在于，key值唯一不能有重复\n\n插入元素可以用[]和insert\n\n[unordered_map测试代码](https://github.com/oldbuffalo/DayDayUp/blob/master/STL/unordered_map.h)\n\n注意点：各种类型的map都不支持全局的find函数\n\nGNU C的标准库带的hash_set、hash_map、hash_multiset、hash_multimap就是现在C++11中以unordered开头的容器，因此就不再进行测试了。\n\nGNU C 也有一个非标准库的单向链表类slist","slug":"STL容器性能测试","published":1,"updated":"2021-12-06T05:30:36.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7c000e96ca5pibd4dt","content":"<p>之前说到STL有六大部件，这里着重介绍一下容器部分。</p>\n<p>容器就是用来装数据的，难的地方就是需要根据数据的特征以及考虑要对数据进行的操作选择合适的容器，同时还要考虑容器的内存分布。</p>\n<h4 id=\"STL容器总览图\"><a href=\"#STL容器总览图\" class=\"headerlink\" title=\"STL容器总览图\"></a>STL容器总览图</h4><p><img src=\"/pic/STL%E5%AE%B9%E5%99%A8.png\" alt=\"\"></p>\n<p>其中主要分为顺序式和关联式。关联式的查找速度更快</p>\n<p>array、vector、deque底层数据结构都是数组</p>\n<p>list、forward_list底层数据结构是链表</p>\n<p>set、multiset、map、multimap底层数据结构是红黑树</p>\n<p>其中set、map键值不允许重复，multiset、multimap允许重复</p>\n<p>unordered_set、unordered_multiset、unordered_map、unordered_multimap、</p>\n<p>hash_set、hash_multiset、hash_multimap、hash_map底层数据结构是hash表</p>\n<p>还有图中没写出来的stack、queue、priority_queue都是线性结构</p>\n<p><a href=\"https://github.com/huihut/interview/blob/master/STL/STL.md\" target=\"_blank\" rel=\"noopener\">STL容器详细文档</a></p>\n<p>小技巧：在编写测试程序的时候，让每个单元在独立的命名空间里面</p>\n<a id=\"more\"></a>\n\n<h2 id=\"顺序式容器\"><a href=\"#顺序式容器\" class=\"headerlink\" title=\"顺序式容器\"></a>顺序式容器</h2><h4 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h4><p>这是C++11新添加的容器，封装了最常用的数组</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/array_test.h\" target=\"_blank\" rel=\"noopener\">array测试代码</a></p>\n<h4 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/vector_test.h\" target=\"_blank\" rel=\"noopener\">vector测试代码</a></p>\n<p>vector只有push_back操作，而没有push_front操作，是因为push_front的话之后的元素都要后移，很耗费时间。在插入操作的时候不够的话自动扩展，二倍扩展，将原有数据拷贝到新的空间，然后释放旧空间。</p>\n<p>通过测试，发现STL算法中的find算法相比较于 先排序(快排)再二分查找  前者查找的速度快很多。</p>\n<h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/list_test.h\" target=\"_blank\" rel=\"noopener\">list测试代码</a></p>\n<p>双向链表，头尾都可以添加和删除</p>\n<h4 id=\"forward-list\"><a href=\"#forward-list\" class=\"headerlink\" title=\"forward_list\"></a>forward_list</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/forward_list_test.h\" target=\"_blank\" rel=\"noopener\">forward_list测试代码</a></p>\n<p>单向链表，这也是C++11新添加的容器，只能头添加和头删除，因为如果没有指针标记链表尾部的话，从末尾添加元素每次都需要遍历到末尾，效率很低。</p>\n<h4 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/deque_test.h\" target=\"_blank\" rel=\"noopener\">deque测试代码</a></p>\n<p>双端队列,内存不是真正意味上的连续，每一段之间是连续的,头尾都能添加和删除</p>\n<p><img src=\"/pic/deque%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<h4 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h4><p>栈(先进后出) ，push和pop操作</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/stack_test.h\" target=\"_blank\" rel=\"noopener\">stack测试代码</a></p>\n<h4 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h4><p>队列(先进先出)，push和pop操作</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/queue_test.h\" target=\"_blank\" rel=\"noopener\">queue测试代码</a></p>\n<p>需要注意的是:</p>\n<p><img src=\"/pic/stack%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>由上图可见，deque也能够完成stack的功能</p>\n<p><img src=\"/pic/queue%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>由上图可见，deque也能够完成queue的功能</p>\n<p>实际上，stack和queue的源代码内部拥有一个deque。也就是stack和queue本身没有去实现数据结构，而是用deque作为支撑。因此，stack和queue也能叫做容器的适配器。</p>\n<h2 id=\"关联式容器-适合查找\"><a href=\"#关联式容器-适合查找\" class=\"headerlink\" title=\"关联式容器(适合查找)\"></a>关联式容器(适合查找)</h2><h3 id=\"key值可以重复\"><a href=\"#key值可以重复\" class=\"headerlink\" title=\"key值可以重复\"></a>key值可以重复</h3><h4 id=\"multiset\"><a href=\"#multiset\" class=\"headerlink\" title=\"multiset\"></a>multiset</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/multiset_test.h\" target=\"_blank\" rel=\"noopener\">multiset测试代码</a></p>\n<p>注意包含的是set头文件，插入元素用insert方法</p>\n<p>使用全局的find()和容器自带的find()函数进行查找效率的比较，发现容器自带的find速度更大。</p>\n<h4 id=\"multimap\"><a href=\"#multimap\" class=\"headerlink\" title=\"multimap\"></a>multimap</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/multimap_test.h\" target=\"_blank\" rel=\"noopener\">multimap测试代码</a></p>\n<p>注意包含的是map头文件，插入元素用insert方法,用pair&lt;&gt;构建插入的键值对</p>\n<h4 id=\"unordered-multiset\"><a href=\"#unordered-multiset\" class=\"headerlink\" title=\"unordered_multiset\"></a>unordered_multiset</h4><p>C++11新加入的容器</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/ordered_multiset_test.h\" target=\"_blank\" rel=\"noopener\">unordered_multiset测试代码</a></p>\n<p>注意包含的是unordered_set头文件，插入元素用insert方法</p>\n<p>使用全局的find()和容器自带的find()函数进行查找效率的比较，发现容器自带的find速度更大。</p>\n<h4 id=\"unordered-multimap\"><a href=\"#unordered-multimap\" class=\"headerlink\" title=\"unordered_multimap\"></a>unordered_multimap</h4><p>C++11新加入的容器</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/ordered_multimap_test.h\" target=\"_blank\" rel=\"noopener\">unordered_multimap测试代码</a></p>\n<p>注意包含的是unordered_map头文件，插入元素用insert方法,用pair&lt;&gt;构建插入的键值对</p>\n<h3 id=\"key值不能重复\"><a href=\"#key值不能重复\" class=\"headerlink\" title=\"key值不能重复\"></a>key值不能重复</h3><h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>和上面的multiset和unordered_multiset的区别在于，key值唯一不能有重复</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/set_test.h\" target=\"_blank\" rel=\"noopener\">set测试代码</a></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>和上面的multimap和unordered_multimap的区别在于，key值唯一不能有重复</p>\n<p>插入元素可以用[]和insert,而multimap只能用insert</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/map_test.h\" target=\"_blank\" rel=\"noopener\">map测试代码</a></p>\n<h4 id=\"unordered-set\"><a href=\"#unordered-set\" class=\"headerlink\" title=\"unordered_set\"></a>unordered_set</h4><p>C++11新加入的容器</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/unordered_set.h\" target=\"_blank\" rel=\"noopener\">unordered_set测试代码</a></p>\n<p>和上面的multiset和unordered_multiset的区别在于，key值唯一不能有重复</p>\n<h4 id=\"unordered-map\"><a href=\"#unordered-map\" class=\"headerlink\" title=\"unordered_map\"></a>unordered_map</h4><p>C++11新加入的容器</p>\n<p>和上面的multimap和unordered_multimap的区别在于，key值唯一不能有重复</p>\n<p>插入元素可以用[]和insert</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/unordered_map.h\" target=\"_blank\" rel=\"noopener\">unordered_map测试代码</a></p>\n<p>注意点：各种类型的map都不支持全局的find函数</p>\n<p>GNU C的标准库带的hash_set、hash_map、hash_multiset、hash_multimap就是现在C++11中以unordered开头的容器，因此就不再进行测试了。</p>\n<p>GNU C 也有一个非标准库的单向链表类slist</p>\n","site":{"data":{}},"excerpt":"<p>之前说到STL有六大部件，这里着重介绍一下容器部分。</p>\n<p>容器就是用来装数据的，难的地方就是需要根据数据的特征以及考虑要对数据进行的操作选择合适的容器，同时还要考虑容器的内存分布。</p>\n<h4 id=\"STL容器总览图\"><a href=\"#STL容器总览图\" class=\"headerlink\" title=\"STL容器总览图\"></a>STL容器总览图</h4><p><img src=\"/pic/STL%E5%AE%B9%E5%99%A8.png\" alt=\"\"></p>\n<p>其中主要分为顺序式和关联式。关联式的查找速度更快</p>\n<p>array、vector、deque底层数据结构都是数组</p>\n<p>list、forward_list底层数据结构是链表</p>\n<p>set、multiset、map、multimap底层数据结构是红黑树</p>\n<p>其中set、map键值不允许重复，multiset、multimap允许重复</p>\n<p>unordered_set、unordered_multiset、unordered_map、unordered_multimap、</p>\n<p>hash_set、hash_multiset、hash_multimap、hash_map底层数据结构是hash表</p>\n<p>还有图中没写出来的stack、queue、priority_queue都是线性结构</p>\n<p><a href=\"https://github.com/huihut/interview/blob/master/STL/STL.md\" target=\"_blank\" rel=\"noopener\">STL容器详细文档</a></p>\n<p>小技巧：在编写测试程序的时候，让每个单元在独立的命名空间里面</p>","more":"<h2 id=\"顺序式容器\"><a href=\"#顺序式容器\" class=\"headerlink\" title=\"顺序式容器\"></a>顺序式容器</h2><h4 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h4><p>这是C++11新添加的容器，封装了最常用的数组</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/array_test.h\" target=\"_blank\" rel=\"noopener\">array测试代码</a></p>\n<h4 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/vector_test.h\" target=\"_blank\" rel=\"noopener\">vector测试代码</a></p>\n<p>vector只有push_back操作，而没有push_front操作，是因为push_front的话之后的元素都要后移，很耗费时间。在插入操作的时候不够的话自动扩展，二倍扩展，将原有数据拷贝到新的空间，然后释放旧空间。</p>\n<p>通过测试，发现STL算法中的find算法相比较于 先排序(快排)再二分查找  前者查找的速度快很多。</p>\n<h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/list_test.h\" target=\"_blank\" rel=\"noopener\">list测试代码</a></p>\n<p>双向链表，头尾都可以添加和删除</p>\n<h4 id=\"forward-list\"><a href=\"#forward-list\" class=\"headerlink\" title=\"forward_list\"></a>forward_list</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/forward_list_test.h\" target=\"_blank\" rel=\"noopener\">forward_list测试代码</a></p>\n<p>单向链表，这也是C++11新添加的容器，只能头添加和头删除，因为如果没有指针标记链表尾部的话，从末尾添加元素每次都需要遍历到末尾，效率很低。</p>\n<h4 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/deque_test.h\" target=\"_blank\" rel=\"noopener\">deque测试代码</a></p>\n<p>双端队列,内存不是真正意味上的连续，每一段之间是连续的,头尾都能添加和删除</p>\n<p><img src=\"/pic/deque%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<h4 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h4><p>栈(先进后出) ，push和pop操作</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/stack_test.h\" target=\"_blank\" rel=\"noopener\">stack测试代码</a></p>\n<h4 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h4><p>队列(先进先出)，push和pop操作</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/queue_test.h\" target=\"_blank\" rel=\"noopener\">queue测试代码</a></p>\n<p>需要注意的是:</p>\n<p><img src=\"/pic/stack%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>由上图可见，deque也能够完成stack的功能</p>\n<p><img src=\"/pic/queue%E7%BB%93%E6%9E%84.png\" alt=\"\"></p>\n<p>由上图可见，deque也能够完成queue的功能</p>\n<p>实际上，stack和queue的源代码内部拥有一个deque。也就是stack和queue本身没有去实现数据结构，而是用deque作为支撑。因此，stack和queue也能叫做容器的适配器。</p>\n<h2 id=\"关联式容器-适合查找\"><a href=\"#关联式容器-适合查找\" class=\"headerlink\" title=\"关联式容器(适合查找)\"></a>关联式容器(适合查找)</h2><h3 id=\"key值可以重复\"><a href=\"#key值可以重复\" class=\"headerlink\" title=\"key值可以重复\"></a>key值可以重复</h3><h4 id=\"multiset\"><a href=\"#multiset\" class=\"headerlink\" title=\"multiset\"></a>multiset</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/multiset_test.h\" target=\"_blank\" rel=\"noopener\">multiset测试代码</a></p>\n<p>注意包含的是set头文件，插入元素用insert方法</p>\n<p>使用全局的find()和容器自带的find()函数进行查找效率的比较，发现容器自带的find速度更大。</p>\n<h4 id=\"multimap\"><a href=\"#multimap\" class=\"headerlink\" title=\"multimap\"></a>multimap</h4><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/multimap_test.h\" target=\"_blank\" rel=\"noopener\">multimap测试代码</a></p>\n<p>注意包含的是map头文件，插入元素用insert方法,用pair&lt;&gt;构建插入的键值对</p>\n<h4 id=\"unordered-multiset\"><a href=\"#unordered-multiset\" class=\"headerlink\" title=\"unordered_multiset\"></a>unordered_multiset</h4><p>C++11新加入的容器</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/ordered_multiset_test.h\" target=\"_blank\" rel=\"noopener\">unordered_multiset测试代码</a></p>\n<p>注意包含的是unordered_set头文件，插入元素用insert方法</p>\n<p>使用全局的find()和容器自带的find()函数进行查找效率的比较，发现容器自带的find速度更大。</p>\n<h4 id=\"unordered-multimap\"><a href=\"#unordered-multimap\" class=\"headerlink\" title=\"unordered_multimap\"></a>unordered_multimap</h4><p>C++11新加入的容器</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/ordered_multimap_test.h\" target=\"_blank\" rel=\"noopener\">unordered_multimap测试代码</a></p>\n<p>注意包含的是unordered_map头文件，插入元素用insert方法,用pair&lt;&gt;构建插入的键值对</p>\n<h3 id=\"key值不能重复\"><a href=\"#key值不能重复\" class=\"headerlink\" title=\"key值不能重复\"></a>key值不能重复</h3><h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>和上面的multiset和unordered_multiset的区别在于，key值唯一不能有重复</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/set_test.h\" target=\"_blank\" rel=\"noopener\">set测试代码</a></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>和上面的multimap和unordered_multimap的区别在于，key值唯一不能有重复</p>\n<p>插入元素可以用[]和insert,而multimap只能用insert</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/map_test.h\" target=\"_blank\" rel=\"noopener\">map测试代码</a></p>\n<h4 id=\"unordered-set\"><a href=\"#unordered-set\" class=\"headerlink\" title=\"unordered_set\"></a>unordered_set</h4><p>C++11新加入的容器</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/unordered_set.h\" target=\"_blank\" rel=\"noopener\">unordered_set测试代码</a></p>\n<p>和上面的multiset和unordered_multiset的区别在于，key值唯一不能有重复</p>\n<h4 id=\"unordered-map\"><a href=\"#unordered-map\" class=\"headerlink\" title=\"unordered_map\"></a>unordered_map</h4><p>C++11新加入的容器</p>\n<p>和上面的multimap和unordered_multimap的区别在于，key值唯一不能有重复</p>\n<p>插入元素可以用[]和insert</p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/STL/unordered_map.h\" target=\"_blank\" rel=\"noopener\">unordered_map测试代码</a></p>\n<p>注意点：各种类型的map都不支持全局的find函数</p>\n<p>GNU C的标准库带的hash_set、hash_map、hash_multiset、hash_multimap就是现在C++11中以unordered开头的容器，因此就不再进行测试了。</p>\n<p>GNU C 也有一个非标准库的单向链表类slist</p>"},{"title":"TCP数据传输","date":"2019-03-10T08:10:33.000Z","_content":"\n## TCP交互数据流\n\n交互数据仅包含很少的字节，使用交互数据的应用程序(或协议)对实时性要求高，比如telnet、ssh等\n\n#### 延迟确认\n\n延迟确认：每次需要发送的确认报文段不马上发送，而是在一段延迟时间后查看本端是否有数据需要发送，如果有，就和确认信息一起发出。延迟确认可以减少发送TCP报文段的数量，提高通信效率。\n\n一般服务器对客户请求处理得很快，所以它发送确认报文段的时候总有数据一起发送，常用延迟确认。而客户端用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文一般不携带任何应用程序数据。\n\n在TCP四次挥手的时候，也有可能发生延迟确认。（确认客户端FIN包的ACK包可以和应用数据一起发送）\n\n#### Nagle算法\n\n在广域网中，交互数据流可能经受很大的延迟，并且，如果携带交互数据流的微小TCP报文段数量很多的时候(一个按键就导致一个TCP报文段)，可能导致拥塞发生，影响网络性能。\n\n解决方案是:Nagle算法\n\nNagle算法要求当一个TCP连接中有在传数据(即那些已发送但还未经确认的数据)，小的报文段(长度小于SMSS)就不能发送，直到所有的在传数据都收到ACK。并且，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。迫使TCP遵循停等规程。这样就极大地减少了网络上的微小TCP报文段的数量，另一个优点是自适应性：确认到达得越快，数据也就发送得越快。\n\n## TCP成块数据流\n\n成块数据的长度通常为TCP报文段允许的最大数据长度，使用成块数据的应用程序（或协议）对传输效率要求高，比如ftp。\n\n当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。\n\n发送方在收到上一次确认后，能连续发送多少个TCP报文段取决于接收通告窗口大小和拥塞窗口大小。\n\n可以修改TCP接收缓冲区和发送缓冲区的大小。\n\n## 带外数据\n\n用来迅速通告对方本端发生的重要事件，因此带外数据比普通数据有更高的优先级，应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。\n\n带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接上。\n\nUDP没实现带外数据传输，TCP也没真正的带外数据，但是TCP可以利用头部中的紧急指针标志和紧急指针两个字段，给应用程序提供一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。\n\n![](/pic/TCP带外数据.png)\n\n假设一个进程已经往某个TCP连接的发送缓冲区中写入了N个字节的普通数据，并等待其发送。在数据被发送之前，该进程又向这个连接写入了3字节的带外数据\"abc\"，此时，待发送的TCP报文段的头部被设置URG标志，且紧急指针被设置成指向最后一个带外数据的下一字节。\n\n发送端一次发送的多字节带外数据中只有最后一字节被当作带外数据(c)，而其他数据(a、b)被当成普通数据。如果TCP以多个TCP报文段来发送上图所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置自URG标志，并且它们的紧急指针指向同一位置，但只有一个TCP报文段真正携带带外数据。\n\nTCP接收带外数据，接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指位置确定带外数据位置，并将它读入一个特殊的缓存，这个缓存只有1字节，称为带外缓存。如果上层应用没有及时将带外数据从带外缓存中读出，后续的带外数据将覆盖它。\n\n上面的接收方式是TCP默认的接收方式，如果给TCP连接设置SO_OOBINLINE，那么带外数据将和普通数据一样被TCP模块存放在TCP接收缓冲区内。那么这样如何区分带外数据和普通数据? 1.紧急指针可以用来指出带外数据的位置2.socket编程接口提供了识别带外数据的系统调用\n\n## 数据传输超时重传\n\n区别于三次握手的时候的超时重连策略\n\nTCP超时重传策略：如果某个数据报在规定时间内没收到确认包，接下来一共执行5次重传，间隔分别是0.2s、0.4s、0.8s、1.6s、3.2s。\n\nLinux中有两个重要的内核参数与TCP超时重传有关。 \n\n/proc/sys/net/ipv4/tcp_retries1 :  指定底层IP接管之前TCP最少执行的重传次数，默认值是3\n\n/proc/sys/net/ipv4/tcp_retries2 : 指定连接放弃前TCP最多可以执行的重传次数，默认值是15(一般对应13~30min)\n\n","source":"_posts/TCP数据传输.md","raw":"---\ntitle: TCP数据传输\ndate: 2019-03-10 16:10:33\ntags:\n- TCP\n- 网络\n- Linux高性能服务器编程\n---\n\n## TCP交互数据流\n\n交互数据仅包含很少的字节，使用交互数据的应用程序(或协议)对实时性要求高，比如telnet、ssh等\n\n#### 延迟确认\n\n延迟确认：每次需要发送的确认报文段不马上发送，而是在一段延迟时间后查看本端是否有数据需要发送，如果有，就和确认信息一起发出。延迟确认可以减少发送TCP报文段的数量，提高通信效率。\n\n一般服务器对客户请求处理得很快，所以它发送确认报文段的时候总有数据一起发送，常用延迟确认。而客户端用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文一般不携带任何应用程序数据。\n\n在TCP四次挥手的时候，也有可能发生延迟确认。（确认客户端FIN包的ACK包可以和应用数据一起发送）\n\n#### Nagle算法\n\n在广域网中，交互数据流可能经受很大的延迟，并且，如果携带交互数据流的微小TCP报文段数量很多的时候(一个按键就导致一个TCP报文段)，可能导致拥塞发生，影响网络性能。\n\n解决方案是:Nagle算法\n\nNagle算法要求当一个TCP连接中有在传数据(即那些已发送但还未经确认的数据)，小的报文段(长度小于SMSS)就不能发送，直到所有的在传数据都收到ACK。并且，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。迫使TCP遵循停等规程。这样就极大地减少了网络上的微小TCP报文段的数量，另一个优点是自适应性：确认到达得越快，数据也就发送得越快。\n\n## TCP成块数据流\n\n成块数据的长度通常为TCP报文段允许的最大数据长度，使用成块数据的应用程序（或协议）对传输效率要求高，比如ftp。\n\n当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。\n\n发送方在收到上一次确认后，能连续发送多少个TCP报文段取决于接收通告窗口大小和拥塞窗口大小。\n\n可以修改TCP接收缓冲区和发送缓冲区的大小。\n\n## 带外数据\n\n用来迅速通告对方本端发生的重要事件，因此带外数据比普通数据有更高的优先级，应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。\n\n带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接上。\n\nUDP没实现带外数据传输，TCP也没真正的带外数据，但是TCP可以利用头部中的紧急指针标志和紧急指针两个字段，给应用程序提供一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。\n\n![](/pic/TCP带外数据.png)\n\n假设一个进程已经往某个TCP连接的发送缓冲区中写入了N个字节的普通数据，并等待其发送。在数据被发送之前，该进程又向这个连接写入了3字节的带外数据\"abc\"，此时，待发送的TCP报文段的头部被设置URG标志，且紧急指针被设置成指向最后一个带外数据的下一字节。\n\n发送端一次发送的多字节带外数据中只有最后一字节被当作带外数据(c)，而其他数据(a、b)被当成普通数据。如果TCP以多个TCP报文段来发送上图所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置自URG标志，并且它们的紧急指针指向同一位置，但只有一个TCP报文段真正携带带外数据。\n\nTCP接收带外数据，接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指位置确定带外数据位置，并将它读入一个特殊的缓存，这个缓存只有1字节，称为带外缓存。如果上层应用没有及时将带外数据从带外缓存中读出，后续的带外数据将覆盖它。\n\n上面的接收方式是TCP默认的接收方式，如果给TCP连接设置SO_OOBINLINE，那么带外数据将和普通数据一样被TCP模块存放在TCP接收缓冲区内。那么这样如何区分带外数据和普通数据? 1.紧急指针可以用来指出带外数据的位置2.socket编程接口提供了识别带外数据的系统调用\n\n## 数据传输超时重传\n\n区别于三次握手的时候的超时重连策略\n\nTCP超时重传策略：如果某个数据报在规定时间内没收到确认包，接下来一共执行5次重传，间隔分别是0.2s、0.4s、0.8s、1.6s、3.2s。\n\nLinux中有两个重要的内核参数与TCP超时重传有关。 \n\n/proc/sys/net/ipv4/tcp_retries1 :  指定底层IP接管之前TCP最少执行的重传次数，默认值是3\n\n/proc/sys/net/ipv4/tcp_retries2 : 指定连接放弃前TCP最多可以执行的重传次数，默认值是15(一般对应13~30min)\n\n","slug":"TCP数据传输","published":1,"updated":"2021-12-06T05:30:36.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7e000h96ca8ei29jd6","content":"<h2 id=\"TCP交互数据流\"><a href=\"#TCP交互数据流\" class=\"headerlink\" title=\"TCP交互数据流\"></a>TCP交互数据流</h2><p>交互数据仅包含很少的字节，使用交互数据的应用程序(或协议)对实时性要求高，比如telnet、ssh等</p>\n<h4 id=\"延迟确认\"><a href=\"#延迟确认\" class=\"headerlink\" title=\"延迟确认\"></a>延迟确认</h4><p>延迟确认：每次需要发送的确认报文段不马上发送，而是在一段延迟时间后查看本端是否有数据需要发送，如果有，就和确认信息一起发出。延迟确认可以减少发送TCP报文段的数量，提高通信效率。</p>\n<p>一般服务器对客户请求处理得很快，所以它发送确认报文段的时候总有数据一起发送，常用延迟确认。而客户端用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文一般不携带任何应用程序数据。</p>\n<p>在TCP四次挥手的时候，也有可能发生延迟确认。（确认客户端FIN包的ACK包可以和应用数据一起发送）</p>\n<h4 id=\"Nagle算法\"><a href=\"#Nagle算法\" class=\"headerlink\" title=\"Nagle算法\"></a>Nagle算法</h4><p>在广域网中，交互数据流可能经受很大的延迟，并且，如果携带交互数据流的微小TCP报文段数量很多的时候(一个按键就导致一个TCP报文段)，可能导致拥塞发生，影响网络性能。</p>\n<p>解决方案是:Nagle算法</p>\n<p>Nagle算法要求当一个TCP连接中有在传数据(即那些已发送但还未经确认的数据)，小的报文段(长度小于SMSS)就不能发送，直到所有的在传数据都收到ACK。并且，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。迫使TCP遵循停等规程。这样就极大地减少了网络上的微小TCP报文段的数量，另一个优点是自适应性：确认到达得越快，数据也就发送得越快。</p>\n<h2 id=\"TCP成块数据流\"><a href=\"#TCP成块数据流\" class=\"headerlink\" title=\"TCP成块数据流\"></a>TCP成块数据流</h2><p>成块数据的长度通常为TCP报文段允许的最大数据长度，使用成块数据的应用程序（或协议）对传输效率要求高，比如ftp。</p>\n<p>当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。</p>\n<p>发送方在收到上一次确认后，能连续发送多少个TCP报文段取决于接收通告窗口大小和拥塞窗口大小。</p>\n<p>可以修改TCP接收缓冲区和发送缓冲区的大小。</p>\n<h2 id=\"带外数据\"><a href=\"#带外数据\" class=\"headerlink\" title=\"带外数据\"></a>带外数据</h2><p>用来迅速通告对方本端发生的重要事件，因此带外数据比普通数据有更高的优先级，应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。</p>\n<p>带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接上。</p>\n<p>UDP没实现带外数据传输，TCP也没真正的带外数据，但是TCP可以利用头部中的紧急指针标志和紧急指针两个字段，给应用程序提供一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。</p>\n<p><img src=\"/pic/TCP%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE.png\" alt=\"\"></p>\n<p>假设一个进程已经往某个TCP连接的发送缓冲区中写入了N个字节的普通数据，并等待其发送。在数据被发送之前，该进程又向这个连接写入了3字节的带外数据”abc”，此时，待发送的TCP报文段的头部被设置URG标志，且紧急指针被设置成指向最后一个带外数据的下一字节。</p>\n<p>发送端一次发送的多字节带外数据中只有最后一字节被当作带外数据(c)，而其他数据(a、b)被当成普通数据。如果TCP以多个TCP报文段来发送上图所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置自URG标志，并且它们的紧急指针指向同一位置，但只有一个TCP报文段真正携带带外数据。</p>\n<p>TCP接收带外数据，接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指位置确定带外数据位置，并将它读入一个特殊的缓存，这个缓存只有1字节，称为带外缓存。如果上层应用没有及时将带外数据从带外缓存中读出，后续的带外数据将覆盖它。</p>\n<p>上面的接收方式是TCP默认的接收方式，如果给TCP连接设置SO_OOBINLINE，那么带外数据将和普通数据一样被TCP模块存放在TCP接收缓冲区内。那么这样如何区分带外数据和普通数据? 1.紧急指针可以用来指出带外数据的位置2.socket编程接口提供了识别带外数据的系统调用</p>\n<h2 id=\"数据传输超时重传\"><a href=\"#数据传输超时重传\" class=\"headerlink\" title=\"数据传输超时重传\"></a>数据传输超时重传</h2><p>区别于三次握手的时候的超时重连策略</p>\n<p>TCP超时重传策略：如果某个数据报在规定时间内没收到确认包，接下来一共执行5次重传，间隔分别是0.2s、0.4s、0.8s、1.6s、3.2s。</p>\n<p>Linux中有两个重要的内核参数与TCP超时重传有关。 </p>\n<p>/proc/sys/net/ipv4/tcp_retries1 :  指定底层IP接管之前TCP最少执行的重传次数，默认值是3</p>\n<p>/proc/sys/net/ipv4/tcp_retries2 : 指定连接放弃前TCP最多可以执行的重传次数，默认值是15(一般对应13~30min)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TCP交互数据流\"><a href=\"#TCP交互数据流\" class=\"headerlink\" title=\"TCP交互数据流\"></a>TCP交互数据流</h2><p>交互数据仅包含很少的字节，使用交互数据的应用程序(或协议)对实时性要求高，比如telnet、ssh等</p>\n<h4 id=\"延迟确认\"><a href=\"#延迟确认\" class=\"headerlink\" title=\"延迟确认\"></a>延迟确认</h4><p>延迟确认：每次需要发送的确认报文段不马上发送，而是在一段延迟时间后查看本端是否有数据需要发送，如果有，就和确认信息一起发出。延迟确认可以减少发送TCP报文段的数量，提高通信效率。</p>\n<p>一般服务器对客户请求处理得很快，所以它发送确认报文段的时候总有数据一起发送，常用延迟确认。而客户端用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文一般不携带任何应用程序数据。</p>\n<p>在TCP四次挥手的时候，也有可能发生延迟确认。（确认客户端FIN包的ACK包可以和应用数据一起发送）</p>\n<h4 id=\"Nagle算法\"><a href=\"#Nagle算法\" class=\"headerlink\" title=\"Nagle算法\"></a>Nagle算法</h4><p>在广域网中，交互数据流可能经受很大的延迟，并且，如果携带交互数据流的微小TCP报文段数量很多的时候(一个按键就导致一个TCP报文段)，可能导致拥塞发生，影响网络性能。</p>\n<p>解决方案是:Nagle算法</p>\n<p>Nagle算法要求当一个TCP连接中有在传数据(即那些已发送但还未经确认的数据)，小的报文段(长度小于SMSS)就不能发送，直到所有的在传数据都收到ACK。并且，在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。迫使TCP遵循停等规程。这样就极大地减少了网络上的微小TCP报文段的数量，另一个优点是自适应性：确认到达得越快，数据也就发送得越快。</p>\n<h2 id=\"TCP成块数据流\"><a href=\"#TCP成块数据流\" class=\"headerlink\" title=\"TCP成块数据流\"></a>TCP成块数据流</h2><p>成块数据的长度通常为TCP报文段允许的最大数据长度，使用成块数据的应用程序（或协议）对传输效率要求高，比如ftp。</p>\n<p>当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。</p>\n<p>发送方在收到上一次确认后，能连续发送多少个TCP报文段取决于接收通告窗口大小和拥塞窗口大小。</p>\n<p>可以修改TCP接收缓冲区和发送缓冲区的大小。</p>\n<h2 id=\"带外数据\"><a href=\"#带外数据\" class=\"headerlink\" title=\"带外数据\"></a>带外数据</h2><p>用来迅速通告对方本端发生的重要事件，因此带外数据比普通数据有更高的优先级，应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。</p>\n<p>带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接上。</p>\n<p>UDP没实现带外数据传输，TCP也没真正的带外数据，但是TCP可以利用头部中的紧急指针标志和紧急指针两个字段，给应用程序提供一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。</p>\n<p><img src=\"/pic/TCP%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE.png\" alt=\"\"></p>\n<p>假设一个进程已经往某个TCP连接的发送缓冲区中写入了N个字节的普通数据，并等待其发送。在数据被发送之前，该进程又向这个连接写入了3字节的带外数据”abc”，此时，待发送的TCP报文段的头部被设置URG标志，且紧急指针被设置成指向最后一个带外数据的下一字节。</p>\n<p>发送端一次发送的多字节带外数据中只有最后一字节被当作带外数据(c)，而其他数据(a、b)被当成普通数据。如果TCP以多个TCP报文段来发送上图所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置自URG标志，并且它们的紧急指针指向同一位置，但只有一个TCP报文段真正携带带外数据。</p>\n<p>TCP接收带外数据，接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指位置确定带外数据位置，并将它读入一个特殊的缓存，这个缓存只有1字节，称为带外缓存。如果上层应用没有及时将带外数据从带外缓存中读出，后续的带外数据将覆盖它。</p>\n<p>上面的接收方式是TCP默认的接收方式，如果给TCP连接设置SO_OOBINLINE，那么带外数据将和普通数据一样被TCP模块存放在TCP接收缓冲区内。那么这样如何区分带外数据和普通数据? 1.紧急指针可以用来指出带外数据的位置2.socket编程接口提供了识别带外数据的系统调用</p>\n<h2 id=\"数据传输超时重传\"><a href=\"#数据传输超时重传\" class=\"headerlink\" title=\"数据传输超时重传\"></a>数据传输超时重传</h2><p>区别于三次握手的时候的超时重连策略</p>\n<p>TCP超时重传策略：如果某个数据报在规定时间内没收到确认包，接下来一共执行5次重传，间隔分别是0.2s、0.4s、0.8s、1.6s、3.2s。</p>\n<p>Linux中有两个重要的内核参数与TCP超时重传有关。 </p>\n<p>/proc/sys/net/ipv4/tcp_retries1 :  指定底层IP接管之前TCP最少执行的重传次数，默认值是3</p>\n<p>/proc/sys/net/ipv4/tcp_retries2 : 指定连接放弃前TCP最多可以执行的重传次数，默认值是15(一般对应13~30min)</p>\n"},{"title":"epoll","date":"2018-12-01T13:52:13.000Z","_content":"\n## 模型特点\n\n1.不同于select和poll,epoll采用回调函数的方式获取文件描述符的就绪状态(主动通知)\n2.采用红黑树管理epoll_event结构体\n3.内核维护一个就绪队列，只传出就绪的文件描述符\n4.有ET(边缘触发)和LT(水平触发)，而select和poll都只有LT\n5.同样也突破了select并发量的限制\n\n<!-- more -->\n\n## 具体使用\n\n#### 内核事件表\n\nepoll把用户关心的文件描述符上的事件放在内核里的一个事件表，不同于select、poll每次调用都要重复传入文件描述符集或事件集，因此epoll需要一个额外的文件描述符来唯一标识内核中的这个事件表，这个文件描述符用epoll_create函数来创建。\n\n**int epoll_create(int size)**；\n\nsize参数现在不起作用，只是给内核一个提示，告诉它内核事件表需要多大，该函数返回的文件描述符将作用于其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表\n\n**int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)**\n\nepfd：为epoll_creat的句柄\nop：表示动作，用3个宏来表示：\n\n- EPOLL_CTL_ADD(注册新的fd到epfd)\n- EPOLL_CTL_MOD(修改已经注册的fd的监听事件)\n- EPOLL_CTL_DEL(从epfd删除一个fd)\n\nevent：告诉内核需要监听的事件\nstruct epoll_event{\n​　　　　__uint32_t events;    //监控的事件\n​　　　　epoll_data_t data;  //用户数据\n};\nepoll支持的事件类型和poll基本相同，表示epoll事件类型的宏是在poll对应的宏前加上“E”，但epoll有两个额外的事件类型(EPOLLET和EPOLLONESHOT)，这两个宏对于epoll的高效运作很重要。\n\nEPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的\nEPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\n\ntypedef union epoll_data {\n​　　　　void        *ptr;     //指定与fd相关的用户数据\n​　　　　int          fd;\n​　　　　uint32_t     u32;\n​　　　　uint64_t     u64;\n} epoll_data_t;\n\n**int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)**\n\n成功返回就绪的文件描述符个数，失败返回-1并设置errno\n\nepoll_wait函数如果检测到事件，就将所有就绪的时间从内核事件表中复制到它的第二个参数events指向的数组，这个数组只用于输出epoll_wait检测到的就绪事件，而不像select、poll的数组参数既用于传入用户注册事件，又用于输出内核检测到的就绪事件，这就大大提高了应用程序索引就绪文件描述符的效率。\n\n对于select、poll，需要遍历整个数组找出就绪的文件描述符，然后判断是什么类型的事件发生  O(n)\n\n对于epoll,数组中的所有文件描述符都是就绪的，直接可以判断是什么类型的事件发生  O(1)\n\n## ET和LT\n\nLT是默认的工作模式，这种模式下epoll相当于一个效率较高的poll.\n当epoll内核事件表宏注册了一个文件描述符EPOLLET时，采用ET模式\nLT：只要一个文件描述符上的事件一次没有处理完，会在以后调用epoll_wait时次次返回就绪\nET：只返回一个就绪，不管处理完还是没有处理完\n\n举个例子:\n1.某个客户端向服务器传输了2KB的数据\n2.服务器epoll_wait()返回，然后读了1KB\n3.两种模式比较\n\n- 如果是LT模式下，下次epoll_wait()还会返回，然后继续读，直到数据被处理完毕\n- 如果是ET模式下，下次epoll_wait()会阻塞，因此ET模式只适用于非阻塞的socket，需要循环读取保证所有数据被处理完毕。\n- 设置非阻塞 1.socket创建指定选项 2.fcntl 3.iocnlsocket\n\nET模式很大程序上降低了同一个epoll事件被重复触发的次数，效率更高。但是LT能保证数据读取完整，ET读取数据如果被信号打断，可能读取不全。\n\n对于监听的 sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上。如果非要使用边缘触发，可以用 while 来循环 accept()。\n\n[ET和LT](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/et_lt.cpp)\n\n#### 为什么ET模式下socket要设置成非阻塞？\n\n如果是阻塞 connfd 的边缘触发，如果不一次性读取一个事件上的数据，会干扰下一个事件，所以必须在读取数据的外部套一层循环，这样才能完整的处理数据。但是外层套循环之后会导致另外一个问题：处理完数据之后，程序会一直卡在 recv() 函数上，因为是阻塞 IO，如果没数据可读，它会一直等在那里，直到有数据可读。但是这个时候，如果用另一个客户端去连接服务器，服务器就不能受理这个新的客户端了。\n\n如果是非阻塞 connfd 的边缘触发，和阻塞版本一样，必须在读取数据的外部套一层循环，这样才能完整的处理数据。因为非阻塞 IO 如果没有数据可读时，会立即返回，并设置 errno。这里我们根据 EAGAIN 和EWOULDBLOCK 来判断数据是否全部读取完毕了，如果读取完毕，就会正常退出循环了。\n\n## EPOLLONESHOT (Linux高性能服务器编程P157)\n\n即使我们使用ET模式，那一个socket上的事件也有可能被触发多次，这在并发程序中会引起一个问题。比如一个线程读取socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读，此时另外一个线程来读取这些数据，于是就出现了两个线程同时操作一个socket的情况。而我们期望一个socket连接在任意时刻都只被一个线程处理，这一点我们可以用EPOLLONESHOT事件实现。\n\n对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其注册的读、写、异常中的一个，并且只触发一次，除非重新用epoll_ctl重置该文件描述符的EPOLLONESHOT事件。因此，每次处理完都需要立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，EPOLLIN能被触发。\n\n**注意：监听socket上不能注册EPOLLONESHOT，否则只能处理一个客户端的连接**\n\n[EPOLLONESHOT](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/epoll_oneshot.cpp)\n\n#### 对于EPOLLOUT事件的一些理解\n\n在一次发送大量数据（超过发送缓冲区大小）的情况下，如果使用阻塞方式，程序一直阻塞，直到所有的数据都写入到缓冲区中。例如，要发送M字节数据，套接字发送缓冲区大小为B字节，只有当对端向本机返回ack表明其接收到大于等于M-B字节时，才意味着所有的数据都写入到缓冲区中。很明显，如果一次发送的数据量非常大，比如M=10GB、B=64KB，则：1）一次发送过程中本机线程会在一个fd上阻塞相当长一段时间，其他fd得不到及时处理；2）如果出现发送失败，无从得知到底有多少数据发送成功，应用程序只能选择重新发送这10G数据，结合考虑网络的稳定性，只能呵呵；\n总之，上述两点都是无法接受的。因此，对性能有要求的服务器一般不采用阻塞而采用非阻塞。\n\n采用非阻塞套接字一次发送大量数据的流程：\n\n- 1.使劲往发送缓冲区中写数据，直到返回不可写\n\n- 2.等待下一次缓冲区可写\n\n- 3.要发送的数据写完\n\n  其中2可以有两种方式\n\n  - 查询式，程序不停地查询是否可写\n  - 程序去干其他的事情（多路分离器的优在），等出现可写事件后再接着写；很明显方式b）更加优雅\n\n例如需要将一个10G大小的文件返回给用户，那么简单send这个文件是不会成功的。\n这个场景下，send 10G的数据，send返回值不会是10G，而是大约256k，表示你只成功写入了256k的数据。接着调用send，send就会返回EAGAIN，告诉你socket的缓冲区已经满了，此时无法继续send,需要重新注册EPOLLOUT事件，进行新一轮的监听。\n此时异步程序的正确处理流程是调用epoll_wait，当socket缓冲区中的数据被对方接收之后，缓冲区就会有空闲空间可以继续接收数据，此时epoll_wait就会返回这个socket的EPOLLOUT事件，获得这个事件时，你就可以继续往socket中写出数据。\n\nEPOLLOUT事件就是以事件的方式通知用户程序，可以继续往缓冲区写数据了。\n\n## 优缺点分析\n\n缺点：\n1.在高并发高活跃的情况下，对内部树进行频繁的操作，效率可能不如select和poll\n2.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。\n\n优点:\n1.非常适用于高并发低活跃的情况下\n2.采用回调函数的方式传出fd，高效\n3.直接传出就绪的文件描述符，减少了索引就绪文件描述符的时间\n\n4.真正突破了文件描述符的限制，不采用轮询，不会因为fd数量的增长而导致效率下降\n5.有ET工作模型和EPOLLONESHOT，进一步提升了工作效率\n\n## LT工作模型下的服务器(客户端同多进程模型)\n\n```\n#include<stdio.h>\n#include<ctype.h>\n#include<string.h>\n#include<unistd.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<stdlib.h>\n#include<string.h>\n#include<sys/epoll.h>\n#include<arpa/inet.h>\n\n#define PORT       1234\n#define LISTEN     128\n#define IP         16\n#define BUFSIZE    1500\n#define MAXSIZE    200000\n\nint main()\n{\n\tstruct sockaddr_in addr,clientaddr;\n\tchar ip[IP] = {0};\n\tbzero(&addr,sizeof(addr));\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(PORT)\t;\n\n\t\n\tint Serverfd;\n\tServerfd = socket(AF_INET,SOCK_STREAM,0);\n\tif(Serverfd  == -1){\n\t\tperror(\"Socket Create Faile\");\n\t\texit(-1);\n\t}\n\tprintf(\"Serverfd:%d\\n\",Serverfd);\n\tif(-1 == bind(Serverfd,(struct sockaddr*)&addr,sizeof(addr))){\n\t\tperror(\"BIND ERROR\");\n\t\texit(-1);\n\t}\n\n\tif(-1 == listen(Serverfd,LISTEN)){\n\t\tperror(\"LISTEN ERROR\");\n\t\texit(-1);\n\t}\n\n\tprintf(\"epoll Server is running\\n\");\n\n\tstruct epoll_event ent[MAXSIZE];\n\tstruct epoll_event tmp;\n\tint epfd,ready,nlen;\n\tchar buf[BUFSIZE];\n\t\n\n\tfor(int i = 0;i<MAXSIZE;i++){\n\t\tent[i].data.fd = -1;\n\t}\n\n\tepfd = epoll_create(MAXSIZE);    //红黑树\n\n\ttmp.data.fd = Serverfd;\n\ttmp.events = EPOLLIN;\n\t\n\tepoll_ctl(epfd,EPOLL_CTL_ADD,Serverfd,&tmp);\n\t\n\twhile(1){\n\t\tready = epoll_wait(epfd,ent,MAXSIZE,-1);\n\t\t\n\t\twhile(ready){\n\t\t\tif(ent[--ready].data.fd == Serverfd){\n\t\t\t\tint Clientfd;\n\t\t\t\tint nlen = sizeof(clientaddr);\n\t\t\t\tClientfd = accept(Serverfd,(struct sockaddr*)&clientaddr,&nlen);\n\t\t\t\tif(Clientfd == -1){\n\t\t\t\t\tperror(\"Accpet Error\");\n\t\t\t\t\texit(-1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinet_ntop(AF_INET,&clientaddr.sin_addr.s_addr,ip,sizeof(ip));\n\t\t\t\t\tprintf(\"IP:%s Port:%d Clientfd:%d\\n\",ip,clientaddr.sin_port,Clientfd);\n\t\t\t\t\t\n\t\t\t\t\ttmp.data.fd = Clientfd;\n\t\t\t\t\ttmp.events = EPOLLIN;\n\n\t\t\t\t\tepoll_ctl(epfd,EPOLL_CTL_ADD,Clientfd,&tmp);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(ent[ready].data.fd != -1){\n\t\t\t\t\tnlen = read(ent[ready].data.fd,buf,sizeof(buf));\n\n\t\t\t\t\tif(0 == nlen){\n\t\t\t\t\t\tepoll_ctl(epfd,EPOLL_CTL_DEL,ent[ready].data.fd,NULL);\n\t\t\t\t\t\tclose(ent[ready].data.fd);\n\t\t\t\t\t\tprintf(\"Clientfd:%d客户端终止\\n\",ent[ready].data.fd);\n\t\t\t\t\t\tent[ready].data.fd = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i = 0;i<nlen;i++){\n\t\t\t\t\t\t\tbuf[i] =toupper(buf[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twrite(ent[ready].data.fd,buf,nlen);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tclose(Serverfd);\n\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/epoll.md","raw":"---\ntitle: epoll\ndate: 2018-12-01 21:52:13\ntags: \n- IO复用 \n- Linux\n- 网络\n- Linux高性能服务器编程\n---\n\n## 模型特点\n\n1.不同于select和poll,epoll采用回调函数的方式获取文件描述符的就绪状态(主动通知)\n2.采用红黑树管理epoll_event结构体\n3.内核维护一个就绪队列，只传出就绪的文件描述符\n4.有ET(边缘触发)和LT(水平触发)，而select和poll都只有LT\n5.同样也突破了select并发量的限制\n\n<!-- more -->\n\n## 具体使用\n\n#### 内核事件表\n\nepoll把用户关心的文件描述符上的事件放在内核里的一个事件表，不同于select、poll每次调用都要重复传入文件描述符集或事件集，因此epoll需要一个额外的文件描述符来唯一标识内核中的这个事件表，这个文件描述符用epoll_create函数来创建。\n\n**int epoll_create(int size)**；\n\nsize参数现在不起作用，只是给内核一个提示，告诉它内核事件表需要多大，该函数返回的文件描述符将作用于其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表\n\n**int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)**\n\nepfd：为epoll_creat的句柄\nop：表示动作，用3个宏来表示：\n\n- EPOLL_CTL_ADD(注册新的fd到epfd)\n- EPOLL_CTL_MOD(修改已经注册的fd的监听事件)\n- EPOLL_CTL_DEL(从epfd删除一个fd)\n\nevent：告诉内核需要监听的事件\nstruct epoll_event{\n​　　　　__uint32_t events;    //监控的事件\n​　　　　epoll_data_t data;  //用户数据\n};\nepoll支持的事件类型和poll基本相同，表示epoll事件类型的宏是在poll对应的宏前加上“E”，但epoll有两个额外的事件类型(EPOLLET和EPOLLONESHOT)，这两个宏对于epoll的高效运作很重要。\n\nEPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的\nEPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\n\ntypedef union epoll_data {\n​　　　　void        *ptr;     //指定与fd相关的用户数据\n​　　　　int          fd;\n​　　　　uint32_t     u32;\n​　　　　uint64_t     u64;\n} epoll_data_t;\n\n**int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)**\n\n成功返回就绪的文件描述符个数，失败返回-1并设置errno\n\nepoll_wait函数如果检测到事件，就将所有就绪的时间从内核事件表中复制到它的第二个参数events指向的数组，这个数组只用于输出epoll_wait检测到的就绪事件，而不像select、poll的数组参数既用于传入用户注册事件，又用于输出内核检测到的就绪事件，这就大大提高了应用程序索引就绪文件描述符的效率。\n\n对于select、poll，需要遍历整个数组找出就绪的文件描述符，然后判断是什么类型的事件发生  O(n)\n\n对于epoll,数组中的所有文件描述符都是就绪的，直接可以判断是什么类型的事件发生  O(1)\n\n## ET和LT\n\nLT是默认的工作模式，这种模式下epoll相当于一个效率较高的poll.\n当epoll内核事件表宏注册了一个文件描述符EPOLLET时，采用ET模式\nLT：只要一个文件描述符上的事件一次没有处理完，会在以后调用epoll_wait时次次返回就绪\nET：只返回一个就绪，不管处理完还是没有处理完\n\n举个例子:\n1.某个客户端向服务器传输了2KB的数据\n2.服务器epoll_wait()返回，然后读了1KB\n3.两种模式比较\n\n- 如果是LT模式下，下次epoll_wait()还会返回，然后继续读，直到数据被处理完毕\n- 如果是ET模式下，下次epoll_wait()会阻塞，因此ET模式只适用于非阻塞的socket，需要循环读取保证所有数据被处理完毕。\n- 设置非阻塞 1.socket创建指定选项 2.fcntl 3.iocnlsocket\n\nET模式很大程序上降低了同一个epoll事件被重复触发的次数，效率更高。但是LT能保证数据读取完整，ET读取数据如果被信号打断，可能读取不全。\n\n对于监听的 sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上。如果非要使用边缘触发，可以用 while 来循环 accept()。\n\n[ET和LT](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/et_lt.cpp)\n\n#### 为什么ET模式下socket要设置成非阻塞？\n\n如果是阻塞 connfd 的边缘触发，如果不一次性读取一个事件上的数据，会干扰下一个事件，所以必须在读取数据的外部套一层循环，这样才能完整的处理数据。但是外层套循环之后会导致另外一个问题：处理完数据之后，程序会一直卡在 recv() 函数上，因为是阻塞 IO，如果没数据可读，它会一直等在那里，直到有数据可读。但是这个时候，如果用另一个客户端去连接服务器，服务器就不能受理这个新的客户端了。\n\n如果是非阻塞 connfd 的边缘触发，和阻塞版本一样，必须在读取数据的外部套一层循环，这样才能完整的处理数据。因为非阻塞 IO 如果没有数据可读时，会立即返回，并设置 errno。这里我们根据 EAGAIN 和EWOULDBLOCK 来判断数据是否全部读取完毕了，如果读取完毕，就会正常退出循环了。\n\n## EPOLLONESHOT (Linux高性能服务器编程P157)\n\n即使我们使用ET模式，那一个socket上的事件也有可能被触发多次，这在并发程序中会引起一个问题。比如一个线程读取socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读，此时另外一个线程来读取这些数据，于是就出现了两个线程同时操作一个socket的情况。而我们期望一个socket连接在任意时刻都只被一个线程处理，这一点我们可以用EPOLLONESHOT事件实现。\n\n对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其注册的读、写、异常中的一个，并且只触发一次，除非重新用epoll_ctl重置该文件描述符的EPOLLONESHOT事件。因此，每次处理完都需要立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，EPOLLIN能被触发。\n\n**注意：监听socket上不能注册EPOLLONESHOT，否则只能处理一个客户端的连接**\n\n[EPOLLONESHOT](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/epoll_oneshot.cpp)\n\n#### 对于EPOLLOUT事件的一些理解\n\n在一次发送大量数据（超过发送缓冲区大小）的情况下，如果使用阻塞方式，程序一直阻塞，直到所有的数据都写入到缓冲区中。例如，要发送M字节数据，套接字发送缓冲区大小为B字节，只有当对端向本机返回ack表明其接收到大于等于M-B字节时，才意味着所有的数据都写入到缓冲区中。很明显，如果一次发送的数据量非常大，比如M=10GB、B=64KB，则：1）一次发送过程中本机线程会在一个fd上阻塞相当长一段时间，其他fd得不到及时处理；2）如果出现发送失败，无从得知到底有多少数据发送成功，应用程序只能选择重新发送这10G数据，结合考虑网络的稳定性，只能呵呵；\n总之，上述两点都是无法接受的。因此，对性能有要求的服务器一般不采用阻塞而采用非阻塞。\n\n采用非阻塞套接字一次发送大量数据的流程：\n\n- 1.使劲往发送缓冲区中写数据，直到返回不可写\n\n- 2.等待下一次缓冲区可写\n\n- 3.要发送的数据写完\n\n  其中2可以有两种方式\n\n  - 查询式，程序不停地查询是否可写\n  - 程序去干其他的事情（多路分离器的优在），等出现可写事件后再接着写；很明显方式b）更加优雅\n\n例如需要将一个10G大小的文件返回给用户，那么简单send这个文件是不会成功的。\n这个场景下，send 10G的数据，send返回值不会是10G，而是大约256k，表示你只成功写入了256k的数据。接着调用send，send就会返回EAGAIN，告诉你socket的缓冲区已经满了，此时无法继续send,需要重新注册EPOLLOUT事件，进行新一轮的监听。\n此时异步程序的正确处理流程是调用epoll_wait，当socket缓冲区中的数据被对方接收之后，缓冲区就会有空闲空间可以继续接收数据，此时epoll_wait就会返回这个socket的EPOLLOUT事件，获得这个事件时，你就可以继续往socket中写出数据。\n\nEPOLLOUT事件就是以事件的方式通知用户程序，可以继续往缓冲区写数据了。\n\n## 优缺点分析\n\n缺点：\n1.在高并发高活跃的情况下，对内部树进行频繁的操作，效率可能不如select和poll\n2.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。\n\n优点:\n1.非常适用于高并发低活跃的情况下\n2.采用回调函数的方式传出fd，高效\n3.直接传出就绪的文件描述符，减少了索引就绪文件描述符的时间\n\n4.真正突破了文件描述符的限制，不采用轮询，不会因为fd数量的增长而导致效率下降\n5.有ET工作模型和EPOLLONESHOT，进一步提升了工作效率\n\n## LT工作模型下的服务器(客户端同多进程模型)\n\n```\n#include<stdio.h>\n#include<ctype.h>\n#include<string.h>\n#include<unistd.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<stdlib.h>\n#include<string.h>\n#include<sys/epoll.h>\n#include<arpa/inet.h>\n\n#define PORT       1234\n#define LISTEN     128\n#define IP         16\n#define BUFSIZE    1500\n#define MAXSIZE    200000\n\nint main()\n{\n\tstruct sockaddr_in addr,clientaddr;\n\tchar ip[IP] = {0};\n\tbzero(&addr,sizeof(addr));\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(PORT)\t;\n\n\t\n\tint Serverfd;\n\tServerfd = socket(AF_INET,SOCK_STREAM,0);\n\tif(Serverfd  == -1){\n\t\tperror(\"Socket Create Faile\");\n\t\texit(-1);\n\t}\n\tprintf(\"Serverfd:%d\\n\",Serverfd);\n\tif(-1 == bind(Serverfd,(struct sockaddr*)&addr,sizeof(addr))){\n\t\tperror(\"BIND ERROR\");\n\t\texit(-1);\n\t}\n\n\tif(-1 == listen(Serverfd,LISTEN)){\n\t\tperror(\"LISTEN ERROR\");\n\t\texit(-1);\n\t}\n\n\tprintf(\"epoll Server is running\\n\");\n\n\tstruct epoll_event ent[MAXSIZE];\n\tstruct epoll_event tmp;\n\tint epfd,ready,nlen;\n\tchar buf[BUFSIZE];\n\t\n\n\tfor(int i = 0;i<MAXSIZE;i++){\n\t\tent[i].data.fd = -1;\n\t}\n\n\tepfd = epoll_create(MAXSIZE);    //红黑树\n\n\ttmp.data.fd = Serverfd;\n\ttmp.events = EPOLLIN;\n\t\n\tepoll_ctl(epfd,EPOLL_CTL_ADD,Serverfd,&tmp);\n\t\n\twhile(1){\n\t\tready = epoll_wait(epfd,ent,MAXSIZE,-1);\n\t\t\n\t\twhile(ready){\n\t\t\tif(ent[--ready].data.fd == Serverfd){\n\t\t\t\tint Clientfd;\n\t\t\t\tint nlen = sizeof(clientaddr);\n\t\t\t\tClientfd = accept(Serverfd,(struct sockaddr*)&clientaddr,&nlen);\n\t\t\t\tif(Clientfd == -1){\n\t\t\t\t\tperror(\"Accpet Error\");\n\t\t\t\t\texit(-1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinet_ntop(AF_INET,&clientaddr.sin_addr.s_addr,ip,sizeof(ip));\n\t\t\t\t\tprintf(\"IP:%s Port:%d Clientfd:%d\\n\",ip,clientaddr.sin_port,Clientfd);\n\t\t\t\t\t\n\t\t\t\t\ttmp.data.fd = Clientfd;\n\t\t\t\t\ttmp.events = EPOLLIN;\n\n\t\t\t\t\tepoll_ctl(epfd,EPOLL_CTL_ADD,Clientfd,&tmp);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(ent[ready].data.fd != -1){\n\t\t\t\t\tnlen = read(ent[ready].data.fd,buf,sizeof(buf));\n\n\t\t\t\t\tif(0 == nlen){\n\t\t\t\t\t\tepoll_ctl(epfd,EPOLL_CTL_DEL,ent[ready].data.fd,NULL);\n\t\t\t\t\t\tclose(ent[ready].data.fd);\n\t\t\t\t\t\tprintf(\"Clientfd:%d客户端终止\\n\",ent[ready].data.fd);\n\t\t\t\t\t\tent[ready].data.fd = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i = 0;i<nlen;i++){\n\t\t\t\t\t\t\tbuf[i] =toupper(buf[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twrite(ent[ready].data.fd,buf,nlen);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tclose(Serverfd);\n\n\treturn 0;\n}\n```\n\n\n\n","slug":"epoll","published":1,"updated":"2021-12-06T05:30:36.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7e000i96ca4z35cdd2","content":"<h2 id=\"模型特点\"><a href=\"#模型特点\" class=\"headerlink\" title=\"模型特点\"></a>模型特点</h2><p>1.不同于select和poll,epoll采用回调函数的方式获取文件描述符的就绪状态(主动通知)<br>2.采用红黑树管理epoll_event结构体<br>3.内核维护一个就绪队列，只传出就绪的文件描述符<br>4.有ET(边缘触发)和LT(水平触发)，而select和poll都只有LT<br>5.同样也突破了select并发量的限制</p>\n<a id=\"more\"></a>\n\n<h2 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h2><h4 id=\"内核事件表\"><a href=\"#内核事件表\" class=\"headerlink\" title=\"内核事件表\"></a>内核事件表</h4><p>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表，不同于select、poll每次调用都要重复传入文件描述符集或事件集，因此epoll需要一个额外的文件描述符来唯一标识内核中的这个事件表，这个文件描述符用epoll_create函数来创建。</p>\n<p><strong>int epoll_create(int size)</strong>；</p>\n<p>size参数现在不起作用，只是给内核一个提示，告诉它内核事件表需要多大，该函数返回的文件描述符将作用于其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表</p>\n<p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</strong></p>\n<p>epfd：为epoll_creat的句柄<br>op：表示动作，用3个宏来表示：</p>\n<ul>\n<li>EPOLL_CTL_ADD(注册新的fd到epfd)</li>\n<li>EPOLL_CTL_MOD(修改已经注册的fd的监听事件)</li>\n<li>EPOLL_CTL_DEL(从epfd删除一个fd)</li>\n</ul>\n<p>event：告诉内核需要监听的事件<br>struct epoll_event{<br>​　　　　__uint32_t events;    //监控的事件<br>​　　　　epoll_data_t data;  //用户数据<br>};<br>epoll支持的事件类型和poll基本相同，表示epoll事件类型的宏是在poll对应的宏前加上“E”，但epoll有两个额外的事件类型(EPOLLET和EPOLLONESHOT)，这两个宏对于epoll的高效运作很重要。</p>\n<p>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>\n<p>typedef union epoll_data {<br>​　　　　void        *ptr;     //指定与fd相关的用户数据<br>​　　　　int          fd;<br>​　　　　uint32_t     u32;<br>​　　　　uint64_t     u64;<br>} epoll_data_t;</p>\n<p><strong>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</strong></p>\n<p>成功返回就绪的文件描述符个数，失败返回-1并设置errno</p>\n<p>epoll_wait函数如果检测到事件，就将所有就绪的时间从内核事件表中复制到它的第二个参数events指向的数组，这个数组只用于输出epoll_wait检测到的就绪事件，而不像select、poll的数组参数既用于传入用户注册事件，又用于输出内核检测到的就绪事件，这就大大提高了应用程序索引就绪文件描述符的效率。</p>\n<p>对于select、poll，需要遍历整个数组找出就绪的文件描述符，然后判断是什么类型的事件发生  O(n)</p>\n<p>对于epoll,数组中的所有文件描述符都是就绪的，直接可以判断是什么类型的事件发生  O(1)</p>\n<h2 id=\"ET和LT\"><a href=\"#ET和LT\" class=\"headerlink\" title=\"ET和LT\"></a>ET和LT</h2><p>LT是默认的工作模式，这种模式下epoll相当于一个效率较高的poll.<br>当epoll内核事件表宏注册了一个文件描述符EPOLLET时，采用ET模式<br>LT：只要一个文件描述符上的事件一次没有处理完，会在以后调用epoll_wait时次次返回就绪<br>ET：只返回一个就绪，不管处理完还是没有处理完</p>\n<p>举个例子:<br>1.某个客户端向服务器传输了2KB的数据<br>2.服务器epoll_wait()返回，然后读了1KB<br>3.两种模式比较</p>\n<ul>\n<li>如果是LT模式下，下次epoll_wait()还会返回，然后继续读，直到数据被处理完毕</li>\n<li>如果是ET模式下，下次epoll_wait()会阻塞，因此ET模式只适用于非阻塞的socket，需要循环读取保证所有数据被处理完毕。</li>\n<li>设置非阻塞 1.socket创建指定选项 2.fcntl 3.iocnlsocket</li>\n</ul>\n<p>ET模式很大程序上降低了同一个epoll事件被重复触发的次数，效率更高。但是LT能保证数据读取完整，ET读取数据如果被信号打断，可能读取不全。</p>\n<p>对于监听的 sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上。如果非要使用边缘触发，可以用 while 来循环 accept()。</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/et_lt.cpp\" target=\"_blank\" rel=\"noopener\">ET和LT</a></p>\n<h4 id=\"为什么ET模式下socket要设置成非阻塞？\"><a href=\"#为什么ET模式下socket要设置成非阻塞？\" class=\"headerlink\" title=\"为什么ET模式下socket要设置成非阻塞？\"></a>为什么ET模式下socket要设置成非阻塞？</h4><p>如果是阻塞 connfd 的边缘触发，如果不一次性读取一个事件上的数据，会干扰下一个事件，所以必须在读取数据的外部套一层循环，这样才能完整的处理数据。但是外层套循环之后会导致另外一个问题：处理完数据之后，程序会一直卡在 recv() 函数上，因为是阻塞 IO，如果没数据可读，它会一直等在那里，直到有数据可读。但是这个时候，如果用另一个客户端去连接服务器，服务器就不能受理这个新的客户端了。</p>\n<p>如果是非阻塞 connfd 的边缘触发，和阻塞版本一样，必须在读取数据的外部套一层循环，这样才能完整的处理数据。因为非阻塞 IO 如果没有数据可读时，会立即返回，并设置 errno。这里我们根据 EAGAIN 和EWOULDBLOCK 来判断数据是否全部读取完毕了，如果读取完毕，就会正常退出循环了。</p>\n<h2 id=\"EPOLLONESHOT-Linux高性能服务器编程P157\"><a href=\"#EPOLLONESHOT-Linux高性能服务器编程P157\" class=\"headerlink\" title=\"EPOLLONESHOT (Linux高性能服务器编程P157)\"></a>EPOLLONESHOT (Linux高性能服务器编程P157)</h2><p>即使我们使用ET模式，那一个socket上的事件也有可能被触发多次，这在并发程序中会引起一个问题。比如一个线程读取socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读，此时另外一个线程来读取这些数据，于是就出现了两个线程同时操作一个socket的情况。而我们期望一个socket连接在任意时刻都只被一个线程处理，这一点我们可以用EPOLLONESHOT事件实现。</p>\n<p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其注册的读、写、异常中的一个，并且只触发一次，除非重新用epoll_ctl重置该文件描述符的EPOLLONESHOT事件。因此，每次处理完都需要立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，EPOLLIN能被触发。</p>\n<p><strong>注意：监听socket上不能注册EPOLLONESHOT，否则只能处理一个客户端的连接</strong></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/epoll_oneshot.cpp\" target=\"_blank\" rel=\"noopener\">EPOLLONESHOT</a></p>\n<h4 id=\"对于EPOLLOUT事件的一些理解\"><a href=\"#对于EPOLLOUT事件的一些理解\" class=\"headerlink\" title=\"对于EPOLLOUT事件的一些理解\"></a>对于EPOLLOUT事件的一些理解</h4><p>在一次发送大量数据（超过发送缓冲区大小）的情况下，如果使用阻塞方式，程序一直阻塞，直到所有的数据都写入到缓冲区中。例如，要发送M字节数据，套接字发送缓冲区大小为B字节，只有当对端向本机返回ack表明其接收到大于等于M-B字节时，才意味着所有的数据都写入到缓冲区中。很明显，如果一次发送的数据量非常大，比如M=10GB、B=64KB，则：1）一次发送过程中本机线程会在一个fd上阻塞相当长一段时间，其他fd得不到及时处理；2）如果出现发送失败，无从得知到底有多少数据发送成功，应用程序只能选择重新发送这10G数据，结合考虑网络的稳定性，只能呵呵；<br>总之，上述两点都是无法接受的。因此，对性能有要求的服务器一般不采用阻塞而采用非阻塞。</p>\n<p>采用非阻塞套接字一次发送大量数据的流程：</p>\n<ul>\n<li><p>1.使劲往发送缓冲区中写数据，直到返回不可写</p>\n</li>\n<li><p>2.等待下一次缓冲区可写</p>\n</li>\n<li><p>3.要发送的数据写完</p>\n<p>其中2可以有两种方式</p>\n<ul>\n<li>查询式，程序不停地查询是否可写</li>\n<li>程序去干其他的事情（多路分离器的优在），等出现可写事件后再接着写；很明显方式b）更加优雅</li>\n</ul>\n</li>\n</ul>\n<p>例如需要将一个10G大小的文件返回给用户，那么简单send这个文件是不会成功的。<br>这个场景下，send 10G的数据，send返回值不会是10G，而是大约256k，表示你只成功写入了256k的数据。接着调用send，send就会返回EAGAIN，告诉你socket的缓冲区已经满了，此时无法继续send,需要重新注册EPOLLOUT事件，进行新一轮的监听。<br>此时异步程序的正确处理流程是调用epoll_wait，当socket缓冲区中的数据被对方接收之后，缓冲区就会有空闲空间可以继续接收数据，此时epoll_wait就会返回这个socket的EPOLLOUT事件，获得这个事件时，你就可以继续往socket中写出数据。</p>\n<p>EPOLLOUT事件就是以事件的方式通知用户程序，可以继续往缓冲区写数据了。</p>\n<h2 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h2><p>缺点：<br>1.在高并发高活跃的情况下，对内部树进行频繁的操作，效率可能不如select和poll<br>2.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。</p>\n<p>优点:<br>1.非常适用于高并发低活跃的情况下<br>2.采用回调函数的方式传出fd，高效<br>3.直接传出就绪的文件描述符，减少了索引就绪文件描述符的时间</p>\n<p>4.真正突破了文件描述符的限制，不采用轮询，不会因为fd数量的增长而导致效率下降<br>5.有ET工作模型和EPOLLONESHOT，进一步提升了工作效率</p>\n<h2 id=\"LT工作模型下的服务器-客户端同多进程模型\"><a href=\"#LT工作模型下的服务器-客户端同多进程模型\" class=\"headerlink\" title=\"LT工作模型下的服务器(客户端同多进程模型)\"></a>LT工作模型下的服务器(客户端同多进程模型)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;stdio.h&gt;</span><br><span class=\"line\">#include&lt;ctype.h&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;unistd.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;types.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;epoll.h&gt;</span><br><span class=\"line\">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define PORT       1234</span><br><span class=\"line\">#define LISTEN     128</span><br><span class=\"line\">#define IP         16</span><br><span class=\"line\">#define BUFSIZE    1500</span><br><span class=\"line\">#define MAXSIZE    200000</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstruct sockaddr_in addr,clientaddr;</span><br><span class=\"line\">\tchar ip[IP] &#x3D; &#123;0&#125;;</span><br><span class=\"line\">\tbzero(&amp;addr,sizeof(addr));</span><br><span class=\"line\"></span><br><span class=\"line\">\taddr.sin_family &#x3D; AF_INET;</span><br><span class=\"line\">\taddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</span><br><span class=\"line\">\taddr.sin_port &#x3D; htons(PORT)\t;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tint Serverfd;</span><br><span class=\"line\">\tServerfd &#x3D; socket(AF_INET,SOCK_STREAM,0);</span><br><span class=\"line\">\tif(Serverfd  &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\tperror(&quot;Socket Create Faile&quot;);</span><br><span class=\"line\">\t\texit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;Serverfd:%d\\n&quot;,Serverfd);</span><br><span class=\"line\">\tif(-1 &#x3D;&#x3D; bind(Serverfd,(struct sockaddr*)&amp;addr,sizeof(addr)))&#123;</span><br><span class=\"line\">\t\tperror(&quot;BIND ERROR&quot;);</span><br><span class=\"line\">\t\texit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(-1 &#x3D;&#x3D; listen(Serverfd,LISTEN))&#123;</span><br><span class=\"line\">\t\tperror(&quot;LISTEN ERROR&quot;);</span><br><span class=\"line\">\t\texit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(&quot;epoll Server is running\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct epoll_event ent[MAXSIZE];</span><br><span class=\"line\">\tstruct epoll_event tmp;</span><br><span class=\"line\">\tint epfd,ready,nlen;</span><br><span class=\"line\">\tchar buf[BUFSIZE];</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor(int i &#x3D; 0;i&lt;MAXSIZE;i++)&#123;</span><br><span class=\"line\">\t\tent[i].data.fd &#x3D; -1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tepfd &#x3D; epoll_create(MAXSIZE);    &#x2F;&#x2F;红黑树</span><br><span class=\"line\"></span><br><span class=\"line\">\ttmp.data.fd &#x3D; Serverfd;</span><br><span class=\"line\">\ttmp.events &#x3D; EPOLLIN;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tepoll_ctl(epfd,EPOLL_CTL_ADD,Serverfd,&amp;tmp);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tready &#x3D; epoll_wait(epfd,ent,MAXSIZE,-1);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\twhile(ready)&#123;</span><br><span class=\"line\">\t\t\tif(ent[--ready].data.fd &#x3D;&#x3D; Serverfd)&#123;</span><br><span class=\"line\">\t\t\t\tint Clientfd;</span><br><span class=\"line\">\t\t\t\tint nlen &#x3D; sizeof(clientaddr);</span><br><span class=\"line\">\t\t\t\tClientfd &#x3D; accept(Serverfd,(struct sockaddr*)&amp;clientaddr,&amp;nlen);</span><br><span class=\"line\">\t\t\t\tif(Clientfd &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\t\t\tperror(&quot;Accpet Error&quot;);</span><br><span class=\"line\">\t\t\t\t\texit(-1);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse&#123;</span><br><span class=\"line\">\t\t\t\t\tinet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,ip,sizeof(ip));</span><br><span class=\"line\">\t\t\t\t\tprintf(&quot;IP:%s Port:%d Clientfd:%d\\n&quot;,ip,clientaddr.sin_port,Clientfd);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\ttmp.data.fd &#x3D; Clientfd;</span><br><span class=\"line\">\t\t\t\t\ttmp.events &#x3D; EPOLLIN;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tepoll_ctl(epfd,EPOLL_CTL_ADD,Clientfd,&amp;tmp);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse&#123;</span><br><span class=\"line\">\t\t\t\tif(ent[ready].data.fd !&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\t\t\tnlen &#x3D; read(ent[ready].data.fd,buf,sizeof(buf));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tif(0 &#x3D;&#x3D; nlen)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tepoll_ctl(epfd,EPOLL_CTL_DEL,ent[ready].data.fd,NULL);</span><br><span class=\"line\">\t\t\t\t\t\tclose(ent[ready].data.fd);</span><br><span class=\"line\">\t\t\t\t\t\tprintf(&quot;Clientfd:%d客户端终止\\n&quot;,ent[ready].data.fd);</span><br><span class=\"line\">\t\t\t\t\t\tent[ready].data.fd &#x3D; -1;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\telse&#123;</span><br><span class=\"line\">\t\t\t\t\t\tfor(int i &#x3D; 0;i&lt;nlen;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tbuf[i] &#x3D;toupper(buf[i]);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\twrite(ent[ready].data.fd,buf,nlen);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclose(Serverfd);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"模型特点\"><a href=\"#模型特点\" class=\"headerlink\" title=\"模型特点\"></a>模型特点</h2><p>1.不同于select和poll,epoll采用回调函数的方式获取文件描述符的就绪状态(主动通知)<br>2.采用红黑树管理epoll_event结构体<br>3.内核维护一个就绪队列，只传出就绪的文件描述符<br>4.有ET(边缘触发)和LT(水平触发)，而select和poll都只有LT<br>5.同样也突破了select并发量的限制</p>","more":"<h2 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h2><h4 id=\"内核事件表\"><a href=\"#内核事件表\" class=\"headerlink\" title=\"内核事件表\"></a>内核事件表</h4><p>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表，不同于select、poll每次调用都要重复传入文件描述符集或事件集，因此epoll需要一个额外的文件描述符来唯一标识内核中的这个事件表，这个文件描述符用epoll_create函数来创建。</p>\n<p><strong>int epoll_create(int size)</strong>；</p>\n<p>size参数现在不起作用，只是给内核一个提示，告诉它内核事件表需要多大，该函数返回的文件描述符将作用于其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表</p>\n<p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</strong></p>\n<p>epfd：为epoll_creat的句柄<br>op：表示动作，用3个宏来表示：</p>\n<ul>\n<li>EPOLL_CTL_ADD(注册新的fd到epfd)</li>\n<li>EPOLL_CTL_MOD(修改已经注册的fd的监听事件)</li>\n<li>EPOLL_CTL_DEL(从epfd删除一个fd)</li>\n</ul>\n<p>event：告诉内核需要监听的事件<br>struct epoll_event{<br>​　　　　__uint32_t events;    //监控的事件<br>​　　　　epoll_data_t data;  //用户数据<br>};<br>epoll支持的事件类型和poll基本相同，表示epoll事件类型的宏是在poll对应的宏前加上“E”，但epoll有两个额外的事件类型(EPOLLET和EPOLLONESHOT)，这两个宏对于epoll的高效运作很重要。</p>\n<p>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>\n<p>typedef union epoll_data {<br>​　　　　void        *ptr;     //指定与fd相关的用户数据<br>​　　　　int          fd;<br>​　　　　uint32_t     u32;<br>​　　　　uint64_t     u64;<br>} epoll_data_t;</p>\n<p><strong>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</strong></p>\n<p>成功返回就绪的文件描述符个数，失败返回-1并设置errno</p>\n<p>epoll_wait函数如果检测到事件，就将所有就绪的时间从内核事件表中复制到它的第二个参数events指向的数组，这个数组只用于输出epoll_wait检测到的就绪事件，而不像select、poll的数组参数既用于传入用户注册事件，又用于输出内核检测到的就绪事件，这就大大提高了应用程序索引就绪文件描述符的效率。</p>\n<p>对于select、poll，需要遍历整个数组找出就绪的文件描述符，然后判断是什么类型的事件发生  O(n)</p>\n<p>对于epoll,数组中的所有文件描述符都是就绪的，直接可以判断是什么类型的事件发生  O(1)</p>\n<h2 id=\"ET和LT\"><a href=\"#ET和LT\" class=\"headerlink\" title=\"ET和LT\"></a>ET和LT</h2><p>LT是默认的工作模式，这种模式下epoll相当于一个效率较高的poll.<br>当epoll内核事件表宏注册了一个文件描述符EPOLLET时，采用ET模式<br>LT：只要一个文件描述符上的事件一次没有处理完，会在以后调用epoll_wait时次次返回就绪<br>ET：只返回一个就绪，不管处理完还是没有处理完</p>\n<p>举个例子:<br>1.某个客户端向服务器传输了2KB的数据<br>2.服务器epoll_wait()返回，然后读了1KB<br>3.两种模式比较</p>\n<ul>\n<li>如果是LT模式下，下次epoll_wait()还会返回，然后继续读，直到数据被处理完毕</li>\n<li>如果是ET模式下，下次epoll_wait()会阻塞，因此ET模式只适用于非阻塞的socket，需要循环读取保证所有数据被处理完毕。</li>\n<li>设置非阻塞 1.socket创建指定选项 2.fcntl 3.iocnlsocket</li>\n</ul>\n<p>ET模式很大程序上降低了同一个epoll事件被重复触发的次数，效率更高。但是LT能保证数据读取完整，ET读取数据如果被信号打断，可能读取不全。</p>\n<p>对于监听的 sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上。如果非要使用边缘触发，可以用 while 来循环 accept()。</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/et_lt.cpp\" target=\"_blank\" rel=\"noopener\">ET和LT</a></p>\n<h4 id=\"为什么ET模式下socket要设置成非阻塞？\"><a href=\"#为什么ET模式下socket要设置成非阻塞？\" class=\"headerlink\" title=\"为什么ET模式下socket要设置成非阻塞？\"></a>为什么ET模式下socket要设置成非阻塞？</h4><p>如果是阻塞 connfd 的边缘触发，如果不一次性读取一个事件上的数据，会干扰下一个事件，所以必须在读取数据的外部套一层循环，这样才能完整的处理数据。但是外层套循环之后会导致另外一个问题：处理完数据之后，程序会一直卡在 recv() 函数上，因为是阻塞 IO，如果没数据可读，它会一直等在那里，直到有数据可读。但是这个时候，如果用另一个客户端去连接服务器，服务器就不能受理这个新的客户端了。</p>\n<p>如果是非阻塞 connfd 的边缘触发，和阻塞版本一样，必须在读取数据的外部套一层循环，这样才能完整的处理数据。因为非阻塞 IO 如果没有数据可读时，会立即返回，并设置 errno。这里我们根据 EAGAIN 和EWOULDBLOCK 来判断数据是否全部读取完毕了，如果读取完毕，就会正常退出循环了。</p>\n<h2 id=\"EPOLLONESHOT-Linux高性能服务器编程P157\"><a href=\"#EPOLLONESHOT-Linux高性能服务器编程P157\" class=\"headerlink\" title=\"EPOLLONESHOT (Linux高性能服务器编程P157)\"></a>EPOLLONESHOT (Linux高性能服务器编程P157)</h2><p>即使我们使用ET模式，那一个socket上的事件也有可能被触发多次，这在并发程序中会引起一个问题。比如一个线程读取socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读，此时另外一个线程来读取这些数据，于是就出现了两个线程同时操作一个socket的情况。而我们期望一个socket连接在任意时刻都只被一个线程处理，这一点我们可以用EPOLLONESHOT事件实现。</p>\n<p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其注册的读、写、异常中的一个，并且只触发一次，除非重新用epoll_ctl重置该文件描述符的EPOLLONESHOT事件。因此，每次处理完都需要立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，EPOLLIN能被触发。</p>\n<p><strong>注意：监听socket上不能注册EPOLLONESHOT，否则只能处理一个客户端的连接</strong></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/epoll_oneshot.cpp\" target=\"_blank\" rel=\"noopener\">EPOLLONESHOT</a></p>\n<h4 id=\"对于EPOLLOUT事件的一些理解\"><a href=\"#对于EPOLLOUT事件的一些理解\" class=\"headerlink\" title=\"对于EPOLLOUT事件的一些理解\"></a>对于EPOLLOUT事件的一些理解</h4><p>在一次发送大量数据（超过发送缓冲区大小）的情况下，如果使用阻塞方式，程序一直阻塞，直到所有的数据都写入到缓冲区中。例如，要发送M字节数据，套接字发送缓冲区大小为B字节，只有当对端向本机返回ack表明其接收到大于等于M-B字节时，才意味着所有的数据都写入到缓冲区中。很明显，如果一次发送的数据量非常大，比如M=10GB、B=64KB，则：1）一次发送过程中本机线程会在一个fd上阻塞相当长一段时间，其他fd得不到及时处理；2）如果出现发送失败，无从得知到底有多少数据发送成功，应用程序只能选择重新发送这10G数据，结合考虑网络的稳定性，只能呵呵；<br>总之，上述两点都是无法接受的。因此，对性能有要求的服务器一般不采用阻塞而采用非阻塞。</p>\n<p>采用非阻塞套接字一次发送大量数据的流程：</p>\n<ul>\n<li><p>1.使劲往发送缓冲区中写数据，直到返回不可写</p>\n</li>\n<li><p>2.等待下一次缓冲区可写</p>\n</li>\n<li><p>3.要发送的数据写完</p>\n<p>其中2可以有两种方式</p>\n<ul>\n<li>查询式，程序不停地查询是否可写</li>\n<li>程序去干其他的事情（多路分离器的优在），等出现可写事件后再接着写；很明显方式b）更加优雅</li>\n</ul>\n</li>\n</ul>\n<p>例如需要将一个10G大小的文件返回给用户，那么简单send这个文件是不会成功的。<br>这个场景下，send 10G的数据，send返回值不会是10G，而是大约256k，表示你只成功写入了256k的数据。接着调用send，send就会返回EAGAIN，告诉你socket的缓冲区已经满了，此时无法继续send,需要重新注册EPOLLOUT事件，进行新一轮的监听。<br>此时异步程序的正确处理流程是调用epoll_wait，当socket缓冲区中的数据被对方接收之后，缓冲区就会有空闲空间可以继续接收数据，此时epoll_wait就会返回这个socket的EPOLLOUT事件，获得这个事件时，你就可以继续往socket中写出数据。</p>\n<p>EPOLLOUT事件就是以事件的方式通知用户程序，可以继续往缓冲区写数据了。</p>\n<h2 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h2><p>缺点：<br>1.在高并发高活跃的情况下，对内部树进行频繁的操作，效率可能不如select和poll<br>2.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。</p>\n<p>优点:<br>1.非常适用于高并发低活跃的情况下<br>2.采用回调函数的方式传出fd，高效<br>3.直接传出就绪的文件描述符，减少了索引就绪文件描述符的时间</p>\n<p>4.真正突破了文件描述符的限制，不采用轮询，不会因为fd数量的增长而导致效率下降<br>5.有ET工作模型和EPOLLONESHOT，进一步提升了工作效率</p>\n<h2 id=\"LT工作模型下的服务器-客户端同多进程模型\"><a href=\"#LT工作模型下的服务器-客户端同多进程模型\" class=\"headerlink\" title=\"LT工作模型下的服务器(客户端同多进程模型)\"></a>LT工作模型下的服务器(客户端同多进程模型)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;stdio.h&gt;</span><br><span class=\"line\">#include&lt;ctype.h&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;unistd.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;types.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;epoll.h&gt;</span><br><span class=\"line\">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#define PORT       1234</span><br><span class=\"line\">#define LISTEN     128</span><br><span class=\"line\">#define IP         16</span><br><span class=\"line\">#define BUFSIZE    1500</span><br><span class=\"line\">#define MAXSIZE    200000</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstruct sockaddr_in addr,clientaddr;</span><br><span class=\"line\">\tchar ip[IP] &#x3D; &#123;0&#125;;</span><br><span class=\"line\">\tbzero(&amp;addr,sizeof(addr));</span><br><span class=\"line\"></span><br><span class=\"line\">\taddr.sin_family &#x3D; AF_INET;</span><br><span class=\"line\">\taddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</span><br><span class=\"line\">\taddr.sin_port &#x3D; htons(PORT)\t;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tint Serverfd;</span><br><span class=\"line\">\tServerfd &#x3D; socket(AF_INET,SOCK_STREAM,0);</span><br><span class=\"line\">\tif(Serverfd  &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\tperror(&quot;Socket Create Faile&quot;);</span><br><span class=\"line\">\t\texit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprintf(&quot;Serverfd:%d\\n&quot;,Serverfd);</span><br><span class=\"line\">\tif(-1 &#x3D;&#x3D; bind(Serverfd,(struct sockaddr*)&amp;addr,sizeof(addr)))&#123;</span><br><span class=\"line\">\t\tperror(&quot;BIND ERROR&quot;);</span><br><span class=\"line\">\t\texit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(-1 &#x3D;&#x3D; listen(Serverfd,LISTEN))&#123;</span><br><span class=\"line\">\t\tperror(&quot;LISTEN ERROR&quot;);</span><br><span class=\"line\">\t\texit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(&quot;epoll Server is running\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct epoll_event ent[MAXSIZE];</span><br><span class=\"line\">\tstruct epoll_event tmp;</span><br><span class=\"line\">\tint epfd,ready,nlen;</span><br><span class=\"line\">\tchar buf[BUFSIZE];</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor(int i &#x3D; 0;i&lt;MAXSIZE;i++)&#123;</span><br><span class=\"line\">\t\tent[i].data.fd &#x3D; -1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tepfd &#x3D; epoll_create(MAXSIZE);    &#x2F;&#x2F;红黑树</span><br><span class=\"line\"></span><br><span class=\"line\">\ttmp.data.fd &#x3D; Serverfd;</span><br><span class=\"line\">\ttmp.events &#x3D; EPOLLIN;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tepoll_ctl(epfd,EPOLL_CTL_ADD,Serverfd,&amp;tmp);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tready &#x3D; epoll_wait(epfd,ent,MAXSIZE,-1);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\twhile(ready)&#123;</span><br><span class=\"line\">\t\t\tif(ent[--ready].data.fd &#x3D;&#x3D; Serverfd)&#123;</span><br><span class=\"line\">\t\t\t\tint Clientfd;</span><br><span class=\"line\">\t\t\t\tint nlen &#x3D; sizeof(clientaddr);</span><br><span class=\"line\">\t\t\t\tClientfd &#x3D; accept(Serverfd,(struct sockaddr*)&amp;clientaddr,&amp;nlen);</span><br><span class=\"line\">\t\t\t\tif(Clientfd &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\t\t\tperror(&quot;Accpet Error&quot;);</span><br><span class=\"line\">\t\t\t\t\texit(-1);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\telse&#123;</span><br><span class=\"line\">\t\t\t\t\tinet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,ip,sizeof(ip));</span><br><span class=\"line\">\t\t\t\t\tprintf(&quot;IP:%s Port:%d Clientfd:%d\\n&quot;,ip,clientaddr.sin_port,Clientfd);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\ttmp.data.fd &#x3D; Clientfd;</span><br><span class=\"line\">\t\t\t\t\ttmp.events &#x3D; EPOLLIN;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tepoll_ctl(epfd,EPOLL_CTL_ADD,Clientfd,&amp;tmp);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse&#123;</span><br><span class=\"line\">\t\t\t\tif(ent[ready].data.fd !&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\t\t\tnlen &#x3D; read(ent[ready].data.fd,buf,sizeof(buf));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\tif(0 &#x3D;&#x3D; nlen)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tepoll_ctl(epfd,EPOLL_CTL_DEL,ent[ready].data.fd,NULL);</span><br><span class=\"line\">\t\t\t\t\t\tclose(ent[ready].data.fd);</span><br><span class=\"line\">\t\t\t\t\t\tprintf(&quot;Clientfd:%d客户端终止\\n&quot;,ent[ready].data.fd);</span><br><span class=\"line\">\t\t\t\t\t\tent[ready].data.fd &#x3D; -1;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\telse&#123;</span><br><span class=\"line\">\t\t\t\t\t\tfor(int i &#x3D; 0;i&lt;nlen;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tbuf[i] &#x3D;toupper(buf[i]);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\twrite(ent[ready].data.fd,buf,nlen);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclose(Serverfd);</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Windows下的线程同步","date":"2018-11-07T11:02:33.000Z","_content":"\n## 引言\n\n线程可以共享进程的资源，这是一件很好的事情，便于线程之间通信。但是，同时对全局资源进行操作，也容易造成一些问题。例如，两根线程同时对一个全局变量进行++操作，假如初值为0，线程A加1000次，线程B加1000次，结果很有可能不是我们想象中的2000。因为某个线程加完之后还没写入内存，另一根线程就读出了之前的数，这就会造成加的次数减少，导致最后的值小于2000。这是个很简单的例子，但是警示我们在多线程编程中，同时操作全局资源，要注意线程同步的问题。\n<!-- more -->\n\n## 线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。\n\n## Windows下线程互斥和同步的方式\n\n​互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的  访问顺序，即访问是无序的。\n\n​同步: 在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源，如“第一类读写者模型”。\n\n​同步包括互斥，互斥其实是一种特殊的同步\n\n1. **原子访问**     利用Interlocked系列函数    只能对一个变量进行原子操作\n\n- 增减操作    返回变量执行增减操作之后的值\n\n​InterlockedIncrement\n\n​InterlockedDecrement\n\n​ InterlockedExchangeAdd 返回运算后的值，注意！加个负数就是减。\n\n- 赋值操作\n\n​InterlockedExchange函数会返回原先的值。\n\n2. **关键段(临界区) **  让多行代码以原子方式对资源进行操作   CRITICAL_SECTION (结构体)\n\n​初始化:InitializeCriticalSection               销毁:  DeleteCriticalSection\n​进入：EnterCriticalSection                     离开：LeaveCriticalSection\n​尝试进入：TryEnterCriticalSection\n​初始化旋转锁:  InitializeCriticalSectionAndSpinCoun\n​设置旋转锁次数:SetCriticalSectionSpinCount\n\n- 直接阻塞     \n  ​\t对于一个线程在访问临界区，别的想要访问的线程会从用户态切到内核态，一旦那个线程离开，阻塞的线程就切换到可调度状态，这样来回切换状态开销大，效率不高\n\n- 旋转锁    拿不到锁不马上阻塞，而是等待一段时间再阻塞\n- 异步处理  TryEnter   尝试着拿锁，拿不到就处理别的工作\n\n注意点:如果在关键段中途离开，离开之前需要解开关键段。\n\n3. **互斥量** 内核对象  通过句柄操作   配合 WaitForSingleObject使用\n\n互斥对象包含使用计数、线程ID以及一个递归计数(占有互斥量的次数)\n创建:CreateMutex\n进入:WaitForSingleObject  等互斥量\n释放:ReleaseMutex\n跨进程操作:OpenMutex    通过创建时候的最后一个参数：名字\n\n\n4. **事件** 内核对象 通过句柄操作\n\n创建:CreateEvent    注意创建的是人工事件还是自动事件，初始化是有事件还是没有事件\n进入:WaitForSingleObject  等事件  如果是自动事件自动变成无事件，如果是人工，需要手动置成无事件  \n设置成有事件:SetEvent       设置成无事件:ResetEvent\n跨进程操作:OpenEvent\n\n​注意点：如果是人工事件，设置成有信号不变回去的话，所有的线程都能共享资源。适合通知的场合，如果    需要线程之间互斥，则设置成自动事件。\n\n5.  **信号量** 内核对象  通过句柄操作\n创建:CreateSemaphore    注意初始化的信号量个数以及信号量的最大值(不一定是线程个数，看情况而定)\n​进入:WaitForSingleObject    等信号量\n​释放:ReleaseSemaphore\n​跨进程操作:OpenSemaphore\n​注意点:1.一次释放信号量个数不允许超过最大值2.分多次释放信号量，如果总和超过最大值，就取最大值\n\n## 误区\n\nvolatile并不能实现线程同步，只是防止编译优化，每次都要求从内存中读取值。\n\n### 它们之间的区别\n\n码一个整理得不错的[博客](https://blog.csdn.net/morewindows/article/details/7538247)\n\n原子访问局限性比较大，只能作用于变量，因此使用范围不是很广泛。\n\n关键段只能在同一个进程中实现线程同步，而其余三个内核对象都可以实现跨进程。如果是同一进程中进行线程同步，建议用临界区，因为更节省系统资源，更有效率，因为关键段是用户模式下的同步对象内核对象的缺点是性能。要从用户态切换到内核态，开销大。有线程所有权概念，可以实现互斥，但实现不了同步。\n\n互斥量有线程所有权，谁创建谁有优先选择权，可以实现互斥，实现不了同步。能很好地处理\"遗弃\"问题\n\n“遗弃”问题就是占有某种资源的进程意外终止后，其它等待该资源的进程能否感知\n\n事件有人工事件，可以同时让多个线程做事，但是指定不了个数，而信号量可以指定个数\n\n\n\n","source":"_posts/Windows下的线程同步.md","raw":"---\ntitle: Windows下的线程同步\ndate: 2018-11-07 19:02:33\ntags: \n- 操作系统\n- Windows\n---\n\n## 引言\n\n线程可以共享进程的资源，这是一件很好的事情，便于线程之间通信。但是，同时对全局资源进行操作，也容易造成一些问题。例如，两根线程同时对一个全局变量进行++操作，假如初值为0，线程A加1000次，线程B加1000次，结果很有可能不是我们想象中的2000。因为某个线程加完之后还没写入内存，另一根线程就读出了之前的数，这就会造成加的次数减少，导致最后的值小于2000。这是个很简单的例子，但是警示我们在多线程编程中，同时操作全局资源，要注意线程同步的问题。\n<!-- more -->\n\n## 线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。\n\n## Windows下线程互斥和同步的方式\n\n​互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的  访问顺序，即访问是无序的。\n\n​同步: 在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源，如“第一类读写者模型”。\n\n​同步包括互斥，互斥其实是一种特殊的同步\n\n1. **原子访问**     利用Interlocked系列函数    只能对一个变量进行原子操作\n\n- 增减操作    返回变量执行增减操作之后的值\n\n​InterlockedIncrement\n\n​InterlockedDecrement\n\n​ InterlockedExchangeAdd 返回运算后的值，注意！加个负数就是减。\n\n- 赋值操作\n\n​InterlockedExchange函数会返回原先的值。\n\n2. **关键段(临界区) **  让多行代码以原子方式对资源进行操作   CRITICAL_SECTION (结构体)\n\n​初始化:InitializeCriticalSection               销毁:  DeleteCriticalSection\n​进入：EnterCriticalSection                     离开：LeaveCriticalSection\n​尝试进入：TryEnterCriticalSection\n​初始化旋转锁:  InitializeCriticalSectionAndSpinCoun\n​设置旋转锁次数:SetCriticalSectionSpinCount\n\n- 直接阻塞     \n  ​\t对于一个线程在访问临界区，别的想要访问的线程会从用户态切到内核态，一旦那个线程离开，阻塞的线程就切换到可调度状态，这样来回切换状态开销大，效率不高\n\n- 旋转锁    拿不到锁不马上阻塞，而是等待一段时间再阻塞\n- 异步处理  TryEnter   尝试着拿锁，拿不到就处理别的工作\n\n注意点:如果在关键段中途离开，离开之前需要解开关键段。\n\n3. **互斥量** 内核对象  通过句柄操作   配合 WaitForSingleObject使用\n\n互斥对象包含使用计数、线程ID以及一个递归计数(占有互斥量的次数)\n创建:CreateMutex\n进入:WaitForSingleObject  等互斥量\n释放:ReleaseMutex\n跨进程操作:OpenMutex    通过创建时候的最后一个参数：名字\n\n\n4. **事件** 内核对象 通过句柄操作\n\n创建:CreateEvent    注意创建的是人工事件还是自动事件，初始化是有事件还是没有事件\n进入:WaitForSingleObject  等事件  如果是自动事件自动变成无事件，如果是人工，需要手动置成无事件  \n设置成有事件:SetEvent       设置成无事件:ResetEvent\n跨进程操作:OpenEvent\n\n​注意点：如果是人工事件，设置成有信号不变回去的话，所有的线程都能共享资源。适合通知的场合，如果    需要线程之间互斥，则设置成自动事件。\n\n5.  **信号量** 内核对象  通过句柄操作\n创建:CreateSemaphore    注意初始化的信号量个数以及信号量的最大值(不一定是线程个数，看情况而定)\n​进入:WaitForSingleObject    等信号量\n​释放:ReleaseSemaphore\n​跨进程操作:OpenSemaphore\n​注意点:1.一次释放信号量个数不允许超过最大值2.分多次释放信号量，如果总和超过最大值，就取最大值\n\n## 误区\n\nvolatile并不能实现线程同步，只是防止编译优化，每次都要求从内存中读取值。\n\n### 它们之间的区别\n\n码一个整理得不错的[博客](https://blog.csdn.net/morewindows/article/details/7538247)\n\n原子访问局限性比较大，只能作用于变量，因此使用范围不是很广泛。\n\n关键段只能在同一个进程中实现线程同步，而其余三个内核对象都可以实现跨进程。如果是同一进程中进行线程同步，建议用临界区，因为更节省系统资源，更有效率，因为关键段是用户模式下的同步对象内核对象的缺点是性能。要从用户态切换到内核态，开销大。有线程所有权概念，可以实现互斥，但实现不了同步。\n\n互斥量有线程所有权，谁创建谁有优先选择权，可以实现互斥，实现不了同步。能很好地处理\"遗弃\"问题\n\n“遗弃”问题就是占有某种资源的进程意外终止后，其它等待该资源的进程能否感知\n\n事件有人工事件，可以同时让多个线程做事，但是指定不了个数，而信号量可以指定个数\n\n\n\n","slug":"Windows下的线程同步","published":1,"updated":"2021-12-06T05:30:36.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7f000k96caf2s4c20d","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>线程可以共享进程的资源，这是一件很好的事情，便于线程之间通信。但是，同时对全局资源进行操作，也容易造成一些问题。例如，两根线程同时对一个全局变量进行++操作，假如初值为0，线程A加1000次，线程B加1000次，结果很有可能不是我们想象中的2000。因为某个线程加完之后还没写入内存，另一根线程就读出了之前的数，这就会造成加的次数减少，导致最后的值小于2000。这是个很简单的例子，但是警示我们在多线程编程中，同时操作全局资源，要注意线程同步的问题。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。\"><a href=\"#线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。\" class=\"headerlink\" title=\"线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。\"></a>线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。</h2><h2 id=\"Windows下线程互斥和同步的方式\"><a href=\"#Windows下线程互斥和同步的方式\" class=\"headerlink\" title=\"Windows下线程互斥和同步的方式\"></a>Windows下线程互斥和同步的方式</h2><p>​互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的  访问顺序，即访问是无序的。</p>\n<p>​同步: 在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源，如“第一类读写者模型”。</p>\n<p>​同步包括互斥，互斥其实是一种特殊的同步</p>\n<ol>\n<li><strong>原子访问</strong>     利用Interlocked系列函数    只能对一个变量进行原子操作</li>\n</ol>\n<ul>\n<li>增减操作    返回变量执行增减操作之后的值</li>\n</ul>\n<p>​InterlockedIncrement</p>\n<p>​InterlockedDecrement</p>\n<p>​ InterlockedExchangeAdd 返回运算后的值，注意！加个负数就是减。</p>\n<ul>\n<li>赋值操作</li>\n</ul>\n<p>​InterlockedExchange函数会返回原先的值。</p>\n<ol start=\"2\">\n<li>*<em>关键段(临界区) *</em>  让多行代码以原子方式对资源进行操作   CRITICAL_SECTION (结构体)</li>\n</ol>\n<p>​初始化:InitializeCriticalSection               销毁:  DeleteCriticalSection<br>​进入：EnterCriticalSection                     离开：LeaveCriticalSection<br>​尝试进入：TryEnterCriticalSection<br>​初始化旋转锁:  InitializeCriticalSectionAndSpinCoun<br>​设置旋转锁次数:SetCriticalSectionSpinCount</p>\n<ul>\n<li><p>直接阻塞<br>​    对于一个线程在访问临界区，别的想要访问的线程会从用户态切到内核态，一旦那个线程离开，阻塞的线程就切换到可调度状态，这样来回切换状态开销大，效率不高</p>\n</li>\n<li><p>旋转锁    拿不到锁不马上阻塞，而是等待一段时间再阻塞</p>\n</li>\n<li><p>异步处理  TryEnter   尝试着拿锁，拿不到就处理别的工作</p>\n</li>\n</ul>\n<p>注意点:如果在关键段中途离开，离开之前需要解开关键段。</p>\n<ol start=\"3\">\n<li><strong>互斥量</strong> 内核对象  通过句柄操作   配合 WaitForSingleObject使用</li>\n</ol>\n<p>互斥对象包含使用计数、线程ID以及一个递归计数(占有互斥量的次数)<br>创建:CreateMutex<br>进入:WaitForSingleObject  等互斥量<br>释放:ReleaseMutex<br>跨进程操作:OpenMutex    通过创建时候的最后一个参数：名字</p>\n<ol start=\"4\">\n<li><strong>事件</strong> 内核对象 通过句柄操作</li>\n</ol>\n<p>创建:CreateEvent    注意创建的是人工事件还是自动事件，初始化是有事件还是没有事件<br>进入:WaitForSingleObject  等事件  如果是自动事件自动变成无事件，如果是人工，需要手动置成无事件<br>设置成有事件:SetEvent       设置成无事件:ResetEvent<br>跨进程操作:OpenEvent</p>\n<p>​注意点：如果是人工事件，设置成有信号不变回去的话，所有的线程都能共享资源。适合通知的场合，如果    需要线程之间互斥，则设置成自动事件。</p>\n<ol start=\"5\">\n<li><strong>信号量</strong> 内核对象  通过句柄操作<br>创建:CreateSemaphore    注意初始化的信号量个数以及信号量的最大值(不一定是线程个数，看情况而定)<br>​进入:WaitForSingleObject    等信号量<br>​释放:ReleaseSemaphore<br>​跨进程操作:OpenSemaphore<br>​注意点:1.一次释放信号量个数不允许超过最大值2.分多次释放信号量，如果总和超过最大值，就取最大值</li>\n</ol>\n<h2 id=\"误区\"><a href=\"#误区\" class=\"headerlink\" title=\"误区\"></a>误区</h2><p>volatile并不能实现线程同步，只是防止编译优化，每次都要求从内存中读取值。</p>\n<h3 id=\"它们之间的区别\"><a href=\"#它们之间的区别\" class=\"headerlink\" title=\"它们之间的区别\"></a>它们之间的区别</h3><p>码一个整理得不错的<a href=\"https://blog.csdn.net/morewindows/article/details/7538247\" target=\"_blank\" rel=\"noopener\">博客</a></p>\n<p>原子访问局限性比较大，只能作用于变量，因此使用范围不是很广泛。</p>\n<p>关键段只能在同一个进程中实现线程同步，而其余三个内核对象都可以实现跨进程。如果是同一进程中进行线程同步，建议用临界区，因为更节省系统资源，更有效率，因为关键段是用户模式下的同步对象内核对象的缺点是性能。要从用户态切换到内核态，开销大。有线程所有权概念，可以实现互斥，但实现不了同步。</p>\n<p>互斥量有线程所有权，谁创建谁有优先选择权，可以实现互斥，实现不了同步。能很好地处理”遗弃”问题</p>\n<p>“遗弃”问题就是占有某种资源的进程意外终止后，其它等待该资源的进程能否感知</p>\n<p>事件有人工事件，可以同时让多个线程做事，但是指定不了个数，而信号量可以指定个数</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>线程可以共享进程的资源，这是一件很好的事情，便于线程之间通信。但是，同时对全局资源进行操作，也容易造成一些问题。例如，两根线程同时对一个全局变量进行++操作，假如初值为0，线程A加1000次，线程B加1000次，结果很有可能不是我们想象中的2000。因为某个线程加完之后还没写入内存，另一根线程就读出了之前的数，这就会造成加的次数减少，导致最后的值小于2000。这是个很简单的例子，但是警示我们在多线程编程中，同时操作全局资源，要注意线程同步的问题。</p>","more":"<h2 id=\"线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。\"><a href=\"#线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。\" class=\"headerlink\" title=\"线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。\"></a>线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。</h2><h2 id=\"Windows下线程互斥和同步的方式\"><a href=\"#Windows下线程互斥和同步的方式\" class=\"headerlink\" title=\"Windows下线程互斥和同步的方式\"></a>Windows下线程互斥和同步的方式</h2><p>​互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的  访问顺序，即访问是无序的。</p>\n<p>​同步: 在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源，如“第一类读写者模型”。</p>\n<p>​同步包括互斥，互斥其实是一种特殊的同步</p>\n<ol>\n<li><strong>原子访问</strong>     利用Interlocked系列函数    只能对一个变量进行原子操作</li>\n</ol>\n<ul>\n<li>增减操作    返回变量执行增减操作之后的值</li>\n</ul>\n<p>​InterlockedIncrement</p>\n<p>​InterlockedDecrement</p>\n<p>​ InterlockedExchangeAdd 返回运算后的值，注意！加个负数就是减。</p>\n<ul>\n<li>赋值操作</li>\n</ul>\n<p>​InterlockedExchange函数会返回原先的值。</p>\n<ol start=\"2\">\n<li>*<em>关键段(临界区) *</em>  让多行代码以原子方式对资源进行操作   CRITICAL_SECTION (结构体)</li>\n</ol>\n<p>​初始化:InitializeCriticalSection               销毁:  DeleteCriticalSection<br>​进入：EnterCriticalSection                     离开：LeaveCriticalSection<br>​尝试进入：TryEnterCriticalSection<br>​初始化旋转锁:  InitializeCriticalSectionAndSpinCoun<br>​设置旋转锁次数:SetCriticalSectionSpinCount</p>\n<ul>\n<li><p>直接阻塞<br>​    对于一个线程在访问临界区，别的想要访问的线程会从用户态切到内核态，一旦那个线程离开，阻塞的线程就切换到可调度状态，这样来回切换状态开销大，效率不高</p>\n</li>\n<li><p>旋转锁    拿不到锁不马上阻塞，而是等待一段时间再阻塞</p>\n</li>\n<li><p>异步处理  TryEnter   尝试着拿锁，拿不到就处理别的工作</p>\n</li>\n</ul>\n<p>注意点:如果在关键段中途离开，离开之前需要解开关键段。</p>\n<ol start=\"3\">\n<li><strong>互斥量</strong> 内核对象  通过句柄操作   配合 WaitForSingleObject使用</li>\n</ol>\n<p>互斥对象包含使用计数、线程ID以及一个递归计数(占有互斥量的次数)<br>创建:CreateMutex<br>进入:WaitForSingleObject  等互斥量<br>释放:ReleaseMutex<br>跨进程操作:OpenMutex    通过创建时候的最后一个参数：名字</p>\n<ol start=\"4\">\n<li><strong>事件</strong> 内核对象 通过句柄操作</li>\n</ol>\n<p>创建:CreateEvent    注意创建的是人工事件还是自动事件，初始化是有事件还是没有事件<br>进入:WaitForSingleObject  等事件  如果是自动事件自动变成无事件，如果是人工，需要手动置成无事件<br>设置成有事件:SetEvent       设置成无事件:ResetEvent<br>跨进程操作:OpenEvent</p>\n<p>​注意点：如果是人工事件，设置成有信号不变回去的话，所有的线程都能共享资源。适合通知的场合，如果    需要线程之间互斥，则设置成自动事件。</p>\n<ol start=\"5\">\n<li><strong>信号量</strong> 内核对象  通过句柄操作<br>创建:CreateSemaphore    注意初始化的信号量个数以及信号量的最大值(不一定是线程个数，看情况而定)<br>​进入:WaitForSingleObject    等信号量<br>​释放:ReleaseSemaphore<br>​跨进程操作:OpenSemaphore<br>​注意点:1.一次释放信号量个数不允许超过最大值2.分多次释放信号量，如果总和超过最大值，就取最大值</li>\n</ol>\n<h2 id=\"误区\"><a href=\"#误区\" class=\"headerlink\" title=\"误区\"></a>误区</h2><p>volatile并不能实现线程同步，只是防止编译优化，每次都要求从内存中读取值。</p>\n<h3 id=\"它们之间的区别\"><a href=\"#它们之间的区别\" class=\"headerlink\" title=\"它们之间的区别\"></a>它们之间的区别</h3><p>码一个整理得不错的<a href=\"https://blog.csdn.net/morewindows/article/details/7538247\" target=\"_blank\" rel=\"noopener\">博客</a></p>\n<p>原子访问局限性比较大，只能作用于变量，因此使用范围不是很广泛。</p>\n<p>关键段只能在同一个进程中实现线程同步，而其余三个内核对象都可以实现跨进程。如果是同一进程中进行线程同步，建议用临界区，因为更节省系统资源，更有效率，因为关键段是用户模式下的同步对象内核对象的缺点是性能。要从用户态切换到内核态，开销大。有线程所有权概念，可以实现互斥，但实现不了同步。</p>\n<p>互斥量有线程所有权，谁创建谁有优先选择权，可以实现互斥，实现不了同步。能很好地处理”遗弃”问题</p>\n<p>“遗弃”问题就是占有某种资源的进程意外终止后，其它等待该资源的进程能否感知</p>\n<p>事件有人工事件，可以同时让多个线程做事，但是指定不了个数，而信号量可以指定个数</p>"},{"title":"Variadic Templates","date":"2019-04-25T06:22:25.000Z","_content":"\n记录一下可变模板参数的使用方法。(C++ Primer p619)\n\n用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class...或typename...指出接下来的参数表示零个或者多个类型的列表。\n\n先来看一个例子\n\n```\nvoid print(){}\ntemplate <typename T,typename...Types>\nvoid print(const T& firstArg,const Types&...args){\n    cout<<firstArg<<endl;\n    print(args...);   //recursive\n}\n\nint main(){\n   print(7.5, \"hello\", bitset<16>(100), 42); \n}\n\n//最终输出\n7.5\nhello\n0000000001100100\n42\n```\n\n...叫做一个所谓的pack(包)\n\nTypes是模板参数包，args是函数参数包，都表示零个或多个参数\n\n注意点：\n\n- 三次...的位置的区别，语法规范\n- 第一行单写的一个print是递归终止的条件，很关键。对于主函数中调用的print，传入的参数是4个，对于可变模板方法而言是1个和其他，就把第一个输出，把其他三个传入print，再把第一个输出，把其他两个传入print，再把第一个输出，其他一个传入print，再把第一个输出，其他零个传入print，这时候就调用第一行的print。\n\n进一步思考：\n\n```\ntemplate <typename...Types>\nvoid print(const Types&...args){\n   //...\n}\n```\n\n这个可变参数模板函数能和上面的共存吗？\n\n按照正常的理解，假如传入print的参数个数是5个，既可以被看成1个和4个，也可以被看成5个，这会造成歧义。但实际上编译时可以通过的。\n\n经过测试，调用的是1个和其他个的版本，至于原因，以后补上。\n\n通过sizeof...运算符可以知道包中元素的个数。\n\n```\ntemplate <typename...Types>\nvoid print(const Types&...args){\n    cout<<sizeof...(Types)<<endl;\n    cout<<sizeof...(args)<<endl;\n}\n```\n\n","source":"_posts/Variadic-Templates.md","raw":"---\ntitle: Variadic Templates\ndate: 2019-04-25 14:22:25\ntags:\n- C++\n- C++11\n---\n\n记录一下可变模板参数的使用方法。(C++ Primer p619)\n\n用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class...或typename...指出接下来的参数表示零个或者多个类型的列表。\n\n先来看一个例子\n\n```\nvoid print(){}\ntemplate <typename T,typename...Types>\nvoid print(const T& firstArg,const Types&...args){\n    cout<<firstArg<<endl;\n    print(args...);   //recursive\n}\n\nint main(){\n   print(7.5, \"hello\", bitset<16>(100), 42); \n}\n\n//最终输出\n7.5\nhello\n0000000001100100\n42\n```\n\n...叫做一个所谓的pack(包)\n\nTypes是模板参数包，args是函数参数包，都表示零个或多个参数\n\n注意点：\n\n- 三次...的位置的区别，语法规范\n- 第一行单写的一个print是递归终止的条件，很关键。对于主函数中调用的print，传入的参数是4个，对于可变模板方法而言是1个和其他，就把第一个输出，把其他三个传入print，再把第一个输出，把其他两个传入print，再把第一个输出，其他一个传入print，再把第一个输出，其他零个传入print，这时候就调用第一行的print。\n\n进一步思考：\n\n```\ntemplate <typename...Types>\nvoid print(const Types&...args){\n   //...\n}\n```\n\n这个可变参数模板函数能和上面的共存吗？\n\n按照正常的理解，假如传入print的参数个数是5个，既可以被看成1个和4个，也可以被看成5个，这会造成歧义。但实际上编译时可以通过的。\n\n经过测试，调用的是1个和其他个的版本，至于原因，以后补上。\n\n通过sizeof...运算符可以知道包中元素的个数。\n\n```\ntemplate <typename...Types>\nvoid print(const Types&...args){\n    cout<<sizeof...(Types)<<endl;\n    cout<<sizeof...(args)<<endl;\n}\n```\n\n","slug":"Variadic-Templates","published":1,"updated":"2021-12-06T05:30:36.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7g000m96cac9bsdw3t","content":"<p>记录一下可变模板参数的使用方法。(C++ Primer p619)</p>\n<p>用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class…或typename…指出接下来的参数表示零个或者多个类型的列表。</p>\n<p>先来看一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void print()&#123;&#125;</span><br><span class=\"line\">template &lt;typename T,typename...Types&gt;</span><br><span class=\"line\">void print(const T&amp; firstArg,const Types&amp;...args)&#123;</span><br><span class=\"line\">    cout&lt;&lt;firstArg&lt;&lt;endl;</span><br><span class=\"line\">    print(args...);   &#x2F;&#x2F;recursive</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">   print(7.5, &quot;hello&quot;, bitset&lt;16&gt;(100), 42); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;最终输出</span><br><span class=\"line\">7.5</span><br><span class=\"line\">hello</span><br><span class=\"line\">0000000001100100</span><br><span class=\"line\">42</span><br></pre></td></tr></table></figure>\n\n<p>…叫做一个所谓的pack(包)</p>\n<p>Types是模板参数包，args是函数参数包，都表示零个或多个参数</p>\n<p>注意点：</p>\n<ul>\n<li>三次…的位置的区别，语法规范</li>\n<li>第一行单写的一个print是递归终止的条件，很关键。对于主函数中调用的print，传入的参数是4个，对于可变模板方法而言是1个和其他，就把第一个输出，把其他三个传入print，再把第一个输出，把其他两个传入print，再把第一个输出，其他一个传入print，再把第一个输出，其他零个传入print，这时候就调用第一行的print。</li>\n</ul>\n<p>进一步思考：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename...Types&gt;</span><br><span class=\"line\">void print(const Types&amp;...args)&#123;</span><br><span class=\"line\">   &#x2F;&#x2F;...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个可变参数模板函数能和上面的共存吗？</p>\n<p>按照正常的理解，假如传入print的参数个数是5个，既可以被看成1个和4个，也可以被看成5个，这会造成歧义。但实际上编译时可以通过的。</p>\n<p>经过测试，调用的是1个和其他个的版本，至于原因，以后补上。</p>\n<p>通过sizeof…运算符可以知道包中元素的个数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename...Types&gt;</span><br><span class=\"line\">void print(const Types&amp;...args)&#123;</span><br><span class=\"line\">    cout&lt;&lt;sizeof...(Types)&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;sizeof...(args)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>记录一下可变模板参数的使用方法。(C++ Primer p619)</p>\n<p>用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class…或typename…指出接下来的参数表示零个或者多个类型的列表。</p>\n<p>先来看一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void print()&#123;&#125;</span><br><span class=\"line\">template &lt;typename T,typename...Types&gt;</span><br><span class=\"line\">void print(const T&amp; firstArg,const Types&amp;...args)&#123;</span><br><span class=\"line\">    cout&lt;&lt;firstArg&lt;&lt;endl;</span><br><span class=\"line\">    print(args...);   &#x2F;&#x2F;recursive</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">   print(7.5, &quot;hello&quot;, bitset&lt;16&gt;(100), 42); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;最终输出</span><br><span class=\"line\">7.5</span><br><span class=\"line\">hello</span><br><span class=\"line\">0000000001100100</span><br><span class=\"line\">42</span><br></pre></td></tr></table></figure>\n\n<p>…叫做一个所谓的pack(包)</p>\n<p>Types是模板参数包，args是函数参数包，都表示零个或多个参数</p>\n<p>注意点：</p>\n<ul>\n<li>三次…的位置的区别，语法规范</li>\n<li>第一行单写的一个print是递归终止的条件，很关键。对于主函数中调用的print，传入的参数是4个，对于可变模板方法而言是1个和其他，就把第一个输出，把其他三个传入print，再把第一个输出，把其他两个传入print，再把第一个输出，其他一个传入print，再把第一个输出，其他零个传入print，这时候就调用第一行的print。</li>\n</ul>\n<p>进一步思考：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename...Types&gt;</span><br><span class=\"line\">void print(const Types&amp;...args)&#123;</span><br><span class=\"line\">   &#x2F;&#x2F;...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个可变参数模板函数能和上面的共存吗？</p>\n<p>按照正常的理解，假如传入print的参数个数是5个，既可以被看成1个和4个，也可以被看成5个，这会造成歧义。但实际上编译时可以通过的。</p>\n<p>经过测试，调用的是1个和其他个的版本，至于原因，以后补上。</p>\n<p>通过sizeof…运算符可以知道包中元素的个数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename...Types&gt;</span><br><span class=\"line\">void print(const Types&amp;...args)&#123;</span><br><span class=\"line\">    cout&lt;&lt;sizeof...(Types)&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;sizeof...(args)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Windows下的线程","date":"2018-11-06T13:08:17.000Z","_content":"\n## 线程介绍\n\n进程中的执行单元，线程是最小的调度单位，进程是最小的分配资源的单元。\n换言之，就是线程是进程的一部分，帮进程干事情，cpu调度的是线程，而不是进程，进程只提供一块空间。\n特点:1.轻量2.可并发执行3.切换开销小4.共享进程资源，也有自己特有的线程堆栈和内核对象\n因为线程共享进程的资源很多，例如进程的地址空间、打开文件、定时器、信号量、全局、静态变量等\n，拥有的系统资源很少，因此很轻量，从而上下文切换的开销很小。\n\n<!-- more -->\n## 什么时候需要使用线程？\n\n在同一个进程中，需要完成不同的工作，又不想因为某个工作阻塞而影响别的工作的时候，就将不同的工作放在不同的线程，并发的执行，这样既可以提高程序吞吐量又可以改善响应时间。\n\n## 线程状态转换\n\n![线程状态图](/pic/线程状态图.png)\n\n其中可运行也称为就绪。\n就绪->运行   获得cpu时间片\n运行->就绪   cpu时间片耗尽\n运行->阻塞 1.等待I/O操作发生2.sleep3.试图获得锁4.等待事件 \n阻塞->就绪 1.I/O操作完成2.sleep时间到了3.成功获得锁4.事件触发\n\n那么为什么不能从阻塞到运行以及就绪到阻塞呢？\n\n## 线程构成\n\n1.线程堆栈(函数中的局部变量和函数参数)，线程退出时释放\n2.内核对象(Windows核心编程第三章有对这个概念深入的介绍)   \n\n![线程内核对象](/pic/线程内核对象.png)\n\n这里主要关注内核对象中的使用次数(计数器)、暂停次数(挂起计数器)、信号(已通知=FALSE)\n\n使用次数初始值为2，线程退出时减1，关闭句柄的时候减1，为0时释放内核对象\n\n暂停次数初始值为1，在创建线程时判断是否有挂起标志，没有的话再置为0\n\n信号初始值为FALSE，线程退出时变为TRUE，一般用WiatForSingleObject()检测是否有信号，从而判断线程是否正常退出\n\n## 线程的常用函数\n\n### 创建\n\nCreateThread和_beginthreadex     创建成功返回句柄\n参数就不罗列了，有安全属性，线程栈大小，线程函数入口地址，传入参数，创建标志，线程ID\n\n**这里着重强调一下两者的区别**(介意使用后者)\n前者是Windows函数，后者是C/C++运行期库函数，主要的区别在于对于系统全局变量的影响上。\n比如C运行库全局变量errno，在系统函数出错时进行赋值，如果是多线程编程，很容易造成值覆盖的问题。\n\n```\nif(/*某个系统函数调用出错*/){\n\tswitch(errno){\n        //错误处理函数\n\t}\n}\n```\n\n假如线程A运行到if和switch之间，时间片用完了，这时候errno已经被赋值，但是还没进入switch的时候被切换掉了，此时同一进程的线程B运行时某个函数改动了errno，当线程A重新切换到运行态的时候，errno的值已经不是预想的了。因此要避免这种多线程访问修改导致数据覆盖的问题。\n\nCreateThread没有办法解决这个问题，_beginthreadex在创建新线程时会分配并初始化一个_tiddata块。这个_tiddata块自然是用来存放一些需要线程独享的数据。事实上新线程运行时会首先将_tiddata块与自己进一步关联起来,从而接下里调用标准C运行库函数进行操作时就只会改变线程自身数据块的值。\n\n注意点：1.通过句柄操作线程，线程退出时要记得关闭句柄\n​　　　　2.无法连着两次关闭句柄\n​　　　　3.创建之后关闭了句柄，线程还在，只是无法操作线程了。\n\n### 挂起、唤醒\n\nSuspendThread、ResumeThread\n注意:1.每挂起一次，内核对象的挂起计数器就加1，为0时线程才工作，因此挂起多少次，就要唤醒对应次数\n​　　 2.对于一个尚未挂起的线程进行唤醒是无用的操作。\n\n### 死亡\n\n1.函数返回  return   这是最好的方式\n2.ExitThread   _endthreadex  最好使用后者       这两个函数只能销毁自身，释放堆栈\n3.TerminateThread  强制杀死任意线程   不安全  不释放资源\n4.包含线程的进程退出   \n\n### 将线程函数作为类成员函数需要注意的问题？\n\n要定义成静态成员变量。因为非静态成员函数都会在参数列表中加上一个this指针为为参数,线程处理函数相当于变成DWORD WINAPI ThreadFun(LPVOID, CMyClass *this) ，这和标准的线程函数就不匹配了，编译就通不过。况且，如果是非静态成员函数，不定义类对象或者指针就无法调用，一旦对象生命期结束了，难道线程函数就无法调用了？因此要脱离类本身存在，定义成静态的(相当于一个全局函数)。\n\n\n\n\n\n","source":"_posts/Windows下的线程.md","raw":"---\ntitle: Windows下的线程\ndate: 2018-11-06 21:08:17\ntags: \n- 操作系统\n- Windows\n---\n\n## 线程介绍\n\n进程中的执行单元，线程是最小的调度单位，进程是最小的分配资源的单元。\n换言之，就是线程是进程的一部分，帮进程干事情，cpu调度的是线程，而不是进程，进程只提供一块空间。\n特点:1.轻量2.可并发执行3.切换开销小4.共享进程资源，也有自己特有的线程堆栈和内核对象\n因为线程共享进程的资源很多，例如进程的地址空间、打开文件、定时器、信号量、全局、静态变量等\n，拥有的系统资源很少，因此很轻量，从而上下文切换的开销很小。\n\n<!-- more -->\n## 什么时候需要使用线程？\n\n在同一个进程中，需要完成不同的工作，又不想因为某个工作阻塞而影响别的工作的时候，就将不同的工作放在不同的线程，并发的执行，这样既可以提高程序吞吐量又可以改善响应时间。\n\n## 线程状态转换\n\n![线程状态图](/pic/线程状态图.png)\n\n其中可运行也称为就绪。\n就绪->运行   获得cpu时间片\n运行->就绪   cpu时间片耗尽\n运行->阻塞 1.等待I/O操作发生2.sleep3.试图获得锁4.等待事件 \n阻塞->就绪 1.I/O操作完成2.sleep时间到了3.成功获得锁4.事件触发\n\n那么为什么不能从阻塞到运行以及就绪到阻塞呢？\n\n## 线程构成\n\n1.线程堆栈(函数中的局部变量和函数参数)，线程退出时释放\n2.内核对象(Windows核心编程第三章有对这个概念深入的介绍)   \n\n![线程内核对象](/pic/线程内核对象.png)\n\n这里主要关注内核对象中的使用次数(计数器)、暂停次数(挂起计数器)、信号(已通知=FALSE)\n\n使用次数初始值为2，线程退出时减1，关闭句柄的时候减1，为0时释放内核对象\n\n暂停次数初始值为1，在创建线程时判断是否有挂起标志，没有的话再置为0\n\n信号初始值为FALSE，线程退出时变为TRUE，一般用WiatForSingleObject()检测是否有信号，从而判断线程是否正常退出\n\n## 线程的常用函数\n\n### 创建\n\nCreateThread和_beginthreadex     创建成功返回句柄\n参数就不罗列了，有安全属性，线程栈大小，线程函数入口地址，传入参数，创建标志，线程ID\n\n**这里着重强调一下两者的区别**(介意使用后者)\n前者是Windows函数，后者是C/C++运行期库函数，主要的区别在于对于系统全局变量的影响上。\n比如C运行库全局变量errno，在系统函数出错时进行赋值，如果是多线程编程，很容易造成值覆盖的问题。\n\n```\nif(/*某个系统函数调用出错*/){\n\tswitch(errno){\n        //错误处理函数\n\t}\n}\n```\n\n假如线程A运行到if和switch之间，时间片用完了，这时候errno已经被赋值，但是还没进入switch的时候被切换掉了，此时同一进程的线程B运行时某个函数改动了errno，当线程A重新切换到运行态的时候，errno的值已经不是预想的了。因此要避免这种多线程访问修改导致数据覆盖的问题。\n\nCreateThread没有办法解决这个问题，_beginthreadex在创建新线程时会分配并初始化一个_tiddata块。这个_tiddata块自然是用来存放一些需要线程独享的数据。事实上新线程运行时会首先将_tiddata块与自己进一步关联起来,从而接下里调用标准C运行库函数进行操作时就只会改变线程自身数据块的值。\n\n注意点：1.通过句柄操作线程，线程退出时要记得关闭句柄\n​　　　　2.无法连着两次关闭句柄\n​　　　　3.创建之后关闭了句柄，线程还在，只是无法操作线程了。\n\n### 挂起、唤醒\n\nSuspendThread、ResumeThread\n注意:1.每挂起一次，内核对象的挂起计数器就加1，为0时线程才工作，因此挂起多少次，就要唤醒对应次数\n​　　 2.对于一个尚未挂起的线程进行唤醒是无用的操作。\n\n### 死亡\n\n1.函数返回  return   这是最好的方式\n2.ExitThread   _endthreadex  最好使用后者       这两个函数只能销毁自身，释放堆栈\n3.TerminateThread  强制杀死任意线程   不安全  不释放资源\n4.包含线程的进程退出   \n\n### 将线程函数作为类成员函数需要注意的问题？\n\n要定义成静态成员变量。因为非静态成员函数都会在参数列表中加上一个this指针为为参数,线程处理函数相当于变成DWORD WINAPI ThreadFun(LPVOID, CMyClass *this) ，这和标准的线程函数就不匹配了，编译就通不过。况且，如果是非静态成员函数，不定义类对象或者指针就无法调用，一旦对象生命期结束了，难道线程函数就无法调用了？因此要脱离类本身存在，定义成静态的(相当于一个全局函数)。\n\n\n\n\n\n","slug":"Windows下的线程","published":1,"updated":"2021-12-06T05:30:36.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7h000p96cahe3nea1c","content":"<h2 id=\"线程介绍\"><a href=\"#线程介绍\" class=\"headerlink\" title=\"线程介绍\"></a>线程介绍</h2><p>进程中的执行单元，线程是最小的调度单位，进程是最小的分配资源的单元。<br>换言之，就是线程是进程的一部分，帮进程干事情，cpu调度的是线程，而不是进程，进程只提供一块空间。<br>特点:1.轻量2.可并发执行3.切换开销小4.共享进程资源，也有自己特有的线程堆栈和内核对象<br>因为线程共享进程的资源很多，例如进程的地址空间、打开文件、定时器、信号量、全局、静态变量等<br>，拥有的系统资源很少，因此很轻量，从而上下文切换的开销很小。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么时候需要使用线程？\"><a href=\"#什么时候需要使用线程？\" class=\"headerlink\" title=\"什么时候需要使用线程？\"></a>什么时候需要使用线程？</h2><p>在同一个进程中，需要完成不同的工作，又不想因为某个工作阻塞而影响别的工作的时候，就将不同的工作放在不同的线程，并发的执行，这样既可以提高程序吞吐量又可以改善响应时间。</p>\n<h2 id=\"线程状态转换\"><a href=\"#线程状态转换\" class=\"headerlink\" title=\"线程状态转换\"></a>线程状态转换</h2><p><img src=\"/pic/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png\" alt=\"线程状态图\"></p>\n<p>其中可运行也称为就绪。<br>就绪-&gt;运行   获得cpu时间片<br>运行-&gt;就绪   cpu时间片耗尽<br>运行-&gt;阻塞 1.等待I/O操作发生2.sleep3.试图获得锁4.等待事件<br>阻塞-&gt;就绪 1.I/O操作完成2.sleep时间到了3.成功获得锁4.事件触发</p>\n<p>那么为什么不能从阻塞到运行以及就绪到阻塞呢？</p>\n<h2 id=\"线程构成\"><a href=\"#线程构成\" class=\"headerlink\" title=\"线程构成\"></a>线程构成</h2><p>1.线程堆栈(函数中的局部变量和函数参数)，线程退出时释放<br>2.内核对象(Windows核心编程第三章有对这个概念深入的介绍)   </p>\n<p><img src=\"/pic/%E7%BA%BF%E7%A8%8B%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1.png\" alt=\"线程内核对象\"></p>\n<p>这里主要关注内核对象中的使用次数(计数器)、暂停次数(挂起计数器)、信号(已通知=FALSE)</p>\n<p>使用次数初始值为2，线程退出时减1，关闭句柄的时候减1，为0时释放内核对象</p>\n<p>暂停次数初始值为1，在创建线程时判断是否有挂起标志，没有的话再置为0</p>\n<p>信号初始值为FALSE，线程退出时变为TRUE，一般用WiatForSingleObject()检测是否有信号，从而判断线程是否正常退出</p>\n<h2 id=\"线程的常用函数\"><a href=\"#线程的常用函数\" class=\"headerlink\" title=\"线程的常用函数\"></a>线程的常用函数</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>CreateThread和_beginthreadex     创建成功返回句柄<br>参数就不罗列了，有安全属性，线程栈大小，线程函数入口地址，传入参数，创建标志，线程ID</p>\n<p><strong>这里着重强调一下两者的区别</strong>(介意使用后者)<br>前者是Windows函数，后者是C/C++运行期库函数，主要的区别在于对于系统全局变量的影响上。<br>比如C运行库全局变量errno，在系统函数出错时进行赋值，如果是多线程编程，很容易造成值覆盖的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(&#x2F;*某个系统函数调用出错*&#x2F;)&#123;</span><br><span class=\"line\">\tswitch(errno)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;错误处理函数</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假如线程A运行到if和switch之间，时间片用完了，这时候errno已经被赋值，但是还没进入switch的时候被切换掉了，此时同一进程的线程B运行时某个函数改动了errno，当线程A重新切换到运行态的时候，errno的值已经不是预想的了。因此要避免这种多线程访问修改导致数据覆盖的问题。</p>\n<p>CreateThread没有办法解决这个问题，_beginthreadex在创建新线程时会分配并初始化一个_tiddata块。这个_tiddata块自然是用来存放一些需要线程独享的数据。事实上新线程运行时会首先将_tiddata块与自己进一步关联起来,从而接下里调用标准C运行库函数进行操作时就只会改变线程自身数据块的值。</p>\n<p>注意点：1.通过句柄操作线程，线程退出时要记得关闭句柄<br>​　　　　2.无法连着两次关闭句柄<br>​　　　　3.创建之后关闭了句柄，线程还在，只是无法操作线程了。</p>\n<h3 id=\"挂起、唤醒\"><a href=\"#挂起、唤醒\" class=\"headerlink\" title=\"挂起、唤醒\"></a>挂起、唤醒</h3><p>SuspendThread、ResumeThread<br>注意:1.每挂起一次，内核对象的挂起计数器就加1，为0时线程才工作，因此挂起多少次，就要唤醒对应次数<br>​　　 2.对于一个尚未挂起的线程进行唤醒是无用的操作。</p>\n<h3 id=\"死亡\"><a href=\"#死亡\" class=\"headerlink\" title=\"死亡\"></a>死亡</h3><p>1.函数返回  return   这是最好的方式<br>2.ExitThread   _endthreadex  最好使用后者       这两个函数只能销毁自身，释放堆栈<br>3.TerminateThread  强制杀死任意线程   不安全  不释放资源<br>4.包含线程的进程退出   </p>\n<h3 id=\"将线程函数作为类成员函数需要注意的问题？\"><a href=\"#将线程函数作为类成员函数需要注意的问题？\" class=\"headerlink\" title=\"将线程函数作为类成员函数需要注意的问题？\"></a>将线程函数作为类成员函数需要注意的问题？</h3><p>要定义成静态成员变量。因为非静态成员函数都会在参数列表中加上一个this指针为为参数,线程处理函数相当于变成DWORD WINAPI ThreadFun(LPVOID, CMyClass *this) ，这和标准的线程函数就不匹配了，编译就通不过。况且，如果是非静态成员函数，不定义类对象或者指针就无法调用，一旦对象生命期结束了，难道线程函数就无法调用了？因此要脱离类本身存在，定义成静态的(相当于一个全局函数)。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"线程介绍\"><a href=\"#线程介绍\" class=\"headerlink\" title=\"线程介绍\"></a>线程介绍</h2><p>进程中的执行单元，线程是最小的调度单位，进程是最小的分配资源的单元。<br>换言之，就是线程是进程的一部分，帮进程干事情，cpu调度的是线程，而不是进程，进程只提供一块空间。<br>特点:1.轻量2.可并发执行3.切换开销小4.共享进程资源，也有自己特有的线程堆栈和内核对象<br>因为线程共享进程的资源很多，例如进程的地址空间、打开文件、定时器、信号量、全局、静态变量等<br>，拥有的系统资源很少，因此很轻量，从而上下文切换的开销很小。</p>","more":"<h2 id=\"什么时候需要使用线程？\"><a href=\"#什么时候需要使用线程？\" class=\"headerlink\" title=\"什么时候需要使用线程？\"></a>什么时候需要使用线程？</h2><p>在同一个进程中，需要完成不同的工作，又不想因为某个工作阻塞而影响别的工作的时候，就将不同的工作放在不同的线程，并发的执行，这样既可以提高程序吞吐量又可以改善响应时间。</p>\n<h2 id=\"线程状态转换\"><a href=\"#线程状态转换\" class=\"headerlink\" title=\"线程状态转换\"></a>线程状态转换</h2><p><img src=\"/pic/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png\" alt=\"线程状态图\"></p>\n<p>其中可运行也称为就绪。<br>就绪-&gt;运行   获得cpu时间片<br>运行-&gt;就绪   cpu时间片耗尽<br>运行-&gt;阻塞 1.等待I/O操作发生2.sleep3.试图获得锁4.等待事件<br>阻塞-&gt;就绪 1.I/O操作完成2.sleep时间到了3.成功获得锁4.事件触发</p>\n<p>那么为什么不能从阻塞到运行以及就绪到阻塞呢？</p>\n<h2 id=\"线程构成\"><a href=\"#线程构成\" class=\"headerlink\" title=\"线程构成\"></a>线程构成</h2><p>1.线程堆栈(函数中的局部变量和函数参数)，线程退出时释放<br>2.内核对象(Windows核心编程第三章有对这个概念深入的介绍)   </p>\n<p><img src=\"/pic/%E7%BA%BF%E7%A8%8B%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1.png\" alt=\"线程内核对象\"></p>\n<p>这里主要关注内核对象中的使用次数(计数器)、暂停次数(挂起计数器)、信号(已通知=FALSE)</p>\n<p>使用次数初始值为2，线程退出时减1，关闭句柄的时候减1，为0时释放内核对象</p>\n<p>暂停次数初始值为1，在创建线程时判断是否有挂起标志，没有的话再置为0</p>\n<p>信号初始值为FALSE，线程退出时变为TRUE，一般用WiatForSingleObject()检测是否有信号，从而判断线程是否正常退出</p>\n<h2 id=\"线程的常用函数\"><a href=\"#线程的常用函数\" class=\"headerlink\" title=\"线程的常用函数\"></a>线程的常用函数</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>CreateThread和_beginthreadex     创建成功返回句柄<br>参数就不罗列了，有安全属性，线程栈大小，线程函数入口地址，传入参数，创建标志，线程ID</p>\n<p><strong>这里着重强调一下两者的区别</strong>(介意使用后者)<br>前者是Windows函数，后者是C/C++运行期库函数，主要的区别在于对于系统全局变量的影响上。<br>比如C运行库全局变量errno，在系统函数出错时进行赋值，如果是多线程编程，很容易造成值覆盖的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(&#x2F;*某个系统函数调用出错*&#x2F;)&#123;</span><br><span class=\"line\">\tswitch(errno)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;错误处理函数</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假如线程A运行到if和switch之间，时间片用完了，这时候errno已经被赋值，但是还没进入switch的时候被切换掉了，此时同一进程的线程B运行时某个函数改动了errno，当线程A重新切换到运行态的时候，errno的值已经不是预想的了。因此要避免这种多线程访问修改导致数据覆盖的问题。</p>\n<p>CreateThread没有办法解决这个问题，_beginthreadex在创建新线程时会分配并初始化一个_tiddata块。这个_tiddata块自然是用来存放一些需要线程独享的数据。事实上新线程运行时会首先将_tiddata块与自己进一步关联起来,从而接下里调用标准C运行库函数进行操作时就只会改变线程自身数据块的值。</p>\n<p>注意点：1.通过句柄操作线程，线程退出时要记得关闭句柄<br>​　　　　2.无法连着两次关闭句柄<br>​　　　　3.创建之后关闭了句柄，线程还在，只是无法操作线程了。</p>\n<h3 id=\"挂起、唤醒\"><a href=\"#挂起、唤醒\" class=\"headerlink\" title=\"挂起、唤醒\"></a>挂起、唤醒</h3><p>SuspendThread、ResumeThread<br>注意:1.每挂起一次，内核对象的挂起计数器就加1，为0时线程才工作，因此挂起多少次，就要唤醒对应次数<br>​　　 2.对于一个尚未挂起的线程进行唤醒是无用的操作。</p>\n<h3 id=\"死亡\"><a href=\"#死亡\" class=\"headerlink\" title=\"死亡\"></a>死亡</h3><p>1.函数返回  return   这是最好的方式<br>2.ExitThread   _endthreadex  最好使用后者       这两个函数只能销毁自身，释放堆栈<br>3.TerminateThread  强制杀死任意线程   不安全  不释放资源<br>4.包含线程的进程退出   </p>\n<h3 id=\"将线程函数作为类成员函数需要注意的问题？\"><a href=\"#将线程函数作为类成员函数需要注意的问题？\" class=\"headerlink\" title=\"将线程函数作为类成员函数需要注意的问题？\"></a>将线程函数作为类成员函数需要注意的问题？</h3><p>要定义成静态成员变量。因为非静态成员函数都会在参数列表中加上一个this指针为为参数,线程处理函数相当于变成DWORD WINAPI ThreadFun(LPVOID, CMyClass *this) ，这和标准的线程函数就不匹配了，编译就通不过。况且，如果是非静态成员函数，不定义类对象或者指针就无法调用，一旦对象生命期结束了，难道线程函数就无法调用了？因此要脱离类本身存在，定义成静态的(相当于一个全局函数)。</p>"},{"title":"gdb调试","date":"2019-04-20T07:50:10.000Z","_content":"\ngdb是一个文件界面的调试工具，但是功能很强大。\n\n通过实战来熟悉一下常用操作。\n\n首先需要注意的是如果要用gdb调试，在编译的时候需要加上-g选项\n\n<!--more-->\n\n## 调试最基础的swap程序\n\n\n\n\n\n\n\n## gdb调试多进程程序\n\n- 单独调试子进程(attach)\n\n调试用例程序：[进程池实现的CGI服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/15_chapter/CGI_server.cpp)\n\n首先启动服务器\n\n![](/pic/CGI调试1.png)\n\n然后输入gdb启动gdb调试器，然后输入attach 子进程pid\n\n一开始attach失败了\n\n![](/pic/CGI调试2.png)\n\n根据错误信息的提示然后查阅资料，得知是内核参数/proc/sys/kernel/yama/ptrace_scope的原因\n\n要设置成0，才能attach成功。\n\n因此，采用临时修改的方式\n\n```\necho 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope\n```\n\n当然也可以在/etc/sysctl.d/10-ptrace.conf中修改从而永久有效\n\n```\nkernel.yama.ptrace_scope = 0\n```\n\n![](/pic/CGI调试3.png)\n\n下一步设置断点\n\n![](/pic/CGI调试4.png)\n\n接下来在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在断点处暂停了，并且使用bt查看堆栈调用。\n\n![](/pic/CGI调试5.png)\n\n- 使用调试器选项follow-fork-mode\n\ngdb调试器的选项follow-fork-mode允许我们选择程序执行fork系统调用后是继续调试父进程还是调试子进程。\n\n```\nset follow-fork-mode mode(parent/child)\n```\n\n还是使用上面的CGI程序进行调试，但是不同的是启动gdb调试的时候需要  gdb +程序文件名\n\n![](/pic/CGI调试6.png)\n\n接下来在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在断点处暂停了，并且使用bt查看堆栈调用。\n\n![](/pic/CGI调试7.png)\n\n## gdb调试多线程程序\n\ngdb有一组命令可辅助多线程程序的调试\n\n- info threads,显示当前可调试的所有线程.gdb会为每个线程分配一个ID，可以使用这个ID来操作对应的线程。ID前面有\"*\"号的线程是当前被调试的线程\n- thread ID,调试目标ID指定的线程\n- set scheduler-locking[off|on|step]。调试多线程程序时，默认除了被调试的线程在执行外，其他线程也继续执行。但有的时候我们希望只让被调试的线程运行，这可以通过这个命令实现。\n  - off表示不锁定任何线程，即所有线程都可以继续执行，这是默认值\n  - on表示只有当前被调试的线程会继续执行\n  - step表示在单步执行的时候，只有当前线程会执行\n\n调试用例程序：[多线程Web服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/tree/master/15_chapter/Web_server)\n\n分别设置父线程中的断点和子线程中的断点，然后启动程序\n\n![](/pic/Web调试1.png)\n\n然后在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在预期的断点处暂停了。并且查看线程信息，发现当前被调试的是主线程，ID是1\n\n![](/pic/Web调试2.png)\n\n紧接着设置scheduler-locking值为on，让其他线程不执行，锁定调试对象，然后逐步执行,最终重新阻塞在epoll_wait上，然后按crtl+C结束主线程\n\n![](/pic/Web调试3.png)\n\n然后切换到子线程进行调试，其ID为2\n\n![](/pic/Web调试4.png)\n\n这里用到了一个技巧，就是先将线程池创建的线程个数减少到1，来观察程序的逻辑是否正确，然后再逐步增加线程的数量进行调试。","source":"_posts/gdb调试.md","raw":"---\ntitle: gdb调试\ndate: 2019-04-20 15:50:10\ntags:\n- 常用工具\n- Linux高性能服务器编程\n---\n\ngdb是一个文件界面的调试工具，但是功能很强大。\n\n通过实战来熟悉一下常用操作。\n\n首先需要注意的是如果要用gdb调试，在编译的时候需要加上-g选项\n\n<!--more-->\n\n## 调试最基础的swap程序\n\n\n\n\n\n\n\n## gdb调试多进程程序\n\n- 单独调试子进程(attach)\n\n调试用例程序：[进程池实现的CGI服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/15_chapter/CGI_server.cpp)\n\n首先启动服务器\n\n![](/pic/CGI调试1.png)\n\n然后输入gdb启动gdb调试器，然后输入attach 子进程pid\n\n一开始attach失败了\n\n![](/pic/CGI调试2.png)\n\n根据错误信息的提示然后查阅资料，得知是内核参数/proc/sys/kernel/yama/ptrace_scope的原因\n\n要设置成0，才能attach成功。\n\n因此，采用临时修改的方式\n\n```\necho 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope\n```\n\n当然也可以在/etc/sysctl.d/10-ptrace.conf中修改从而永久有效\n\n```\nkernel.yama.ptrace_scope = 0\n```\n\n![](/pic/CGI调试3.png)\n\n下一步设置断点\n\n![](/pic/CGI调试4.png)\n\n接下来在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在断点处暂停了，并且使用bt查看堆栈调用。\n\n![](/pic/CGI调试5.png)\n\n- 使用调试器选项follow-fork-mode\n\ngdb调试器的选项follow-fork-mode允许我们选择程序执行fork系统调用后是继续调试父进程还是调试子进程。\n\n```\nset follow-fork-mode mode(parent/child)\n```\n\n还是使用上面的CGI程序进行调试，但是不同的是启动gdb调试的时候需要  gdb +程序文件名\n\n![](/pic/CGI调试6.png)\n\n接下来在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在断点处暂停了，并且使用bt查看堆栈调用。\n\n![](/pic/CGI调试7.png)\n\n## gdb调试多线程程序\n\ngdb有一组命令可辅助多线程程序的调试\n\n- info threads,显示当前可调试的所有线程.gdb会为每个线程分配一个ID，可以使用这个ID来操作对应的线程。ID前面有\"*\"号的线程是当前被调试的线程\n- thread ID,调试目标ID指定的线程\n- set scheduler-locking[off|on|step]。调试多线程程序时，默认除了被调试的线程在执行外，其他线程也继续执行。但有的时候我们希望只让被调试的线程运行，这可以通过这个命令实现。\n  - off表示不锁定任何线程，即所有线程都可以继续执行，这是默认值\n  - on表示只有当前被调试的线程会继续执行\n  - step表示在单步执行的时候，只有当前线程会执行\n\n调试用例程序：[多线程Web服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/tree/master/15_chapter/Web_server)\n\n分别设置父线程中的断点和子线程中的断点，然后启动程序\n\n![](/pic/Web调试1.png)\n\n然后在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在预期的断点处暂停了。并且查看线程信息，发现当前被调试的是主线程，ID是1\n\n![](/pic/Web调试2.png)\n\n紧接着设置scheduler-locking值为on，让其他线程不执行，锁定调试对象，然后逐步执行,最终重新阻塞在epoll_wait上，然后按crtl+C结束主线程\n\n![](/pic/Web调试3.png)\n\n然后切换到子线程进行调试，其ID为2\n\n![](/pic/Web调试4.png)\n\n这里用到了一个技巧，就是先将线程池创建的线程个数减少到1，来观察程序的逻辑是否正确，然后再逐步增加线程的数量进行调试。","slug":"gdb调试","published":1,"updated":"2021-12-06T05:30:36.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7h000q96ca0dgv93u6","content":"<p>gdb是一个文件界面的调试工具，但是功能很强大。</p>\n<p>通过实战来熟悉一下常用操作。</p>\n<p>首先需要注意的是如果要用gdb调试，在编译的时候需要加上-g选项</p>\n<a id=\"more\"></a>\n\n<h2 id=\"调试最基础的swap程序\"><a href=\"#调试最基础的swap程序\" class=\"headerlink\" title=\"调试最基础的swap程序\"></a>调试最基础的swap程序</h2><h2 id=\"gdb调试多进程程序\"><a href=\"#gdb调试多进程程序\" class=\"headerlink\" title=\"gdb调试多进程程序\"></a>gdb调试多进程程序</h2><ul>\n<li>单独调试子进程(attach)</li>\n</ul>\n<p>调试用例程序：<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/15_chapter/CGI_server.cpp\" target=\"_blank\" rel=\"noopener\">进程池实现的CGI服务器</a></p>\n<p>首先启动服务器</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%951.png\" alt=\"\"></p>\n<p>然后输入gdb启动gdb调试器，然后输入attach 子进程pid</p>\n<p>一开始attach失败了</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%952.png\" alt=\"\"></p>\n<p>根据错误信息的提示然后查阅资料，得知是内核参数/proc/sys/kernel/yama/ptrace_scope的原因</p>\n<p>要设置成0，才能attach成功。</p>\n<p>因此，采用临时修改的方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 0 | sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope</span><br></pre></td></tr></table></figure>\n\n<p>当然也可以在/etc/sysctl.d/10-ptrace.conf中修改从而永久有效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel.yama.ptrace_scope &#x3D; 0</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%953.png\" alt=\"\"></p>\n<p>下一步设置断点</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%954.png\" alt=\"\"></p>\n<p>接下来在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在断点处暂停了，并且使用bt查看堆栈调用。</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%955.png\" alt=\"\"></p>\n<ul>\n<li>使用调试器选项follow-fork-mode</li>\n</ul>\n<p>gdb调试器的选项follow-fork-mode允许我们选择程序执行fork系统调用后是继续调试父进程还是调试子进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set follow-fork-mode mode(parent&#x2F;child)</span><br></pre></td></tr></table></figure>\n\n<p>还是使用上面的CGI程序进行调试，但是不同的是启动gdb调试的时候需要  gdb +程序文件名</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%956.png\" alt=\"\"></p>\n<p>接下来在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在断点处暂停了，并且使用bt查看堆栈调用。</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%957.png\" alt=\"\"></p>\n<h2 id=\"gdb调试多线程程序\"><a href=\"#gdb调试多线程程序\" class=\"headerlink\" title=\"gdb调试多线程程序\"></a>gdb调试多线程程序</h2><p>gdb有一组命令可辅助多线程程序的调试</p>\n<ul>\n<li>info threads,显示当前可调试的所有线程.gdb会为每个线程分配一个ID，可以使用这个ID来操作对应的线程。ID前面有”*”号的线程是当前被调试的线程</li>\n<li>thread ID,调试目标ID指定的线程</li>\n<li>set scheduler-locking[off|on|step]。调试多线程程序时，默认除了被调试的线程在执行外，其他线程也继续执行。但有的时候我们希望只让被调试的线程运行，这可以通过这个命令实现。<ul>\n<li>off表示不锁定任何线程，即所有线程都可以继续执行，这是默认值</li>\n<li>on表示只有当前被调试的线程会继续执行</li>\n<li>step表示在单步执行的时候，只有当前线程会执行</li>\n</ul>\n</li>\n</ul>\n<p>调试用例程序：<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/tree/master/15_chapter/Web_server\" target=\"_blank\" rel=\"noopener\">多线程Web服务器</a></p>\n<p>分别设置父线程中的断点和子线程中的断点，然后启动程序</p>\n<p><img src=\"/pic/Web%E8%B0%83%E8%AF%951.png\" alt=\"\"></p>\n<p>然后在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在预期的断点处暂停了。并且查看线程信息，发现当前被调试的是主线程，ID是1</p>\n<p><img src=\"/pic/Web%E8%B0%83%E8%AF%952.png\" alt=\"\"></p>\n<p>紧接着设置scheduler-locking值为on，让其他线程不执行，锁定调试对象，然后逐步执行,最终重新阻塞在epoll_wait上，然后按crtl+C结束主线程</p>\n<p><img src=\"/pic/Web%E8%B0%83%E8%AF%953.png\" alt=\"\"></p>\n<p>然后切换到子线程进行调试，其ID为2</p>\n<p><img src=\"/pic/Web%E8%B0%83%E8%AF%954.png\" alt=\"\"></p>\n<p>这里用到了一个技巧，就是先将线程池创建的线程个数减少到1，来观察程序的逻辑是否正确，然后再逐步增加线程的数量进行调试。</p>\n","site":{"data":{}},"excerpt":"<p>gdb是一个文件界面的调试工具，但是功能很强大。</p>\n<p>通过实战来熟悉一下常用操作。</p>\n<p>首先需要注意的是如果要用gdb调试，在编译的时候需要加上-g选项</p>","more":"<h2 id=\"调试最基础的swap程序\"><a href=\"#调试最基础的swap程序\" class=\"headerlink\" title=\"调试最基础的swap程序\"></a>调试最基础的swap程序</h2><h2 id=\"gdb调试多进程程序\"><a href=\"#gdb调试多进程程序\" class=\"headerlink\" title=\"gdb调试多进程程序\"></a>gdb调试多进程程序</h2><ul>\n<li>单独调试子进程(attach)</li>\n</ul>\n<p>调试用例程序：<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/15_chapter/CGI_server.cpp\" target=\"_blank\" rel=\"noopener\">进程池实现的CGI服务器</a></p>\n<p>首先启动服务器</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%951.png\" alt=\"\"></p>\n<p>然后输入gdb启动gdb调试器，然后输入attach 子进程pid</p>\n<p>一开始attach失败了</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%952.png\" alt=\"\"></p>\n<p>根据错误信息的提示然后查阅资料，得知是内核参数/proc/sys/kernel/yama/ptrace_scope的原因</p>\n<p>要设置成0，才能attach成功。</p>\n<p>因此，采用临时修改的方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 0 | sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope</span><br></pre></td></tr></table></figure>\n\n<p>当然也可以在/etc/sysctl.d/10-ptrace.conf中修改从而永久有效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel.yama.ptrace_scope &#x3D; 0</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%953.png\" alt=\"\"></p>\n<p>下一步设置断点</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%954.png\" alt=\"\"></p>\n<p>接下来在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在断点处暂停了，并且使用bt查看堆栈调用。</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%955.png\" alt=\"\"></p>\n<ul>\n<li>使用调试器选项follow-fork-mode</li>\n</ul>\n<p>gdb调试器的选项follow-fork-mode允许我们选择程序执行fork系统调用后是继续调试父进程还是调试子进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set follow-fork-mode mode(parent&#x2F;child)</span><br></pre></td></tr></table></figure>\n\n<p>还是使用上面的CGI程序进行调试，但是不同的是启动gdb调试的时候需要  gdb +程序文件名</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%956.png\" alt=\"\"></p>\n<p>接下来在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在断点处暂停了，并且使用bt查看堆栈调用。</p>\n<p><img src=\"/pic/CGI%E8%B0%83%E8%AF%957.png\" alt=\"\"></p>\n<h2 id=\"gdb调试多线程程序\"><a href=\"#gdb调试多线程程序\" class=\"headerlink\" title=\"gdb调试多线程程序\"></a>gdb调试多线程程序</h2><p>gdb有一组命令可辅助多线程程序的调试</p>\n<ul>\n<li>info threads,显示当前可调试的所有线程.gdb会为每个线程分配一个ID，可以使用这个ID来操作对应的线程。ID前面有”*”号的线程是当前被调试的线程</li>\n<li>thread ID,调试目标ID指定的线程</li>\n<li>set scheduler-locking[off|on|step]。调试多线程程序时，默认除了被调试的线程在执行外，其他线程也继续执行。但有的时候我们希望只让被调试的线程运行，这可以通过这个命令实现。<ul>\n<li>off表示不锁定任何线程，即所有线程都可以继续执行，这是默认值</li>\n<li>on表示只有当前被调试的线程会继续执行</li>\n<li>step表示在单步执行的时候，只有当前线程会执行</li>\n</ul>\n</li>\n</ul>\n<p>调试用例程序：<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/tree/master/15_chapter/Web_server\" target=\"_blank\" rel=\"noopener\">多线程Web服务器</a></p>\n<p>分别设置父线程中的断点和子线程中的断点，然后启动程序</p>\n<p><img src=\"/pic/Web%E8%B0%83%E8%AF%951.png\" alt=\"\"></p>\n<p>然后在另一个终端使用telnet 127.0.0.1 12345来连接服务器并发送一些数据，调试器就在预期的断点处暂停了。并且查看线程信息，发现当前被调试的是主线程，ID是1</p>\n<p><img src=\"/pic/Web%E8%B0%83%E8%AF%952.png\" alt=\"\"></p>\n<p>紧接着设置scheduler-locking值为on，让其他线程不执行，锁定调试对象，然后逐步执行,最终重新阻塞在epoll_wait上，然后按crtl+C结束主线程</p>\n<p><img src=\"/pic/Web%E8%B0%83%E8%AF%953.png\" alt=\"\"></p>\n<p>然后切换到子线程进行调试，其ID为2</p>\n<p><img src=\"/pic/Web%E8%B0%83%E8%AF%954.png\" alt=\"\"></p>\n<p>这里用到了一个技巧，就是先将线程池创建的线程个数减少到1，来观察程序的逻辑是否正确，然后再逐步增加线程的数量进行调试。</p>"},{"title":"linux下的多进程服务器模型","date":"2018-11-27T13:42:24.000Z","_content":"\n## 整体思路\n\n服务器端完成的工作是将客户端传来的字符串，小写变大写，再返回给客户端\n父进程负责accept，每来一个connect就fork出一个子进程专门处理对应客户端的请求。\n\n## 需要注意的问题\n1.fork子进程的时候继承父进程的文件描述符，需要关闭。\n2.客户端退出之后，对应的子进程也就终止，需要回收子进程。\n3.在回收子进程的过程中，利用信号捕捉SIGCHLD。在执行信号捕捉函数的时候，会导致accept调用失败。\n4.在多个子进程同时退出的时候，需要用waitpid循环回收。\n5.创建一根线程专门回收的时候，需要在主线程对SIGCHLD信号设置屏蔽字\n\n<!-- more -->\n\n## 服务器端代码\n\n```c\n#include<stdio.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<arpa/inet.h>\n#include<ctype.h>\n#include<pthread.h>\n#include<sys/wait.h>\n#include<signal.h>\n\nvoid mywait(int n)\n{\n\tpid_t wpid;\n\twhile((wpid = waitpid(-1,NULL,WNOHANG)) > 0){\n\t\tprintf(\"pid为%d的进程被回收\\n\",wpid);\n\t}\n}\n\n\nvoid* jobs(void* argv)\n{\n\t//捕捉信号   异步回收\n\tpthread_detach(pthread_self());\n\tstruct sigaction act,oldact;\n\tact.sa_handler = mywait;\n\tact.sa_flags = 0;\n\tsigemptyset(&act.sa_mask);\n\n\tsigaction(SIGCHLD,&act,&oldact);\n\n\twhile(1)\n\t\tsleep(1);\n}\n\n\nint main()\n{\n\tstruct sockaddr_in clientaddr;\n\tint addrsize;\n\tint ListenSock,ClientSock;\n\tchar ip[16];\n\tstruct sockaddr_in addr;\n\tbzero(&addr,sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(1234);\n\n\tListenSock = socket(AF_INET,SOCK_STREAM,0);\n\n\tif(ListenSock == -1){\n\t\tperror(\"SCOKET CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tif(bind(ListenSock,(struct sockaddr *)&addr,sizeof(addr)) == -1){\n\t\tperror(\"BIND CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tif(listen(ListenSock,128) == -1){\n        perror(\"LISTEN CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tprintf(\"Server is Running\\n\");\n\tchar buf[100];\n\tbzero(buf,sizeof(buf));\n\tpthread_t tid;\n\tpthread_create(&tid,NULL,jobs,NULL);   //创建一个线程回收\n\n    sigset_t set,oldset;\n    sigemptyset(&set);\n    sigaddset(&set,SIGCHLD);\n \tsigprocmask(SIG_BLOCK,&set,&oldset);\n\t\n\tint nRes;\n\tpid_t pid;\n\twhile(1){\n\t\taddrsize = sizeof(clientaddr);\n\t\tClientSock= accept(ListenSock,(struct sockaddr* )&clientaddr,&addrsize);\n\t\tif(ClientSock < 0){\n\t\t\tperror(\"ACCEPT ERROR\");\n\t\t\texit(-1);\n\t\t}\n\t\tpid = fork();\n\t\t//父进程\n\t\tif(pid > 0){\n\t\t\tinet_ntop(AF_INET,&clientaddr.sin_addr.s_addr,ip,sizeof(ip));\n\t\t\tprintf(\"IP:%s  Port:%d\\n\",ip,clientaddr.sin_port);\n\t\t\tclose(ClientSock);\n\t\t}\n\t\t//子进程\n\t\telse if(pid == 0){\n\t\t\tclose(ListenSock);\n\t\t\twhile(1){\n\t\t\t\tnRes = read(ClientSock,buf,sizeof(buf));\n\t\t\t\tif(nRes < 0){\n\t\t\t\t\tperror(\"READ ERROR\");\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\telse if(nRes == 0){//客户端写端关闭   read返回值为0 这个进程终止\n\t\t\t\t\tclose(ClientSock);\n\t\t\t\t\texit(-1);\n\t\t\t\t}\n\t\t\t\t//大小写转换\n\t\t\t\tfor(int i = 0;i<nRes;i++){\n\t\t\t\t\tbuf[i] = toupper(buf[i]);\n\t\t\t\t}\n\t\t\t\twrite(ClientSock,buf,nRes);\n\t\t\t\tbzero(buf,sizeof(buf));\n\t\t\t}\n\n\t\t}\n\t\telse{\n\t\t\tperror(\"FORK CALL FAILED\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\tclose(ListenSock);\n\treturn 0;\n}\n```\n\n#### 客户端代码\n\n```c\n#include<stdio.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<arpa/inet.h>\n\n\n#define SERVER_IP \"127.0.0.1\"\n#define PORT 1234\n\nint main()\n{\n\tstruct sockaddr_in addr;\n\tbzero(&addr,sizeof(addr));\n\taddr.sin_family = AF_INET;\n\tinet_pton(AF_INET,SERVER_IP,&addr.sin_addr.s_addr);\n\taddr.sin_port = htons(PORT);\n\n\tint ClientSock;\n\tClientSock = socket(AF_INET,SOCK_STREAM,0);\n\n\tif(ClientSock == -1)\n\t{\n\t\tperror(\"SCOKET CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\n\tif(-1 == connect(ClientSock,(struct sockaddr*)&addr,sizeof(addr)))\n\t{\n\t\tperror(\"CONNECT CALL FAILED\");\n\t\texit(-1);\n\t}\n\tchar buf[100];\n\t//scanf(\"%s\",buf);\n\tint nRes;\n\twhile(1)\n\t{\n\t\tfgets(buf,sizeof(buf),stdin);\n\t\t//send(ClientSock,buf,sizeof(buf),0);\n\t\twrite(ClientSock,buf,sizeof(buf));\n\n\t\tnRes = read(ClientSock,buf,sizeof(buf));\n\t\tif(nRes > 0)\n\t\t{\n\t\t\tprintf(\"%s\",buf);\n\t\t}\n\t\tbzero(buf,sizeof(buf));\n\t}\n\tclose(ClientSock);\n\n\treturn 0;\n}\n```\n\n","source":"_posts/linux下的多进程服务器模型.md","raw":"---\ntitle: linux下的多进程服务器模型\ndate: 2018-11-27 21:42:24\ntags: \n- 服务器模型\n- 进程\n- Linux\n---\n\n## 整体思路\n\n服务器端完成的工作是将客户端传来的字符串，小写变大写，再返回给客户端\n父进程负责accept，每来一个connect就fork出一个子进程专门处理对应客户端的请求。\n\n## 需要注意的问题\n1.fork子进程的时候继承父进程的文件描述符，需要关闭。\n2.客户端退出之后，对应的子进程也就终止，需要回收子进程。\n3.在回收子进程的过程中，利用信号捕捉SIGCHLD。在执行信号捕捉函数的时候，会导致accept调用失败。\n4.在多个子进程同时退出的时候，需要用waitpid循环回收。\n5.创建一根线程专门回收的时候，需要在主线程对SIGCHLD信号设置屏蔽字\n\n<!-- more -->\n\n## 服务器端代码\n\n```c\n#include<stdio.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<arpa/inet.h>\n#include<ctype.h>\n#include<pthread.h>\n#include<sys/wait.h>\n#include<signal.h>\n\nvoid mywait(int n)\n{\n\tpid_t wpid;\n\twhile((wpid = waitpid(-1,NULL,WNOHANG)) > 0){\n\t\tprintf(\"pid为%d的进程被回收\\n\",wpid);\n\t}\n}\n\n\nvoid* jobs(void* argv)\n{\n\t//捕捉信号   异步回收\n\tpthread_detach(pthread_self());\n\tstruct sigaction act,oldact;\n\tact.sa_handler = mywait;\n\tact.sa_flags = 0;\n\tsigemptyset(&act.sa_mask);\n\n\tsigaction(SIGCHLD,&act,&oldact);\n\n\twhile(1)\n\t\tsleep(1);\n}\n\n\nint main()\n{\n\tstruct sockaddr_in clientaddr;\n\tint addrsize;\n\tint ListenSock,ClientSock;\n\tchar ip[16];\n\tstruct sockaddr_in addr;\n\tbzero(&addr,sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(1234);\n\n\tListenSock = socket(AF_INET,SOCK_STREAM,0);\n\n\tif(ListenSock == -1){\n\t\tperror(\"SCOKET CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tif(bind(ListenSock,(struct sockaddr *)&addr,sizeof(addr)) == -1){\n\t\tperror(\"BIND CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tif(listen(ListenSock,128) == -1){\n        perror(\"LISTEN CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tprintf(\"Server is Running\\n\");\n\tchar buf[100];\n\tbzero(buf,sizeof(buf));\n\tpthread_t tid;\n\tpthread_create(&tid,NULL,jobs,NULL);   //创建一个线程回收\n\n    sigset_t set,oldset;\n    sigemptyset(&set);\n    sigaddset(&set,SIGCHLD);\n \tsigprocmask(SIG_BLOCK,&set,&oldset);\n\t\n\tint nRes;\n\tpid_t pid;\n\twhile(1){\n\t\taddrsize = sizeof(clientaddr);\n\t\tClientSock= accept(ListenSock,(struct sockaddr* )&clientaddr,&addrsize);\n\t\tif(ClientSock < 0){\n\t\t\tperror(\"ACCEPT ERROR\");\n\t\t\texit(-1);\n\t\t}\n\t\tpid = fork();\n\t\t//父进程\n\t\tif(pid > 0){\n\t\t\tinet_ntop(AF_INET,&clientaddr.sin_addr.s_addr,ip,sizeof(ip));\n\t\t\tprintf(\"IP:%s  Port:%d\\n\",ip,clientaddr.sin_port);\n\t\t\tclose(ClientSock);\n\t\t}\n\t\t//子进程\n\t\telse if(pid == 0){\n\t\t\tclose(ListenSock);\n\t\t\twhile(1){\n\t\t\t\tnRes = read(ClientSock,buf,sizeof(buf));\n\t\t\t\tif(nRes < 0){\n\t\t\t\t\tperror(\"READ ERROR\");\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\telse if(nRes == 0){//客户端写端关闭   read返回值为0 这个进程终止\n\t\t\t\t\tclose(ClientSock);\n\t\t\t\t\texit(-1);\n\t\t\t\t}\n\t\t\t\t//大小写转换\n\t\t\t\tfor(int i = 0;i<nRes;i++){\n\t\t\t\t\tbuf[i] = toupper(buf[i]);\n\t\t\t\t}\n\t\t\t\twrite(ClientSock,buf,nRes);\n\t\t\t\tbzero(buf,sizeof(buf));\n\t\t\t}\n\n\t\t}\n\t\telse{\n\t\t\tperror(\"FORK CALL FAILED\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\tclose(ListenSock);\n\treturn 0;\n}\n```\n\n#### 客户端代码\n\n```c\n#include<stdio.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<arpa/inet.h>\n\n\n#define SERVER_IP \"127.0.0.1\"\n#define PORT 1234\n\nint main()\n{\n\tstruct sockaddr_in addr;\n\tbzero(&addr,sizeof(addr));\n\taddr.sin_family = AF_INET;\n\tinet_pton(AF_INET,SERVER_IP,&addr.sin_addr.s_addr);\n\taddr.sin_port = htons(PORT);\n\n\tint ClientSock;\n\tClientSock = socket(AF_INET,SOCK_STREAM,0);\n\n\tif(ClientSock == -1)\n\t{\n\t\tperror(\"SCOKET CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\n\tif(-1 == connect(ClientSock,(struct sockaddr*)&addr,sizeof(addr)))\n\t{\n\t\tperror(\"CONNECT CALL FAILED\");\n\t\texit(-1);\n\t}\n\tchar buf[100];\n\t//scanf(\"%s\",buf);\n\tint nRes;\n\twhile(1)\n\t{\n\t\tfgets(buf,sizeof(buf),stdin);\n\t\t//send(ClientSock,buf,sizeof(buf),0);\n\t\twrite(ClientSock,buf,sizeof(buf));\n\n\t\tnRes = read(ClientSock,buf,sizeof(buf));\n\t\tif(nRes > 0)\n\t\t{\n\t\t\tprintf(\"%s\",buf);\n\t\t}\n\t\tbzero(buf,sizeof(buf));\n\t}\n\tclose(ClientSock);\n\n\treturn 0;\n}\n```\n\n","slug":"linux下的多进程服务器模型","published":1,"updated":"2021-12-06T05:30:36.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7i000s96ca5vgn4797","content":"<h2 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h2><p>服务器端完成的工作是将客户端传来的字符串，小写变大写，再返回给客户端<br>父进程负责accept，每来一个connect就fork出一个子进程专门处理对应客户端的请求。</p>\n<h2 id=\"需要注意的问题\"><a href=\"#需要注意的问题\" class=\"headerlink\" title=\"需要注意的问题\"></a>需要注意的问题</h2><p>1.fork子进程的时候继承父进程的文件描述符，需要关闭。<br>2.客户端退出之后，对应的子进程也就终止，需要回收子进程。<br>3.在回收子进程的过程中，利用信号捕捉SIGCHLD。在执行信号捕捉函数的时候，会导致accept调用失败。<br>4.在多个子进程同时退出的时候，需要用waitpid循环回收。<br>5.创建一根线程专门回收的时候，需要在主线程对SIGCHLD信号设置屏蔽字</p>\n<a id=\"more\"></a>\n\n<h2 id=\"服务器端代码\"><a href=\"#服务器端代码\" class=\"headerlink\" title=\"服务器端代码\"></a>服务器端代码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;ctype.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mywait</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> wpid;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>((wpid = waitpid(<span class=\"number\">-1</span>,<span class=\"literal\">NULL</span>,WNOHANG)) &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"pid为%d的进程被回收\\n\"</span>,wpid);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">jobs</span><span class=\"params\">(<span class=\"keyword\">void</span>* argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//捕捉信号   异步回收</span></span><br><span class=\"line\">\tpthread_detach(pthread_self());</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span>,<span class=\"title\">oldact</span>;</span></span><br><span class=\"line\">\tact.sa_handler = mywait;</span><br><span class=\"line\">\tact.sa_flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsigemptyset(&amp;act.sa_mask);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsigaction(SIGCHLD,&amp;act,&amp;oldact);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tsleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">clientaddr</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> addrsize;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ListenSock,ClientSock;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ip[<span class=\"number\">16</span>];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">addr</span>;</span></span><br><span class=\"line\">\tbzero(&amp;addr,<span class=\"keyword\">sizeof</span>(addr));</span><br><span class=\"line\">\taddr.sin_family = AF_INET;</span><br><span class=\"line\">\taddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">\taddr.sin_port = htons(<span class=\"number\">1234</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tListenSock = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ListenSock == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"SCOKET CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(bind(ListenSock,(struct sockaddr *)&amp;addr,<span class=\"keyword\">sizeof</span>(addr)) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"BIND CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">listen</span>(ListenSock,<span class=\"number\">128</span>) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"LISTEN CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Server is Running\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">100</span>];</span><br><span class=\"line\">\tbzero(buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t<span class=\"keyword\">pthread_t</span> tid;</span><br><span class=\"line\">\tpthread_create(&amp;tid,<span class=\"literal\">NULL</span>,jobs,<span class=\"literal\">NULL</span>);   <span class=\"comment\">//创建一个线程回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">sigset_t</span> <span class=\"built_in\">set</span>,oldset;</span><br><span class=\"line\">    sigemptyset(&amp;<span class=\"built_in\">set</span>);</span><br><span class=\"line\">    sigaddset(&amp;<span class=\"built_in\">set</span>,SIGCHLD);</span><br><span class=\"line\"> \tsigprocmask(SIG_BLOCK,&amp;<span class=\"built_in\">set</span>,&amp;oldset);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nRes;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\taddrsize = <span class=\"keyword\">sizeof</span>(clientaddr);</span><br><span class=\"line\">\t\tClientSock= accept(ListenSock,(struct sockaddr* )&amp;clientaddr,&amp;addrsize);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ClientSock &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">\"ACCEPT ERROR\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpid = fork();</span><br><span class=\"line\">\t\t<span class=\"comment\">//父进程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(pid &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tinet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,ip,<span class=\"keyword\">sizeof</span>(ip));</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"IP:%s  Port:%d\\n\"</span>,ip,clientaddr.sin_port);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(ClientSock);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//子进程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(ListenSock);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\tnRes = <span class=\"built_in\">read</span>(ClientSock,buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(nRes &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tperror(<span class=\"string\">\"READ ERROR\"</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nRes == <span class=\"number\">0</span>)&#123;<span class=\"comment\">//客户端写端关闭   read返回值为0 这个进程终止</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">close</span>(ClientSock);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//大小写转换</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;nRes;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\tbuf[i] = <span class=\"built_in\">toupper</span>(buf[i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">write</span>(ClientSock,buf,nRes);</span><br><span class=\"line\">\t\t\t\tbzero(buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">\"FORK CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ListenSock);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"客户端代码\"><a href=\"#客户端代码\" class=\"headerlink\" title=\"客户端代码\"></a>客户端代码</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SERVER_IP <span class=\"meta-string\">\"127.0.0.1\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PORT 1234</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">addr</span>;</span></span><br><span class=\"line\">\tbzero(&amp;addr,<span class=\"keyword\">sizeof</span>(addr));</span><br><span class=\"line\">\taddr.sin_family = AF_INET;</span><br><span class=\"line\">\tinet_pton(AF_INET,SERVER_IP,&amp;addr.sin_addr.s_addr);</span><br><span class=\"line\">\taddr.sin_port = htons(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ClientSock;</span><br><span class=\"line\">\tClientSock = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ClientSock == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"SCOKET CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == <span class=\"built_in\">connect</span>(ClientSock,(struct sockaddr*)&amp;addr,<span class=\"keyword\">sizeof</span>(addr)))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"CONNECT CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">100</span>];</span><br><span class=\"line\">\t<span class=\"comment\">//scanf(\"%s\",buf);</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nRes;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfgets(buf,<span class=\"keyword\">sizeof</span>(buf),<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//send(ClientSock,buf,sizeof(buf),0);</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">write</span>(ClientSock,buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnRes = <span class=\"built_in\">read</span>(ClientSock,buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nRes &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,buf);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tbzero(buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ClientSock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h2><p>服务器端完成的工作是将客户端传来的字符串，小写变大写，再返回给客户端<br>父进程负责accept，每来一个connect就fork出一个子进程专门处理对应客户端的请求。</p>\n<h2 id=\"需要注意的问题\"><a href=\"#需要注意的问题\" class=\"headerlink\" title=\"需要注意的问题\"></a>需要注意的问题</h2><p>1.fork子进程的时候继承父进程的文件描述符，需要关闭。<br>2.客户端退出之后，对应的子进程也就终止，需要回收子进程。<br>3.在回收子进程的过程中，利用信号捕捉SIGCHLD。在执行信号捕捉函数的时候，会导致accept调用失败。<br>4.在多个子进程同时退出的时候，需要用waitpid循环回收。<br>5.创建一根线程专门回收的时候，需要在主线程对SIGCHLD信号设置屏蔽字</p>","more":"<h2 id=\"服务器端代码\"><a href=\"#服务器端代码\" class=\"headerlink\" title=\"服务器端代码\"></a>服务器端代码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;ctype.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mywait</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> wpid;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>((wpid = waitpid(<span class=\"number\">-1</span>,<span class=\"literal\">NULL</span>,WNOHANG)) &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"pid为%d的进程被回收\\n\"</span>,wpid);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">jobs</span><span class=\"params\">(<span class=\"keyword\">void</span>* argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//捕捉信号   异步回收</span></span><br><span class=\"line\">\tpthread_detach(pthread_self());</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">act</span>,<span class=\"title\">oldact</span>;</span></span><br><span class=\"line\">\tact.sa_handler = mywait;</span><br><span class=\"line\">\tact.sa_flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tsigemptyset(&amp;act.sa_mask);</span><br><span class=\"line\"></span><br><span class=\"line\">\tsigaction(SIGCHLD,&amp;act,&amp;oldact);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tsleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">clientaddr</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> addrsize;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ListenSock,ClientSock;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ip[<span class=\"number\">16</span>];</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">addr</span>;</span></span><br><span class=\"line\">\tbzero(&amp;addr,<span class=\"keyword\">sizeof</span>(addr));</span><br><span class=\"line\">\taddr.sin_family = AF_INET;</span><br><span class=\"line\">\taddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">\taddr.sin_port = htons(<span class=\"number\">1234</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tListenSock = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ListenSock == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"SCOKET CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(bind(ListenSock,(struct sockaddr *)&amp;addr,<span class=\"keyword\">sizeof</span>(addr)) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"BIND CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">listen</span>(ListenSock,<span class=\"number\">128</span>) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"LISTEN CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Server is Running\\n\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">100</span>];</span><br><span class=\"line\">\tbzero(buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t<span class=\"keyword\">pthread_t</span> tid;</span><br><span class=\"line\">\tpthread_create(&amp;tid,<span class=\"literal\">NULL</span>,jobs,<span class=\"literal\">NULL</span>);   <span class=\"comment\">//创建一个线程回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">sigset_t</span> <span class=\"built_in\">set</span>,oldset;</span><br><span class=\"line\">    sigemptyset(&amp;<span class=\"built_in\">set</span>);</span><br><span class=\"line\">    sigaddset(&amp;<span class=\"built_in\">set</span>,SIGCHLD);</span><br><span class=\"line\"> \tsigprocmask(SIG_BLOCK,&amp;<span class=\"built_in\">set</span>,&amp;oldset);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nRes;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\taddrsize = <span class=\"keyword\">sizeof</span>(clientaddr);</span><br><span class=\"line\">\t\tClientSock= accept(ListenSock,(struct sockaddr* )&amp;clientaddr,&amp;addrsize);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ClientSock &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">\"ACCEPT ERROR\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpid = fork();</span><br><span class=\"line\">\t\t<span class=\"comment\">//父进程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(pid &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tinet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,ip,<span class=\"keyword\">sizeof</span>(ip));</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"IP:%s  Port:%d\\n\"</span>,ip,clientaddr.sin_port);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(ClientSock);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//子进程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">close</span>(ListenSock);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\tnRes = <span class=\"built_in\">read</span>(ClientSock,buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(nRes &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tperror(<span class=\"string\">\"READ ERROR\"</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nRes == <span class=\"number\">0</span>)&#123;<span class=\"comment\">//客户端写端关闭   read返回值为0 这个进程终止</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">close</span>(ClientSock);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//大小写转换</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;nRes;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\tbuf[i] = <span class=\"built_in\">toupper</span>(buf[i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">write</span>(ClientSock,buf,nRes);</span><br><span class=\"line\">\t\t\t\tbzero(buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">\"FORK CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ListenSock);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"客户端代码\"><a href=\"#客户端代码\" class=\"headerlink\" title=\"客户端代码\"></a>客户端代码</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SERVER_IP <span class=\"meta-string\">\"127.0.0.1\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PORT 1234</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">addr</span>;</span></span><br><span class=\"line\">\tbzero(&amp;addr,<span class=\"keyword\">sizeof</span>(addr));</span><br><span class=\"line\">\taddr.sin_family = AF_INET;</span><br><span class=\"line\">\tinet_pton(AF_INET,SERVER_IP,&amp;addr.sin_addr.s_addr);</span><br><span class=\"line\">\taddr.sin_port = htons(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ClientSock;</span><br><span class=\"line\">\tClientSock = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ClientSock == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"SCOKET CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == <span class=\"built_in\">connect</span>(ClientSock,(struct sockaddr*)&amp;addr,<span class=\"keyword\">sizeof</span>(addr)))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"CONNECT CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[<span class=\"number\">100</span>];</span><br><span class=\"line\">\t<span class=\"comment\">//scanf(\"%s\",buf);</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nRes;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfgets(buf,<span class=\"keyword\">sizeof</span>(buf),<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//send(ClientSock,buf,sizeof(buf),0);</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">write</span>(ClientSock,buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tnRes = <span class=\"built_in\">read</span>(ClientSock,buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nRes &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>,buf);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tbzero(buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ClientSock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Linux下的线程","date":"2018-11-07T04:09:05.000Z","_content":"\n## 线程概述\n\n线程的一些特性和状态转换和Windows下面类似。因此就简单介绍一下，重点突出Linux下面的一些特色的地方。\n\n1.线程是轻量级进程(light-weight process)，也有PCB(process control block)，创建线程使用的底层函数和进程一样，都是clone(具体参见进程创建过程)\n2.从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB指向的内存资源的三级页表是相同的(换句话说，就是进程和线程共享某些资源，通过间接寻址，指向同一块虚拟地址空间)\n3.线程就是寄存器和栈(调度单位就是寄存器和栈,保护和恢复现场)\n4.线程是最小的调度单位，内核通过调度编号(LWP)去调度。（LWP---线程编号）\n5.独占资源的称为进程，进程可以蜕化成主控线程。\n\nps -Lf pid   显示指定进程的线程信息\nps -eLf        显示所有线程\n\n## 线程间资源共享资源\n\n 1.文件描述符表 2.信号处理方式 3.当前工作目录(pwd)4.用户ID、组ID \n 5.内存地址空间0-3G(32位)用户地址空间:Text、Data、Bss、堆、lib\n\n注意堆区：linux是共享堆，线程和进程指向同一块堆空间，可以设置成非共享堆，但Windows就是非共享堆，每个线程都有自己的堆空间。\n\n## 线程间非共享资源\n\n1.线程id 2. 处理器现场和内核栈指针(保护上下文) 3.用户空间栈 4.errno全局变量\n5.阻塞信号集(屏蔽字) 6.进程调度优先级\n\n## 线程优缺点\n\n优点:1. 提高程序并发性2.开销小,不用重新分配内存3.通信和共享数据方便\n\n缺点:1.线程稳定性差2.gbd调试困难3.线程使用信号比较麻烦。(虽然有同样的处理函数，但是可以对别的线程设置屏蔽字，并且信号不能调试，再加上多线程调试难度很大)\n\n## 线程原语\n\nLinux下采用的线程接口称为\"pthread\"或\"POSIX线程\"，采用的是NPTL库(Native POSIX Thread Library)\n\ngetconf GNU_LIBPTHREAD_VERSION   查看当前pthread库版本\n\n使用线程库时 gcc时要指定 -lpthread\n\npthread_create  创建线程    注意第二个参数  线程属性一般不怎么使用(具体参见APUE  p342）\npthread_self   获取当前线程的id\npthread_join   阻塞函数   等待指定的线程退出，并回收资源，第二个参数可以获取线程退出码\npthread_detach  设置线程为分离态，一旦线程退出，内核自动回收资源。\n\n优点:释放了主控线程，不需要再进行回收操作  缺点:无法获得退出状态了\n\n线程在创建的时候默认是可回收态，也就是说当可回收态的线程退出时，其线程ID和退出状态将被保留，等待另一个线程调用pthread_join。一旦线程被置成分离态，再调用pthread_join就会出错\n\n### 线程退出方式\n\n1.return  如果是普通线程return，会回到主控线程，主控线程return，则进程终止\n2.pthread_exit(void* status)    只会结束调用该函数的线程本身，不会影响其他人，推荐使用这个函数\n注意点:指针status不能指向线程函数中的某个局部变量\n3.exit(0) 无论哪种线程调用，都导致进程终止\n4.pthread_cancel(pthread_t tid)  通过tid结束指定线程  统一退出码是-1   还能安排多个线程退出时的处理函数(APUE p316)\n\n类似于信号杀死进程    信号处理条件(产生中断、异常、系统调用，从用户态切换到内核态，返回用户态再处理信号)，但是pthread_cancel,只有产生系统调用的时候才会检测cancel事件。可以配合空调函数pthread_testcancel()产生系统调用，但是什么事情都没做。\n\n\n\n注意点：\n\n1.与出错时返回-1，并置errno为某个正值的大多数系统函数不同，pthread函数出错时返回正值，不设置errno，成功返回0，由于不设置errno,因此不能用perror打印，可以用strerror把错误码转换成错误信息再打印\n2.注意处理主控线程和普通线程之间的竞争关系，可以让主控线程sleep几秒，保证普通线程在主控线程退出前有充分时间运行\n3.pthread_self获得的线程id和pthread_create传出的线程id是否等价？\n\n考虑这个问题之前，先来看一下pthread_create的内部实现\n1.创建线程   \n2.clone  共享资源\n3.传出线程id\n完成前两步的时候，该线程就能被内核调用，现在假设这样一种情况，线程处理函数的工作极其短暂，在pthread_create尚未传出线程id的时候，线程就结束了。那么当线程id传出时，这个线程已经不在了。\n\n因此区别在于pthread_self一定能保证线程是存活的，而后者可能线程已经结束了。\n\n再考虑一种情况，假如传出的线程id是一个全局变量，在线程处理函数中打印这个全局的线程id，如果说此时线程创建函数还没有传出这个值，只是完成了前两步，那么这个全局变量就是未初始化的值，不是真正的线程id。","source":"_posts/linux下的线程.md","raw":"---\ntitle: Linux下的线程\ndate: 2018-11-07 12:09:05\ntags: \n- 操作系统\n- Linux\n---\n\n## 线程概述\n\n线程的一些特性和状态转换和Windows下面类似。因此就简单介绍一下，重点突出Linux下面的一些特色的地方。\n\n1.线程是轻量级进程(light-weight process)，也有PCB(process control block)，创建线程使用的底层函数和进程一样，都是clone(具体参见进程创建过程)\n2.从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB指向的内存资源的三级页表是相同的(换句话说，就是进程和线程共享某些资源，通过间接寻址，指向同一块虚拟地址空间)\n3.线程就是寄存器和栈(调度单位就是寄存器和栈,保护和恢复现场)\n4.线程是最小的调度单位，内核通过调度编号(LWP)去调度。（LWP---线程编号）\n5.独占资源的称为进程，进程可以蜕化成主控线程。\n\nps -Lf pid   显示指定进程的线程信息\nps -eLf        显示所有线程\n\n## 线程间资源共享资源\n\n 1.文件描述符表 2.信号处理方式 3.当前工作目录(pwd)4.用户ID、组ID \n 5.内存地址空间0-3G(32位)用户地址空间:Text、Data、Bss、堆、lib\n\n注意堆区：linux是共享堆，线程和进程指向同一块堆空间，可以设置成非共享堆，但Windows就是非共享堆，每个线程都有自己的堆空间。\n\n## 线程间非共享资源\n\n1.线程id 2. 处理器现场和内核栈指针(保护上下文) 3.用户空间栈 4.errno全局变量\n5.阻塞信号集(屏蔽字) 6.进程调度优先级\n\n## 线程优缺点\n\n优点:1. 提高程序并发性2.开销小,不用重新分配内存3.通信和共享数据方便\n\n缺点:1.线程稳定性差2.gbd调试困难3.线程使用信号比较麻烦。(虽然有同样的处理函数，但是可以对别的线程设置屏蔽字，并且信号不能调试，再加上多线程调试难度很大)\n\n## 线程原语\n\nLinux下采用的线程接口称为\"pthread\"或\"POSIX线程\"，采用的是NPTL库(Native POSIX Thread Library)\n\ngetconf GNU_LIBPTHREAD_VERSION   查看当前pthread库版本\n\n使用线程库时 gcc时要指定 -lpthread\n\npthread_create  创建线程    注意第二个参数  线程属性一般不怎么使用(具体参见APUE  p342）\npthread_self   获取当前线程的id\npthread_join   阻塞函数   等待指定的线程退出，并回收资源，第二个参数可以获取线程退出码\npthread_detach  设置线程为分离态，一旦线程退出，内核自动回收资源。\n\n优点:释放了主控线程，不需要再进行回收操作  缺点:无法获得退出状态了\n\n线程在创建的时候默认是可回收态，也就是说当可回收态的线程退出时，其线程ID和退出状态将被保留，等待另一个线程调用pthread_join。一旦线程被置成分离态，再调用pthread_join就会出错\n\n### 线程退出方式\n\n1.return  如果是普通线程return，会回到主控线程，主控线程return，则进程终止\n2.pthread_exit(void* status)    只会结束调用该函数的线程本身，不会影响其他人，推荐使用这个函数\n注意点:指针status不能指向线程函数中的某个局部变量\n3.exit(0) 无论哪种线程调用，都导致进程终止\n4.pthread_cancel(pthread_t tid)  通过tid结束指定线程  统一退出码是-1   还能安排多个线程退出时的处理函数(APUE p316)\n\n类似于信号杀死进程    信号处理条件(产生中断、异常、系统调用，从用户态切换到内核态，返回用户态再处理信号)，但是pthread_cancel,只有产生系统调用的时候才会检测cancel事件。可以配合空调函数pthread_testcancel()产生系统调用，但是什么事情都没做。\n\n\n\n注意点：\n\n1.与出错时返回-1，并置errno为某个正值的大多数系统函数不同，pthread函数出错时返回正值，不设置errno，成功返回0，由于不设置errno,因此不能用perror打印，可以用strerror把错误码转换成错误信息再打印\n2.注意处理主控线程和普通线程之间的竞争关系，可以让主控线程sleep几秒，保证普通线程在主控线程退出前有充分时间运行\n3.pthread_self获得的线程id和pthread_create传出的线程id是否等价？\n\n考虑这个问题之前，先来看一下pthread_create的内部实现\n1.创建线程   \n2.clone  共享资源\n3.传出线程id\n完成前两步的时候，该线程就能被内核调用，现在假设这样一种情况，线程处理函数的工作极其短暂，在pthread_create尚未传出线程id的时候，线程就结束了。那么当线程id传出时，这个线程已经不在了。\n\n因此区别在于pthread_self一定能保证线程是存活的，而后者可能线程已经结束了。\n\n再考虑一种情况，假如传出的线程id是一个全局变量，在线程处理函数中打印这个全局的线程id，如果说此时线程创建函数还没有传出这个值，只是完成了前两步，那么这个全局变量就是未初始化的值，不是真正的线程id。","slug":"linux下的线程","published":1,"updated":"2021-12-06T05:30:36.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7i000u96ca6aen1zmu","content":"<h2 id=\"线程概述\"><a href=\"#线程概述\" class=\"headerlink\" title=\"线程概述\"></a>线程概述</h2><p>线程的一些特性和状态转换和Windows下面类似。因此就简单介绍一下，重点突出Linux下面的一些特色的地方。</p>\n<p>1.线程是轻量级进程(light-weight process)，也有PCB(process control block)，创建线程使用的底层函数和进程一样，都是clone(具体参见进程创建过程)<br>2.从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB指向的内存资源的三级页表是相同的(换句话说，就是进程和线程共享某些资源，通过间接寻址，指向同一块虚拟地址空间)<br>3.线程就是寄存器和栈(调度单位就是寄存器和栈,保护和恢复现场)<br>4.线程是最小的调度单位，内核通过调度编号(LWP)去调度。（LWP—线程编号）<br>5.独占资源的称为进程，进程可以蜕化成主控线程。</p>\n<p>ps -Lf pid   显示指定进程的线程信息<br>ps -eLf        显示所有线程</p>\n<h2 id=\"线程间资源共享资源\"><a href=\"#线程间资源共享资源\" class=\"headerlink\" title=\"线程间资源共享资源\"></a>线程间资源共享资源</h2><p> 1.文件描述符表 2.信号处理方式 3.当前工作目录(pwd)4.用户ID、组ID<br> 5.内存地址空间0-3G(32位)用户地址空间:Text、Data、Bss、堆、lib</p>\n<p>注意堆区：linux是共享堆，线程和进程指向同一块堆空间，可以设置成非共享堆，但Windows就是非共享堆，每个线程都有自己的堆空间。</p>\n<h2 id=\"线程间非共享资源\"><a href=\"#线程间非共享资源\" class=\"headerlink\" title=\"线程间非共享资源\"></a>线程间非共享资源</h2><p>1.线程id 2. 处理器现场和内核栈指针(保护上下文) 3.用户空间栈 4.errno全局变量<br>5.阻塞信号集(屏蔽字) 6.进程调度优先级</p>\n<h2 id=\"线程优缺点\"><a href=\"#线程优缺点\" class=\"headerlink\" title=\"线程优缺点\"></a>线程优缺点</h2><p>优点:1. 提高程序并发性2.开销小,不用重新分配内存3.通信和共享数据方便</p>\n<p>缺点:1.线程稳定性差2.gbd调试困难3.线程使用信号比较麻烦。(虽然有同样的处理函数，但是可以对别的线程设置屏蔽字，并且信号不能调试，再加上多线程调试难度很大)</p>\n<h2 id=\"线程原语\"><a href=\"#线程原语\" class=\"headerlink\" title=\"线程原语\"></a>线程原语</h2><p>Linux下采用的线程接口称为”pthread”或”POSIX线程”，采用的是NPTL库(Native POSIX Thread Library)</p>\n<p>getconf GNU_LIBPTHREAD_VERSION   查看当前pthread库版本</p>\n<p>使用线程库时 gcc时要指定 -lpthread</p>\n<p>pthread_create  创建线程    注意第二个参数  线程属性一般不怎么使用(具体参见APUE  p342）<br>pthread_self   获取当前线程的id<br>pthread_join   阻塞函数   等待指定的线程退出，并回收资源，第二个参数可以获取线程退出码<br>pthread_detach  设置线程为分离态，一旦线程退出，内核自动回收资源。</p>\n<p>优点:释放了主控线程，不需要再进行回收操作  缺点:无法获得退出状态了</p>\n<p>线程在创建的时候默认是可回收态，也就是说当可回收态的线程退出时，其线程ID和退出状态将被保留，等待另一个线程调用pthread_join。一旦线程被置成分离态，再调用pthread_join就会出错</p>\n<h3 id=\"线程退出方式\"><a href=\"#线程退出方式\" class=\"headerlink\" title=\"线程退出方式\"></a>线程退出方式</h3><p>1.return  如果是普通线程return，会回到主控线程，主控线程return，则进程终止<br>2.pthread_exit(void* status)    只会结束调用该函数的线程本身，不会影响其他人，推荐使用这个函数<br>注意点:指针status不能指向线程函数中的某个局部变量<br>3.exit(0) 无论哪种线程调用，都导致进程终止<br>4.pthread_cancel(pthread_t tid)  通过tid结束指定线程  统一退出码是-1   还能安排多个线程退出时的处理函数(APUE p316)</p>\n<p>类似于信号杀死进程    信号处理条件(产生中断、异常、系统调用，从用户态切换到内核态，返回用户态再处理信号)，但是pthread_cancel,只有产生系统调用的时候才会检测cancel事件。可以配合空调函数pthread_testcancel()产生系统调用，但是什么事情都没做。</p>\n<p>注意点：</p>\n<p>1.与出错时返回-1，并置errno为某个正值的大多数系统函数不同，pthread函数出错时返回正值，不设置errno，成功返回0，由于不设置errno,因此不能用perror打印，可以用strerror把错误码转换成错误信息再打印<br>2.注意处理主控线程和普通线程之间的竞争关系，可以让主控线程sleep几秒，保证普通线程在主控线程退出前有充分时间运行<br>3.pthread_self获得的线程id和pthread_create传出的线程id是否等价？</p>\n<p>考虑这个问题之前，先来看一下pthread_create的内部实现<br>1.创建线程<br>2.clone  共享资源<br>3.传出线程id<br>完成前两步的时候，该线程就能被内核调用，现在假设这样一种情况，线程处理函数的工作极其短暂，在pthread_create尚未传出线程id的时候，线程就结束了。那么当线程id传出时，这个线程已经不在了。</p>\n<p>因此区别在于pthread_self一定能保证线程是存活的，而后者可能线程已经结束了。</p>\n<p>再考虑一种情况，假如传出的线程id是一个全局变量，在线程处理函数中打印这个全局的线程id，如果说此时线程创建函数还没有传出这个值，只是完成了前两步，那么这个全局变量就是未初始化的值，不是真正的线程id。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线程概述\"><a href=\"#线程概述\" class=\"headerlink\" title=\"线程概述\"></a>线程概述</h2><p>线程的一些特性和状态转换和Windows下面类似。因此就简单介绍一下，重点突出Linux下面的一些特色的地方。</p>\n<p>1.线程是轻量级进程(light-weight process)，也有PCB(process control block)，创建线程使用的底层函数和进程一样，都是clone(具体参见进程创建过程)<br>2.从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB指向的内存资源的三级页表是相同的(换句话说，就是进程和线程共享某些资源，通过间接寻址，指向同一块虚拟地址空间)<br>3.线程就是寄存器和栈(调度单位就是寄存器和栈,保护和恢复现场)<br>4.线程是最小的调度单位，内核通过调度编号(LWP)去调度。（LWP—线程编号）<br>5.独占资源的称为进程，进程可以蜕化成主控线程。</p>\n<p>ps -Lf pid   显示指定进程的线程信息<br>ps -eLf        显示所有线程</p>\n<h2 id=\"线程间资源共享资源\"><a href=\"#线程间资源共享资源\" class=\"headerlink\" title=\"线程间资源共享资源\"></a>线程间资源共享资源</h2><p> 1.文件描述符表 2.信号处理方式 3.当前工作目录(pwd)4.用户ID、组ID<br> 5.内存地址空间0-3G(32位)用户地址空间:Text、Data、Bss、堆、lib</p>\n<p>注意堆区：linux是共享堆，线程和进程指向同一块堆空间，可以设置成非共享堆，但Windows就是非共享堆，每个线程都有自己的堆空间。</p>\n<h2 id=\"线程间非共享资源\"><a href=\"#线程间非共享资源\" class=\"headerlink\" title=\"线程间非共享资源\"></a>线程间非共享资源</h2><p>1.线程id 2. 处理器现场和内核栈指针(保护上下文) 3.用户空间栈 4.errno全局变量<br>5.阻塞信号集(屏蔽字) 6.进程调度优先级</p>\n<h2 id=\"线程优缺点\"><a href=\"#线程优缺点\" class=\"headerlink\" title=\"线程优缺点\"></a>线程优缺点</h2><p>优点:1. 提高程序并发性2.开销小,不用重新分配内存3.通信和共享数据方便</p>\n<p>缺点:1.线程稳定性差2.gbd调试困难3.线程使用信号比较麻烦。(虽然有同样的处理函数，但是可以对别的线程设置屏蔽字，并且信号不能调试，再加上多线程调试难度很大)</p>\n<h2 id=\"线程原语\"><a href=\"#线程原语\" class=\"headerlink\" title=\"线程原语\"></a>线程原语</h2><p>Linux下采用的线程接口称为”pthread”或”POSIX线程”，采用的是NPTL库(Native POSIX Thread Library)</p>\n<p>getconf GNU_LIBPTHREAD_VERSION   查看当前pthread库版本</p>\n<p>使用线程库时 gcc时要指定 -lpthread</p>\n<p>pthread_create  创建线程    注意第二个参数  线程属性一般不怎么使用(具体参见APUE  p342）<br>pthread_self   获取当前线程的id<br>pthread_join   阻塞函数   等待指定的线程退出，并回收资源，第二个参数可以获取线程退出码<br>pthread_detach  设置线程为分离态，一旦线程退出，内核自动回收资源。</p>\n<p>优点:释放了主控线程，不需要再进行回收操作  缺点:无法获得退出状态了</p>\n<p>线程在创建的时候默认是可回收态，也就是说当可回收态的线程退出时，其线程ID和退出状态将被保留，等待另一个线程调用pthread_join。一旦线程被置成分离态，再调用pthread_join就会出错</p>\n<h3 id=\"线程退出方式\"><a href=\"#线程退出方式\" class=\"headerlink\" title=\"线程退出方式\"></a>线程退出方式</h3><p>1.return  如果是普通线程return，会回到主控线程，主控线程return，则进程终止<br>2.pthread_exit(void* status)    只会结束调用该函数的线程本身，不会影响其他人，推荐使用这个函数<br>注意点:指针status不能指向线程函数中的某个局部变量<br>3.exit(0) 无论哪种线程调用，都导致进程终止<br>4.pthread_cancel(pthread_t tid)  通过tid结束指定线程  统一退出码是-1   还能安排多个线程退出时的处理函数(APUE p316)</p>\n<p>类似于信号杀死进程    信号处理条件(产生中断、异常、系统调用，从用户态切换到内核态，返回用户态再处理信号)，但是pthread_cancel,只有产生系统调用的时候才会检测cancel事件。可以配合空调函数pthread_testcancel()产生系统调用，但是什么事情都没做。</p>\n<p>注意点：</p>\n<p>1.与出错时返回-1，并置errno为某个正值的大多数系统函数不同，pthread函数出错时返回正值，不设置errno，成功返回0，由于不设置errno,因此不能用perror打印，可以用strerror把错误码转换成错误信息再打印<br>2.注意处理主控线程和普通线程之间的竞争关系，可以让主控线程sleep几秒，保证普通线程在主控线程退出前有充分时间运行<br>3.pthread_self获得的线程id和pthread_create传出的线程id是否等价？</p>\n<p>考虑这个问题之前，先来看一下pthread_create的内部实现<br>1.创建线程<br>2.clone  共享资源<br>3.传出线程id<br>完成前两步的时候，该线程就能被内核调用，现在假设这样一种情况，线程处理函数的工作极其短暂，在pthread_create尚未传出线程id的时候，线程就结束了。那么当线程id传出时，这个线程已经不在了。</p>\n<p>因此区别在于pthread_self一定能保证线程是存活的，而后者可能线程已经结束了。</p>\n<p>再考虑一种情况，假如传出的线程id是一个全局变量，在线程处理函数中打印这个全局的线程id，如果说此时线程创建函数还没有传出这个值，只是完成了前两步，那么这个全局变量就是未初始化的值，不是真正的线程id。</p>\n"},{"title":"Linux进程间通信方式","date":"2019-03-13T12:52:05.000Z","_content":"\n## 进程间通信(InterProcess Communication)\n\n当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程同步的问题，确保任一时刻只有一个进程可以拥有对资源的独占式访问。\n\n程序对共享资源访问的代码只是很短的一段，但就是这一段代码引发了进程之间的竞态条件，那么这段代码称为关键段，也叫临界区。\n\n进程间通信大体思路有两种：1.数据传递(通过内核)  2.共享内存\n\n\n\n#### 管道\n\n```\nint pipe(int fd[2]);   //成功返回0  出错返回-1\n```\n\n局限性：\n\n- 半双工(数据只能在一个方向上流动)。现在UNIX域套接字默认是全双工的(通过socketpair创建)\n- 只能在具有公共祖先的两个进程之间使用。一般都是一个进程先调用pipe，然后调用fork\n  - 父进程把文件描述符传给子进程之后父子进程 之间通信\n  - 也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信\n\n- 缓冲区有限（在管道创建时，为缓冲区分配一个页面大小），常量PIPE_BUF决定\n\n![](/pic/fork之后的管道.png)\n\nfork之后做什么取决于我们想要的数据流方向。对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0])，子进程关闭管道的写端(fd[1])。\n\n![](/pic/从父到子的管道.png)\n\n使用注意事项(假设都是阻塞I/O操作)：\n\n- 当读一个写端被关闭的管道(引用计数为0)，在所有数据都被读取后，read返回0，表示文件结束。\n- 如果写端没有被关闭，这时有进程从管道读数据，那么管道中剩余的数据被读取完之后，再次调用read将阻塞，直到持有写端的进程向管道中写入数据\n- 当对于一个读端被关闭的管道进行写操作，将产生SIGPIPE信号，默认动作终止进程。如果忽略该信号或者捕捉该信号并从其处理程序返回，write返回-1，并设置errno为EPIPE\n- 如果读端没有被关闭，持有读端的进程也没有读数据，这是写端向管道写数据，管道被写满时再次调用write将阻塞，知道有数据被read才能继续写入\n\nPIPE_BUF规定了内核的管道缓冲区大小。\n\n如果对管道调用write，并且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或者FIFO)的write交叉进行。\n\n如果有多个进程同时写一个管道(或者FIFO)，而且要求写的字节数超过PIPE_BUF,那么所写的数据可能会与其他进程所写的数据相互交叉。   //有待实验\n\n用pathconf或者fpathconf函数可以确定PIPE_BUF的值。  \n\n","source":"_posts/linux进程间通信方式.md","raw":"---\ntitle: Linux进程间通信方式\ndate: 2019-03-13 20:52:05\ntags:\n- Linux\n- 操作系统\n- 进程\n- apue\n---\n\n## 进程间通信(InterProcess Communication)\n\n当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程同步的问题，确保任一时刻只有一个进程可以拥有对资源的独占式访问。\n\n程序对共享资源访问的代码只是很短的一段，但就是这一段代码引发了进程之间的竞态条件，那么这段代码称为关键段，也叫临界区。\n\n进程间通信大体思路有两种：1.数据传递(通过内核)  2.共享内存\n\n\n\n#### 管道\n\n```\nint pipe(int fd[2]);   //成功返回0  出错返回-1\n```\n\n局限性：\n\n- 半双工(数据只能在一个方向上流动)。现在UNIX域套接字默认是全双工的(通过socketpair创建)\n- 只能在具有公共祖先的两个进程之间使用。一般都是一个进程先调用pipe，然后调用fork\n  - 父进程把文件描述符传给子进程之后父子进程 之间通信\n  - 也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信\n\n- 缓冲区有限（在管道创建时，为缓冲区分配一个页面大小），常量PIPE_BUF决定\n\n![](/pic/fork之后的管道.png)\n\nfork之后做什么取决于我们想要的数据流方向。对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0])，子进程关闭管道的写端(fd[1])。\n\n![](/pic/从父到子的管道.png)\n\n使用注意事项(假设都是阻塞I/O操作)：\n\n- 当读一个写端被关闭的管道(引用计数为0)，在所有数据都被读取后，read返回0，表示文件结束。\n- 如果写端没有被关闭，这时有进程从管道读数据，那么管道中剩余的数据被读取完之后，再次调用read将阻塞，直到持有写端的进程向管道中写入数据\n- 当对于一个读端被关闭的管道进行写操作，将产生SIGPIPE信号，默认动作终止进程。如果忽略该信号或者捕捉该信号并从其处理程序返回，write返回-1，并设置errno为EPIPE\n- 如果读端没有被关闭，持有读端的进程也没有读数据，这是写端向管道写数据，管道被写满时再次调用write将阻塞，知道有数据被read才能继续写入\n\nPIPE_BUF规定了内核的管道缓冲区大小。\n\n如果对管道调用write，并且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或者FIFO)的write交叉进行。\n\n如果有多个进程同时写一个管道(或者FIFO)，而且要求写的字节数超过PIPE_BUF,那么所写的数据可能会与其他进程所写的数据相互交叉。   //有待实验\n\n用pathconf或者fpathconf函数可以确定PIPE_BUF的值。  \n\n","slug":"linux进程间通信方式","published":1,"updated":"2021-12-06T05:30:36.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7j000w96caeisve4jh","content":"<h2 id=\"进程间通信-InterProcess-Communication\"><a href=\"#进程间通信-InterProcess-Communication\" class=\"headerlink\" title=\"进程间通信(InterProcess Communication)\"></a>进程间通信(InterProcess Communication)</h2><p>当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程同步的问题，确保任一时刻只有一个进程可以拥有对资源的独占式访问。</p>\n<p>程序对共享资源访问的代码只是很短的一段，但就是这一段代码引发了进程之间的竞态条件，那么这段代码称为关键段，也叫临界区。</p>\n<p>进程间通信大体思路有两种：1.数据传递(通过内核)  2.共享内存</p>\n<h4 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int pipe(int fd[2]);   &#x2F;&#x2F;成功返回0  出错返回-1</span><br></pre></td></tr></table></figure>\n\n<p>局限性：</p>\n<ul>\n<li><p>半双工(数据只能在一个方向上流动)。现在UNIX域套接字默认是全双工的(通过socketpair创建)</p>\n</li>\n<li><p>只能在具有公共祖先的两个进程之间使用。一般都是一个进程先调用pipe，然后调用fork</p>\n<ul>\n<li>父进程把文件描述符传给子进程之后父子进程 之间通信</li>\n<li>也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信</li>\n</ul>\n</li>\n<li><p>缓冲区有限（在管道创建时，为缓冲区分配一个页面大小），常量PIPE_BUF决定</p>\n</li>\n</ul>\n<p><img src=\"/pic/fork%E4%B9%8B%E5%90%8E%E7%9A%84%E7%AE%A1%E9%81%93.png\" alt=\"\"></p>\n<p>fork之后做什么取决于我们想要的数据流方向。对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0])，子进程关闭管道的写端(fd[1])。</p>\n<p><img src=\"/pic/%E4%BB%8E%E7%88%B6%E5%88%B0%E5%AD%90%E7%9A%84%E7%AE%A1%E9%81%93.png\" alt=\"\"></p>\n<p>使用注意事项(假设都是阻塞I/O操作)：</p>\n<ul>\n<li>当读一个写端被关闭的管道(引用计数为0)，在所有数据都被读取后，read返回0，表示文件结束。</li>\n<li>如果写端没有被关闭，这时有进程从管道读数据，那么管道中剩余的数据被读取完之后，再次调用read将阻塞，直到持有写端的进程向管道中写入数据</li>\n<li>当对于一个读端被关闭的管道进行写操作，将产生SIGPIPE信号，默认动作终止进程。如果忽略该信号或者捕捉该信号并从其处理程序返回，write返回-1，并设置errno为EPIPE</li>\n<li>如果读端没有被关闭，持有读端的进程也没有读数据，这是写端向管道写数据，管道被写满时再次调用write将阻塞，知道有数据被read才能继续写入</li>\n</ul>\n<p>PIPE_BUF规定了内核的管道缓冲区大小。</p>\n<p>如果对管道调用write，并且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或者FIFO)的write交叉进行。</p>\n<p>如果有多个进程同时写一个管道(或者FIFO)，而且要求写的字节数超过PIPE_BUF,那么所写的数据可能会与其他进程所写的数据相互交叉。   //有待实验</p>\n<p>用pathconf或者fpathconf函数可以确定PIPE_BUF的值。  </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"进程间通信-InterProcess-Communication\"><a href=\"#进程间通信-InterProcess-Communication\" class=\"headerlink\" title=\"进程间通信(InterProcess Communication)\"></a>进程间通信(InterProcess Communication)</h2><p>当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程同步的问题，确保任一时刻只有一个进程可以拥有对资源的独占式访问。</p>\n<p>程序对共享资源访问的代码只是很短的一段，但就是这一段代码引发了进程之间的竞态条件，那么这段代码称为关键段，也叫临界区。</p>\n<p>进程间通信大体思路有两种：1.数据传递(通过内核)  2.共享内存</p>\n<h4 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int pipe(int fd[2]);   &#x2F;&#x2F;成功返回0  出错返回-1</span><br></pre></td></tr></table></figure>\n\n<p>局限性：</p>\n<ul>\n<li><p>半双工(数据只能在一个方向上流动)。现在UNIX域套接字默认是全双工的(通过socketpair创建)</p>\n</li>\n<li><p>只能在具有公共祖先的两个进程之间使用。一般都是一个进程先调用pipe，然后调用fork</p>\n<ul>\n<li>父进程把文件描述符传给子进程之后父子进程 之间通信</li>\n<li>也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信</li>\n</ul>\n</li>\n<li><p>缓冲区有限（在管道创建时，为缓冲区分配一个页面大小），常量PIPE_BUF决定</p>\n</li>\n</ul>\n<p><img src=\"/pic/fork%E4%B9%8B%E5%90%8E%E7%9A%84%E7%AE%A1%E9%81%93.png\" alt=\"\"></p>\n<p>fork之后做什么取决于我们想要的数据流方向。对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0])，子进程关闭管道的写端(fd[1])。</p>\n<p><img src=\"/pic/%E4%BB%8E%E7%88%B6%E5%88%B0%E5%AD%90%E7%9A%84%E7%AE%A1%E9%81%93.png\" alt=\"\"></p>\n<p>使用注意事项(假设都是阻塞I/O操作)：</p>\n<ul>\n<li>当读一个写端被关闭的管道(引用计数为0)，在所有数据都被读取后，read返回0，表示文件结束。</li>\n<li>如果写端没有被关闭，这时有进程从管道读数据，那么管道中剩余的数据被读取完之后，再次调用read将阻塞，直到持有写端的进程向管道中写入数据</li>\n<li>当对于一个读端被关闭的管道进行写操作，将产生SIGPIPE信号，默认动作终止进程。如果忽略该信号或者捕捉该信号并从其处理程序返回，write返回-1，并设置errno为EPIPE</li>\n<li>如果读端没有被关闭，持有读端的进程也没有读数据，这是写端向管道写数据，管道被写满时再次调用write将阻塞，知道有数据被read才能继续写入</li>\n</ul>\n<p>PIPE_BUF规定了内核的管道缓冲区大小。</p>\n<p>如果对管道调用write，并且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或者FIFO)的write交叉进行。</p>\n<p>如果有多个进程同时写一个管道(或者FIFO)，而且要求写的字节数超过PIPE_BUF,那么所写的数据可能会与其他进程所写的数据相互交叉。   //有待实验</p>\n<p>用pathconf或者fpathconf函数可以确定PIPE_BUF的值。  </p>\n"},{"title":"Linux下的select模型","date":"2018-11-28T13:51:24.000Z","_content":"\n## 模型特点\n\n1.select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024\n2.采用的是轮询的工作原理\n3.文件描述符采用fd_set类型管理\n\n<!-- more -->\n\n## 具体使用\n\n**int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);**\n成功返回就绪的文件描述符个数，失败返回-1并设置errno\n\n阻塞期间，程序收到信号，select立即返回-1，设置errno为EINTR\n\nnfds:通常被设置成select监听的所有文件描述符最大值+1，因为文件描述符从0开始。\n\n为了效率考虑，这个参数会告诉内核检测前多少个文件描述符的状态\n\nreadfds:监控有读数据到达文件描述符集合，传入传出参数\n\nwritefds：监控写数据到达文件描述符集合，传入传出参数\n\nexceptfds：监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数\n\n通过这3个参数传入自己感兴趣的文件描述符，select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。\n\ntimeout：定时阻塞监控时间(微秒)\n\nstruct timeval {\n　　　long tv_sec;   //seconds \n　　　long tv_usec;   //microseconds\n};\n\n3种情况:\n- NULL，永远等下去\n- 设置timeval，等待固定时间\n- 设置timeval里时间均为0，检查描述字后立即返回，轮询。\n\n当然，如果readfds，writefds，exceptfds三个参数都传空，就相当于一个高配版的sleep()\n\nvoid FD_CLR(int fd, fd_set *set);   把文件描述符集合里fd清0\nint FD_ISSET(int fd, fd_set *set);    测试文件描述符集合里fd是否置1\nvoid FD_SET(int fd, fd_set *set);    把文件描述符集合里fd位置1\nvoid FD_ZERO(fd_set *set);            把文件描述符集合里所有位清0\n\nfd_set假设是一个int类型的数组，那么第一个元素就可以监控0-31文件描述符，第二个元素监控32-63，以此类推\n\n现在假设文件描述符3,4,5已经加入readfds\n\n此时3,4就绪，那么select返回值为2，readfds传出3,4\n\n由于readfds是传入传出参数，因此需要准备一个需要监听的fd_set，每次调用select的时候都拷贝给它。\n\n## 文件描述符就绪条件\n\n哪些情况文件描述符被认为可读、可写或者出现异常？\n\nsocket可读\n\n- socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT，此时可以无阻塞读这个socket\n- socket通信的对方关闭连接，对socket读操作返回0\n- 监听socket上有新的连接请求\n- socket上有未处理的错误。此时可以用getsockopt读取和清除该错误\n\nsocket可写\n\n- socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时可以无阻塞地写该socket\n- socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号\n- socket使用非阻塞connect连接成功或者失败(超时)之后\n- socket上有未处理的错误。此时可以用getsockopt读取和清除该错误\n\nsocket出现异常\n\n- socket上接收到带外数据\n\n## 注意点\n\n1.每次调用select都需要给传入的集合重新复制。\n2.需要准备一个数据结构保存已连接的socket\n3.select第一个参数是文件描述符最大值加1，而不是个数的最大值+1\n4.select也可以监控普通的文件描述符，例如标准输入(FILENO_STDIN)，int fileno(File*)\n\n## 优缺点分析\n\n优点：\n1.单个进程实现伪并发，易于实现，轻量\n2.适合并发量不高，处理流程不长的情况。比如局域网中的某个服务。\n3.支持微妙级别的时间精度\n\n缺点:\n1.每次都要对传入传出的集合重新拷贝赋值，操作麻烦\n2.并发量有1024的上限值\n3.采用轮询，随着fd的线性增长，效率呈线性下降\n4.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。\n5.传入传出参数每次调用select传入时都需要从用户空间拷贝到内核空间，select返回时传出结果从内核拷贝用用户，有着很大的拷贝开销，并且很多时候是重复的工作。\n\n## 服务器代码(客户端代码同多进程模型)\n\n```c\n#include<stdio.h>\n#include<sys/time.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<arpa/inet.h>\n#include<ctype.h>\n#include<pthread.h>\n#include<sys/select.h>\n\n#define IPSIZE 16\n#define BUFSIZE 1500\n#define CLIENTSOCK_SIZE 1024\n#define PORT 1234\n#define LISTEN_SIZE 128\n\nint main()\n{   \n\n\n\tstruct sockaddr_in addr, clientaddr;\n\n\tint ListenSock;\n\tchar ip[IPSIZE];\n\n\tbzero(&addr,sizeof(addr));\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(PORT);\n\n\tListenSock = socket(AF_INET,SOCK_STREAM,0);\n\n\tif(ListenSock == -1){\n\t\tperror(\"SCOKET CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tif(bind(ListenSock,(struct sockaddr *)&addr,sizeof(addr)) == -1){\n\t\tperror(\"BIND CALL FAILED\");\n\t\texit(-1);\n\t}\n\n    if(listen(ListenSock,LISTEN_SIZE) == -1){\n        perror(\"LISTEN CALL FAILED\");\n\t\texit(-1);\n    }\n\n\tprintf(\"Select Server is Running\\n\");\n\n\tchar buf[BUFSIZE];\n\tfd_set set,oldset;\n\tint Max,ready,nlen;\n\tint ClientSockArr[CLIENTSOCK_SIZE];\n\n\t//memset(ClientSockArr,-1,sizeof(ClientSockArr));\n\n\tfor(int i = 0;i<CLIENTSOCK_SIZE;i++)\n\t\tClientSockArr[i] = -1;\n\n\tFD_ZERO(&oldset);\n\tFD_SET(ListenSock,&oldset);\n\n\tMax = ListenSock;\n\tprintf(\"ListenSock:%d\\n\",ListenSock);\n\twhile(1)\n\t{\n\t\tset = oldset;\n\t\tready = select(Max+1,&set,NULL,NULL,NULL);\n\t\twhile(ready){\n\t\t\tif(FD_ISSET(ListenSock,&set)){//ListenSock就绪\n\t\t\t\tint addrsize = sizeof(clientaddr);\n\t\t\t\tint ClientSock;\n\t\t\t\tClientSock = accept(ListenSock,(struct sockaddr* )&clientaddr,&addrsize);\n\t\t\t\tif(ClientSock == -1)\n\t\t\t\t\tperror(\"ACCEPT ERROR\");\n\t\t\t\tif(ClientSock>0){\n\t\t\t\t\tinet_ntop(AF_INET,&clientaddr.sin_addr.s_addr,ip,sizeof(ip));\n\t\t\t\t\tprintf(\"IP:%s  Port:%d,ClientSock:%d\\n\",ip,clientaddr.sin_port,ClientSock);\n\n\t\t\t\t\t//加入到数组当中\n\t\t\t\t\tfor(int i = 0;i<CLIENTSOCK_SIZE;i++){\n\t\t\t\t\t\tif(ClientSockArr[i] == -1){\n\t\t\t\t\t\t\tClientSockArr[i] = ClientSock;\n\t\t\t\t\t\t\tif(ClientSockArr[i] > Max)\n\t\t\t\t\t\t\t\tMax = ClientSockArr[i];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//加入到集合当中\n\t\t\t\t\t\t\tFD_SET(ClientSockArr[i],&oldset);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//遍历客户端数组找出哪个有事件发生\n\t\t\t\tfor(int i = 0;i<CLIENTSOCK_SIZE;i++){\n\t\t\t\t\tif(ClientSockArr[i] != -1){\n\t\t\t\t\t\tif(FD_ISSET(ClientSockArr[i],&set)){ //判断是否就绪\n\t\t\t\t\t\t\tbzero(buf,sizeof(buf));\n\t\t\t\t\t\t\tnlen = read(ClientSockArr[i],buf,sizeof(buf));\n\t\t\t\t\t\t\tif(nlen == 0){ //客户端关闭  这种方式检测客户端终止不好最好心跳机制\n\t\t\t\t\t\t\t\tFD_CLR(ClientSockArr[i],&oldset);\n\t\t\t\t\t\t\t\tclose(ClientSockArr[i]);\n\t\t\t\t\t\t\t\tprintf(\"Cilentfd:%d终止\\n\",ClientSockArr[i]);\n\t\t\t\t\t\t\t\tClientSockArr[i] = -1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tprintf(\"%s\\n\",buf);\n\t\t\t\t\t\t\tfor(int j = 0;j<nlen;j++){\n\t\t\t\t\t\t\t\tbuf[j] = toupper(buf[j]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twrite(ClientSockArr[i],buf,nlen);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tready--;\n\t\t}\n\n\t}\n\n\tclose(ListenSock);\n\treturn 0;\n}\n```\n\n[处理带外数据](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/select.cpp)\n\n","source":"_posts/linux下的select模型.md","raw":"---\ntitle: Linux下的select模型\ndate: 2018-11-28 21:51:24\ntags: \n- IO复用\n- Linux\n- 网络\n- Linux高性能服务器编程\n---\n\n## 模型特点\n\n1.select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024\n2.采用的是轮询的工作原理\n3.文件描述符采用fd_set类型管理\n\n<!-- more -->\n\n## 具体使用\n\n**int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);**\n成功返回就绪的文件描述符个数，失败返回-1并设置errno\n\n阻塞期间，程序收到信号，select立即返回-1，设置errno为EINTR\n\nnfds:通常被设置成select监听的所有文件描述符最大值+1，因为文件描述符从0开始。\n\n为了效率考虑，这个参数会告诉内核检测前多少个文件描述符的状态\n\nreadfds:监控有读数据到达文件描述符集合，传入传出参数\n\nwritefds：监控写数据到达文件描述符集合，传入传出参数\n\nexceptfds：监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数\n\n通过这3个参数传入自己感兴趣的文件描述符，select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。\n\ntimeout：定时阻塞监控时间(微秒)\n\nstruct timeval {\n　　　long tv_sec;   //seconds \n　　　long tv_usec;   //microseconds\n};\n\n3种情况:\n- NULL，永远等下去\n- 设置timeval，等待固定时间\n- 设置timeval里时间均为0，检查描述字后立即返回，轮询。\n\n当然，如果readfds，writefds，exceptfds三个参数都传空，就相当于一个高配版的sleep()\n\nvoid FD_CLR(int fd, fd_set *set);   把文件描述符集合里fd清0\nint FD_ISSET(int fd, fd_set *set);    测试文件描述符集合里fd是否置1\nvoid FD_SET(int fd, fd_set *set);    把文件描述符集合里fd位置1\nvoid FD_ZERO(fd_set *set);            把文件描述符集合里所有位清0\n\nfd_set假设是一个int类型的数组，那么第一个元素就可以监控0-31文件描述符，第二个元素监控32-63，以此类推\n\n现在假设文件描述符3,4,5已经加入readfds\n\n此时3,4就绪，那么select返回值为2，readfds传出3,4\n\n由于readfds是传入传出参数，因此需要准备一个需要监听的fd_set，每次调用select的时候都拷贝给它。\n\n## 文件描述符就绪条件\n\n哪些情况文件描述符被认为可读、可写或者出现异常？\n\nsocket可读\n\n- socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT，此时可以无阻塞读这个socket\n- socket通信的对方关闭连接，对socket读操作返回0\n- 监听socket上有新的连接请求\n- socket上有未处理的错误。此时可以用getsockopt读取和清除该错误\n\nsocket可写\n\n- socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时可以无阻塞地写该socket\n- socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号\n- socket使用非阻塞connect连接成功或者失败(超时)之后\n- socket上有未处理的错误。此时可以用getsockopt读取和清除该错误\n\nsocket出现异常\n\n- socket上接收到带外数据\n\n## 注意点\n\n1.每次调用select都需要给传入的集合重新复制。\n2.需要准备一个数据结构保存已连接的socket\n3.select第一个参数是文件描述符最大值加1，而不是个数的最大值+1\n4.select也可以监控普通的文件描述符，例如标准输入(FILENO_STDIN)，int fileno(File*)\n\n## 优缺点分析\n\n优点：\n1.单个进程实现伪并发，易于实现，轻量\n2.适合并发量不高，处理流程不长的情况。比如局域网中的某个服务。\n3.支持微妙级别的时间精度\n\n缺点:\n1.每次都要对传入传出的集合重新拷贝赋值，操作麻烦\n2.并发量有1024的上限值\n3.采用轮询，随着fd的线性增长，效率呈线性下降\n4.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。\n5.传入传出参数每次调用select传入时都需要从用户空间拷贝到内核空间，select返回时传出结果从内核拷贝用用户，有着很大的拷贝开销，并且很多时候是重复的工作。\n\n## 服务器代码(客户端代码同多进程模型)\n\n```c\n#include<stdio.h>\n#include<sys/time.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<arpa/inet.h>\n#include<ctype.h>\n#include<pthread.h>\n#include<sys/select.h>\n\n#define IPSIZE 16\n#define BUFSIZE 1500\n#define CLIENTSOCK_SIZE 1024\n#define PORT 1234\n#define LISTEN_SIZE 128\n\nint main()\n{   \n\n\n\tstruct sockaddr_in addr, clientaddr;\n\n\tint ListenSock;\n\tchar ip[IPSIZE];\n\n\tbzero(&addr,sizeof(addr));\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(PORT);\n\n\tListenSock = socket(AF_INET,SOCK_STREAM,0);\n\n\tif(ListenSock == -1){\n\t\tperror(\"SCOKET CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tif(bind(ListenSock,(struct sockaddr *)&addr,sizeof(addr)) == -1){\n\t\tperror(\"BIND CALL FAILED\");\n\t\texit(-1);\n\t}\n\n    if(listen(ListenSock,LISTEN_SIZE) == -1){\n        perror(\"LISTEN CALL FAILED\");\n\t\texit(-1);\n    }\n\n\tprintf(\"Select Server is Running\\n\");\n\n\tchar buf[BUFSIZE];\n\tfd_set set,oldset;\n\tint Max,ready,nlen;\n\tint ClientSockArr[CLIENTSOCK_SIZE];\n\n\t//memset(ClientSockArr,-1,sizeof(ClientSockArr));\n\n\tfor(int i = 0;i<CLIENTSOCK_SIZE;i++)\n\t\tClientSockArr[i] = -1;\n\n\tFD_ZERO(&oldset);\n\tFD_SET(ListenSock,&oldset);\n\n\tMax = ListenSock;\n\tprintf(\"ListenSock:%d\\n\",ListenSock);\n\twhile(1)\n\t{\n\t\tset = oldset;\n\t\tready = select(Max+1,&set,NULL,NULL,NULL);\n\t\twhile(ready){\n\t\t\tif(FD_ISSET(ListenSock,&set)){//ListenSock就绪\n\t\t\t\tint addrsize = sizeof(clientaddr);\n\t\t\t\tint ClientSock;\n\t\t\t\tClientSock = accept(ListenSock,(struct sockaddr* )&clientaddr,&addrsize);\n\t\t\t\tif(ClientSock == -1)\n\t\t\t\t\tperror(\"ACCEPT ERROR\");\n\t\t\t\tif(ClientSock>0){\n\t\t\t\t\tinet_ntop(AF_INET,&clientaddr.sin_addr.s_addr,ip,sizeof(ip));\n\t\t\t\t\tprintf(\"IP:%s  Port:%d,ClientSock:%d\\n\",ip,clientaddr.sin_port,ClientSock);\n\n\t\t\t\t\t//加入到数组当中\n\t\t\t\t\tfor(int i = 0;i<CLIENTSOCK_SIZE;i++){\n\t\t\t\t\t\tif(ClientSockArr[i] == -1){\n\t\t\t\t\t\t\tClientSockArr[i] = ClientSock;\n\t\t\t\t\t\t\tif(ClientSockArr[i] > Max)\n\t\t\t\t\t\t\t\tMax = ClientSockArr[i];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//加入到集合当中\n\t\t\t\t\t\t\tFD_SET(ClientSockArr[i],&oldset);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//遍历客户端数组找出哪个有事件发生\n\t\t\t\tfor(int i = 0;i<CLIENTSOCK_SIZE;i++){\n\t\t\t\t\tif(ClientSockArr[i] != -1){\n\t\t\t\t\t\tif(FD_ISSET(ClientSockArr[i],&set)){ //判断是否就绪\n\t\t\t\t\t\t\tbzero(buf,sizeof(buf));\n\t\t\t\t\t\t\tnlen = read(ClientSockArr[i],buf,sizeof(buf));\n\t\t\t\t\t\t\tif(nlen == 0){ //客户端关闭  这种方式检测客户端终止不好最好心跳机制\n\t\t\t\t\t\t\t\tFD_CLR(ClientSockArr[i],&oldset);\n\t\t\t\t\t\t\t\tclose(ClientSockArr[i]);\n\t\t\t\t\t\t\t\tprintf(\"Cilentfd:%d终止\\n\",ClientSockArr[i]);\n\t\t\t\t\t\t\t\tClientSockArr[i] = -1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tprintf(\"%s\\n\",buf);\n\t\t\t\t\t\t\tfor(int j = 0;j<nlen;j++){\n\t\t\t\t\t\t\t\tbuf[j] = toupper(buf[j]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twrite(ClientSockArr[i],buf,nlen);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tready--;\n\t\t}\n\n\t}\n\n\tclose(ListenSock);\n\treturn 0;\n}\n```\n\n[处理带外数据](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/select.cpp)\n\n","slug":"linux下的select模型","published":1,"updated":"2021-12-06T05:30:36.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7k000y96ca2e9p3vbs","content":"<h2 id=\"模型特点\"><a href=\"#模型特点\" class=\"headerlink\" title=\"模型特点\"></a>模型特点</h2><p>1.select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024<br>2.采用的是轮询的工作原理<br>3.文件描述符采用fd_set类型管理</p>\n<a id=\"more\"></a>\n\n<h2 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h2><p><strong>int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</strong><br>成功返回就绪的文件描述符个数，失败返回-1并设置errno</p>\n<p>阻塞期间，程序收到信号，select立即返回-1，设置errno为EINTR</p>\n<p>nfds:通常被设置成select监听的所有文件描述符最大值+1，因为文件描述符从0开始。</p>\n<p>为了效率考虑，这个参数会告诉内核检测前多少个文件描述符的状态</p>\n<p>readfds:监控有读数据到达文件描述符集合，传入传出参数</p>\n<p>writefds：监控写数据到达文件描述符集合，传入传出参数</p>\n<p>exceptfds：监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</p>\n<p>通过这3个参数传入自己感兴趣的文件描述符，select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。</p>\n<p>timeout：定时阻塞监控时间(微秒)</p>\n<p>struct timeval {<br>　　　long tv_sec;   //seconds<br>　　　long tv_usec;   //microseconds<br>};</p>\n<p>3种情况:</p>\n<ul>\n<li>NULL，永远等下去</li>\n<li>设置timeval，等待固定时间</li>\n<li>设置timeval里时间均为0，检查描述字后立即返回，轮询。</li>\n</ul>\n<p>当然，如果readfds，writefds，exceptfds三个参数都传空，就相当于一个高配版的sleep()</p>\n<p>void FD_CLR(int fd, fd_set *set);   把文件描述符集合里fd清0<br>int FD_ISSET(int fd, fd_set *set);    测试文件描述符集合里fd是否置1<br>void FD_SET(int fd, fd_set *set);    把文件描述符集合里fd位置1<br>void FD_ZERO(fd_set *set);            把文件描述符集合里所有位清0</p>\n<p>fd_set假设是一个int类型的数组，那么第一个元素就可以监控0-31文件描述符，第二个元素监控32-63，以此类推</p>\n<p>现在假设文件描述符3,4,5已经加入readfds</p>\n<p>此时3,4就绪，那么select返回值为2，readfds传出3,4</p>\n<p>由于readfds是传入传出参数，因此需要准备一个需要监听的fd_set，每次调用select的时候都拷贝给它。</p>\n<h2 id=\"文件描述符就绪条件\"><a href=\"#文件描述符就绪条件\" class=\"headerlink\" title=\"文件描述符就绪条件\"></a>文件描述符就绪条件</h2><p>哪些情况文件描述符被认为可读、可写或者出现异常？</p>\n<p>socket可读</p>\n<ul>\n<li>socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT，此时可以无阻塞读这个socket</li>\n<li>socket通信的对方关闭连接，对socket读操作返回0</li>\n<li>监听socket上有新的连接请求</li>\n<li>socket上有未处理的错误。此时可以用getsockopt读取和清除该错误</li>\n</ul>\n<p>socket可写</p>\n<ul>\n<li>socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时可以无阻塞地写该socket</li>\n<li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号</li>\n<li>socket使用非阻塞connect连接成功或者失败(超时)之后</li>\n<li>socket上有未处理的错误。此时可以用getsockopt读取和清除该错误</li>\n</ul>\n<p>socket出现异常</p>\n<ul>\n<li>socket上接收到带外数据</li>\n</ul>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>1.每次调用select都需要给传入的集合重新复制。<br>2.需要准备一个数据结构保存已连接的socket<br>3.select第一个参数是文件描述符最大值加1，而不是个数的最大值+1<br>4.select也可以监控普通的文件描述符，例如标准输入(FILENO_STDIN)，int fileno(File*)</p>\n<h2 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h2><p>优点：<br>1.单个进程实现伪并发，易于实现，轻量<br>2.适合并发量不高，处理流程不长的情况。比如局域网中的某个服务。<br>3.支持微妙级别的时间精度</p>\n<p>缺点:<br>1.每次都要对传入传出的集合重新拷贝赋值，操作麻烦<br>2.并发量有1024的上限值<br>3.采用轮询，随着fd的线性增长，效率呈线性下降<br>4.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。<br>5.传入传出参数每次调用select传入时都需要从用户空间拷贝到内核空间，select返回时传出结果从内核拷贝用用户，有着很大的拷贝开销，并且很多时候是重复的工作。</p>\n<h2 id=\"服务器代码-客户端代码同多进程模型\"><a href=\"#服务器代码-客户端代码同多进程模型\" class=\"headerlink\" title=\"服务器代码(客户端代码同多进程模型)\"></a>服务器代码(客户端代码同多进程模型)</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;ctype.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/select.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IPSIZE 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFSIZE 1500</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CLIENTSOCK_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PORT 1234</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LISTEN_SIZE 128</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">addr</span>, <span class=\"title\">clientaddr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ListenSock;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ip[IPSIZE];</span><br><span class=\"line\"></span><br><span class=\"line\">\tbzero(&amp;addr,<span class=\"keyword\">sizeof</span>(addr));</span><br><span class=\"line\"></span><br><span class=\"line\">\taddr.sin_family = AF_INET;</span><br><span class=\"line\">\taddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">\taddr.sin_port = htons(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">\tListenSock = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ListenSock == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"SCOKET CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(bind(ListenSock,(struct sockaddr *)&amp;addr,<span class=\"keyword\">sizeof</span>(addr)) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"BIND CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">listen</span>(ListenSock,LISTEN_SIZE) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"LISTEN CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Select Server is Running\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[BUFSIZE];</span><br><span class=\"line\">\tfd_set <span class=\"built_in\">set</span>,oldset;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Max,<span class=\"built_in\">ready</span>,nlen;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ClientSockArr[CLIENTSOCK_SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//memset(ClientSockArr,-1,sizeof(ClientSockArr));</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;CLIENTSOCK_SIZE;i++)</span><br><span class=\"line\">\t\tClientSockArr[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFD_ZERO(&amp;oldset);</span><br><span class=\"line\">\tFD_SET(ListenSock,&amp;oldset);</span><br><span class=\"line\"></span><br><span class=\"line\">\tMax = ListenSock;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"ListenSock:%d\\n\"</span>,ListenSock);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">set</span> = oldset;</span><br><span class=\"line\">\t\t<span class=\"built_in\">ready</span> = select(Max+<span class=\"number\">1</span>,&amp;<span class=\"built_in\">set</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"built_in\">ready</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(FD_ISSET(ListenSock,&amp;<span class=\"built_in\">set</span>))&#123;<span class=\"comment\">//ListenSock就绪</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> addrsize = <span class=\"keyword\">sizeof</span>(clientaddr);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> ClientSock;</span><br><span class=\"line\">\t\t\t\tClientSock = accept(ListenSock,(struct sockaddr* )&amp;clientaddr,&amp;addrsize);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ClientSock == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\t\t\tperror(<span class=\"string\">\"ACCEPT ERROR\"</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ClientSock&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tinet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,ip,<span class=\"keyword\">sizeof</span>(ip));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"IP:%s  Port:%d,ClientSock:%d\\n\"</span>,ip,clientaddr.sin_port,ClientSock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//加入到数组当中</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;CLIENTSOCK_SIZE;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(ClientSockArr[i] == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tClientSockArr[i] = ClientSock;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(ClientSockArr[i] &gt; Max)</span><br><span class=\"line\">\t\t\t\t\t\t\t\tMax = ClientSockArr[i];</span><br><span class=\"line\">\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//加入到集合当中</span></span><br><span class=\"line\">\t\t\t\t\t\t\tFD_SET(ClientSockArr[i],&amp;oldset);</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//遍历客户端数组找出哪个有事件发生</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;CLIENTSOCK_SIZE;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(ClientSockArr[i] != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(FD_ISSET(ClientSockArr[i],&amp;<span class=\"built_in\">set</span>))&#123; <span class=\"comment\">//判断是否就绪</span></span><br><span class=\"line\">\t\t\t\t\t\t\tbzero(buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t\t\t\t\t\tnlen = <span class=\"built_in\">read</span>(ClientSockArr[i],buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(nlen == <span class=\"number\">0</span>)&#123; <span class=\"comment\">//客户端关闭  这种方式检测客户端终止不好最好心跳机制</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\tFD_CLR(ClientSockArr[i],&amp;oldset);</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"built_in\">close</span>(ClientSockArr[i]);</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Cilentfd:%d终止\\n\"</span>,ClientSockArr[i]);</span><br><span class=\"line\">\t\t\t\t\t\t\t\tClientSockArr[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,buf);</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;nlen;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tbuf[j] = <span class=\"built_in\">toupper</span>(buf[j]);</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">write</span>(ClientSockArr[i],buf,nlen);</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">ready</span>--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ListenSock);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/select.cpp\" target=\"_blank\" rel=\"noopener\">处理带外数据</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"模型特点\"><a href=\"#模型特点\" class=\"headerlink\" title=\"模型特点\"></a>模型特点</h2><p>1.select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024<br>2.采用的是轮询的工作原理<br>3.文件描述符采用fd_set类型管理</p>","more":"<h2 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h2><p><strong>int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</strong><br>成功返回就绪的文件描述符个数，失败返回-1并设置errno</p>\n<p>阻塞期间，程序收到信号，select立即返回-1，设置errno为EINTR</p>\n<p>nfds:通常被设置成select监听的所有文件描述符最大值+1，因为文件描述符从0开始。</p>\n<p>为了效率考虑，这个参数会告诉内核检测前多少个文件描述符的状态</p>\n<p>readfds:监控有读数据到达文件描述符集合，传入传出参数</p>\n<p>writefds：监控写数据到达文件描述符集合，传入传出参数</p>\n<p>exceptfds：监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</p>\n<p>通过这3个参数传入自己感兴趣的文件描述符，select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。</p>\n<p>timeout：定时阻塞监控时间(微秒)</p>\n<p>struct timeval {<br>　　　long tv_sec;   //seconds<br>　　　long tv_usec;   //microseconds<br>};</p>\n<p>3种情况:</p>\n<ul>\n<li>NULL，永远等下去</li>\n<li>设置timeval，等待固定时间</li>\n<li>设置timeval里时间均为0，检查描述字后立即返回，轮询。</li>\n</ul>\n<p>当然，如果readfds，writefds，exceptfds三个参数都传空，就相当于一个高配版的sleep()</p>\n<p>void FD_CLR(int fd, fd_set *set);   把文件描述符集合里fd清0<br>int FD_ISSET(int fd, fd_set *set);    测试文件描述符集合里fd是否置1<br>void FD_SET(int fd, fd_set *set);    把文件描述符集合里fd位置1<br>void FD_ZERO(fd_set *set);            把文件描述符集合里所有位清0</p>\n<p>fd_set假设是一个int类型的数组，那么第一个元素就可以监控0-31文件描述符，第二个元素监控32-63，以此类推</p>\n<p>现在假设文件描述符3,4,5已经加入readfds</p>\n<p>此时3,4就绪，那么select返回值为2，readfds传出3,4</p>\n<p>由于readfds是传入传出参数，因此需要准备一个需要监听的fd_set，每次调用select的时候都拷贝给它。</p>\n<h2 id=\"文件描述符就绪条件\"><a href=\"#文件描述符就绪条件\" class=\"headerlink\" title=\"文件描述符就绪条件\"></a>文件描述符就绪条件</h2><p>哪些情况文件描述符被认为可读、可写或者出现异常？</p>\n<p>socket可读</p>\n<ul>\n<li>socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT，此时可以无阻塞读这个socket</li>\n<li>socket通信的对方关闭连接，对socket读操作返回0</li>\n<li>监听socket上有新的连接请求</li>\n<li>socket上有未处理的错误。此时可以用getsockopt读取和清除该错误</li>\n</ul>\n<p>socket可写</p>\n<ul>\n<li>socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时可以无阻塞地写该socket</li>\n<li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号</li>\n<li>socket使用非阻塞connect连接成功或者失败(超时)之后</li>\n<li>socket上有未处理的错误。此时可以用getsockopt读取和清除该错误</li>\n</ul>\n<p>socket出现异常</p>\n<ul>\n<li>socket上接收到带外数据</li>\n</ul>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>1.每次调用select都需要给传入的集合重新复制。<br>2.需要准备一个数据结构保存已连接的socket<br>3.select第一个参数是文件描述符最大值加1，而不是个数的最大值+1<br>4.select也可以监控普通的文件描述符，例如标准输入(FILENO_STDIN)，int fileno(File*)</p>\n<h2 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h2><p>优点：<br>1.单个进程实现伪并发，易于实现，轻量<br>2.适合并发量不高，处理流程不长的情况。比如局域网中的某个服务。<br>3.支持微妙级别的时间精度</p>\n<p>缺点:<br>1.每次都要对传入传出的集合重新拷贝赋值，操作麻烦<br>2.并发量有1024的上限值<br>3.采用轮询，随着fd的线性增长，效率呈线性下降<br>4.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。<br>5.传入传出参数每次调用select传入时都需要从用户空间拷贝到内核空间，select返回时传出结果从内核拷贝用用户，有着很大的拷贝开销，并且很多时候是重复的工作。</p>\n<h2 id=\"服务器代码-客户端代码同多进程模型\"><a href=\"#服务器代码-客户端代码同多进程模型\" class=\"headerlink\" title=\"服务器代码(客户端代码同多进程模型)\"></a>服务器代码(客户端代码同多进程模型)</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;ctype.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/select.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IPSIZE 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFSIZE 1500</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CLIENTSOCK_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PORT 1234</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LISTEN_SIZE 128</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">addr</span>, <span class=\"title\">clientaddr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ListenSock;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ip[IPSIZE];</span><br><span class=\"line\"></span><br><span class=\"line\">\tbzero(&amp;addr,<span class=\"keyword\">sizeof</span>(addr));</span><br><span class=\"line\"></span><br><span class=\"line\">\taddr.sin_family = AF_INET;</span><br><span class=\"line\">\taddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">\taddr.sin_port = htons(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">\tListenSock = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ListenSock == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"SCOKET CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(bind(ListenSock,(struct sockaddr *)&amp;addr,<span class=\"keyword\">sizeof</span>(addr)) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">\"BIND CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">listen</span>(ListenSock,LISTEN_SIZE) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"LISTEN CALL FAILED\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Select Server is Running\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> buf[BUFSIZE];</span><br><span class=\"line\">\tfd_set <span class=\"built_in\">set</span>,oldset;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Max,<span class=\"built_in\">ready</span>,nlen;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ClientSockArr[CLIENTSOCK_SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//memset(ClientSockArr,-1,sizeof(ClientSockArr));</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;CLIENTSOCK_SIZE;i++)</span><br><span class=\"line\">\t\tClientSockArr[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFD_ZERO(&amp;oldset);</span><br><span class=\"line\">\tFD_SET(ListenSock,&amp;oldset);</span><br><span class=\"line\"></span><br><span class=\"line\">\tMax = ListenSock;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"ListenSock:%d\\n\"</span>,ListenSock);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">set</span> = oldset;</span><br><span class=\"line\">\t\t<span class=\"built_in\">ready</span> = select(Max+<span class=\"number\">1</span>,&amp;<span class=\"built_in\">set</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"built_in\">ready</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(FD_ISSET(ListenSock,&amp;<span class=\"built_in\">set</span>))&#123;<span class=\"comment\">//ListenSock就绪</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> addrsize = <span class=\"keyword\">sizeof</span>(clientaddr);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> ClientSock;</span><br><span class=\"line\">\t\t\t\tClientSock = accept(ListenSock,(struct sockaddr* )&amp;clientaddr,&amp;addrsize);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ClientSock == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\t\t\tperror(<span class=\"string\">\"ACCEPT ERROR\"</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ClientSock&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tinet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,ip,<span class=\"keyword\">sizeof</span>(ip));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"IP:%s  Port:%d,ClientSock:%d\\n\"</span>,ip,clientaddr.sin_port,ClientSock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//加入到数组当中</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;CLIENTSOCK_SIZE;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(ClientSockArr[i] == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tClientSockArr[i] = ClientSock;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(ClientSockArr[i] &gt; Max)</span><br><span class=\"line\">\t\t\t\t\t\t\t\tMax = ClientSockArr[i];</span><br><span class=\"line\">\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//加入到集合当中</span></span><br><span class=\"line\">\t\t\t\t\t\t\tFD_SET(ClientSockArr[i],&amp;oldset);</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//遍历客户端数组找出哪个有事件发生</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;CLIENTSOCK_SIZE;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(ClientSockArr[i] != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(FD_ISSET(ClientSockArr[i],&amp;<span class=\"built_in\">set</span>))&#123; <span class=\"comment\">//判断是否就绪</span></span><br><span class=\"line\">\t\t\t\t\t\t\tbzero(buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t\t\t\t\t\tnlen = <span class=\"built_in\">read</span>(ClientSockArr[i],buf,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(nlen == <span class=\"number\">0</span>)&#123; <span class=\"comment\">//客户端关闭  这种方式检测客户端终止不好最好心跳机制</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\tFD_CLR(ClientSockArr[i],&amp;oldset);</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"built_in\">close</span>(ClientSockArr[i]);</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Cilentfd:%d终止\\n\"</span>,ClientSockArr[i]);</span><br><span class=\"line\">\t\t\t\t\t\t\t\tClientSockArr[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,buf);</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;nlen;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tbuf[j] = <span class=\"built_in\">toupper</span>(buf[j]);</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">write</span>(ClientSockArr[i],buf,nlen);</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">ready</span>--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ListenSock);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/select.cpp\" target=\"_blank\" rel=\"noopener\">处理带外数据</a></p>"},{"title":"lsof","date":"2019-04-20T04:14:43.000Z","_content":"\nlsof(list open file)是一个列出当前系统打开的文件描述符的工具。通过它可以了解感兴趣的进程打开了哪些文件描述符，或者感兴趣的文件描述符被哪些进程打开。\n\n常用选项：\n\n- -i，显示scoket文件描述符\n\n使用方法： \n\n```\nlsof -i [46] [protocol] [@hostname|ipaddr][:service|port]\n```\n\n其中4表示IPv4协议，6表示IPv6协议，protocol指定传输层协议，可以是TCP或者UDP，hostname指定主机名，ipaddr指定主机的IP地址，service指定服务名，port指定端口号。|代表两个填一个就行\n\n<!--more-->\n\n例如，要显示所有连接到主机192.168.1.108的ssh服务的socket文件描述符\n\n```\nlosf -i@192.168.1.108:22\n```\n\n- -u，显示指定用户启动的所有进程打开的所有文件描述符\n- -c，显示指定的命令打开的所有文件描述符，\n\n比如要查看websrv程序打开了哪些文件描述符，可以使用如下命令:\n\nlsof -c websrc\n\n- -p，显示指定的进程打开的所有文件描述符\n- -t，仅显示打开了目标文件描述符的进程的pid\n\n还可以直接将文件名作为lsof命令的参数，以查看哪些进程打开了该文件。\n\nlsof命令的输出内容：\n\n![](/pic/lsof输出内容.png)\n\n","source":"_posts/lsof.md","raw":"---\ntitle: lsof\ndate: 2019-04-20 12:14:43\ntags:\n- 常用工具\n---\n\nlsof(list open file)是一个列出当前系统打开的文件描述符的工具。通过它可以了解感兴趣的进程打开了哪些文件描述符，或者感兴趣的文件描述符被哪些进程打开。\n\n常用选项：\n\n- -i，显示scoket文件描述符\n\n使用方法： \n\n```\nlsof -i [46] [protocol] [@hostname|ipaddr][:service|port]\n```\n\n其中4表示IPv4协议，6表示IPv6协议，protocol指定传输层协议，可以是TCP或者UDP，hostname指定主机名，ipaddr指定主机的IP地址，service指定服务名，port指定端口号。|代表两个填一个就行\n\n<!--more-->\n\n例如，要显示所有连接到主机192.168.1.108的ssh服务的socket文件描述符\n\n```\nlosf -i@192.168.1.108:22\n```\n\n- -u，显示指定用户启动的所有进程打开的所有文件描述符\n- -c，显示指定的命令打开的所有文件描述符，\n\n比如要查看websrv程序打开了哪些文件描述符，可以使用如下命令:\n\nlsof -c websrc\n\n- -p，显示指定的进程打开的所有文件描述符\n- -t，仅显示打开了目标文件描述符的进程的pid\n\n还可以直接将文件名作为lsof命令的参数，以查看哪些进程打开了该文件。\n\nlsof命令的输出内容：\n\n![](/pic/lsof输出内容.png)\n\n","slug":"lsof","published":1,"updated":"2021-12-06T05:30:36.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7k000z96cahgxchs7r","content":"<p>lsof(list open file)是一个列出当前系统打开的文件描述符的工具。通过它可以了解感兴趣的进程打开了哪些文件描述符，或者感兴趣的文件描述符被哪些进程打开。</p>\n<p>常用选项：</p>\n<ul>\n<li>-i，显示scoket文件描述符</li>\n</ul>\n<p>使用方法： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -i [46] [protocol] [@hostname|ipaddr][:service|port]</span><br></pre></td></tr></table></figure>\n\n<p>其中4表示IPv4协议，6表示IPv6协议，protocol指定传输层协议，可以是TCP或者UDP，hostname指定主机名，ipaddr指定主机的IP地址，service指定服务名，port指定端口号。|代表两个填一个就行</p>\n<a id=\"more\"></a>\n\n<p>例如，要显示所有连接到主机192.168.1.108的ssh服务的socket文件描述符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">losf -i@192.168.1.108:22</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-u，显示指定用户启动的所有进程打开的所有文件描述符</li>\n<li>-c，显示指定的命令打开的所有文件描述符，</li>\n</ul>\n<p>比如要查看websrv程序打开了哪些文件描述符，可以使用如下命令:</p>\n<p>lsof -c websrc</p>\n<ul>\n<li>-p，显示指定的进程打开的所有文件描述符</li>\n<li>-t，仅显示打开了目标文件描述符的进程的pid</li>\n</ul>\n<p>还可以直接将文件名作为lsof命令的参数，以查看哪些进程打开了该文件。</p>\n<p>lsof命令的输出内容：</p>\n<p><img src=\"/pic/lsof%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>lsof(list open file)是一个列出当前系统打开的文件描述符的工具。通过它可以了解感兴趣的进程打开了哪些文件描述符，或者感兴趣的文件描述符被哪些进程打开。</p>\n<p>常用选项：</p>\n<ul>\n<li>-i，显示scoket文件描述符</li>\n</ul>\n<p>使用方法： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -i [46] [protocol] [@hostname|ipaddr][:service|port]</span><br></pre></td></tr></table></figure>\n\n<p>其中4表示IPv4协议，6表示IPv6协议，protocol指定传输层协议，可以是TCP或者UDP，hostname指定主机名，ipaddr指定主机的IP地址，service指定服务名，port指定端口号。|代表两个填一个就行</p>","more":"<p>例如，要显示所有连接到主机192.168.1.108的ssh服务的socket文件描述符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">losf -i@192.168.1.108:22</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-u，显示指定用户启动的所有进程打开的所有文件描述符</li>\n<li>-c，显示指定的命令打开的所有文件描述符，</li>\n</ul>\n<p>比如要查看websrv程序打开了哪些文件描述符，可以使用如下命令:</p>\n<p>lsof -c websrc</p>\n<ul>\n<li>-p，显示指定的进程打开的所有文件描述符</li>\n<li>-t，仅显示打开了目标文件描述符的进程的pid</li>\n</ul>\n<p>还可以直接将文件名作为lsof命令的参数，以查看哪些进程打开了该文件。</p>\n<p>lsof命令的输出内容：</p>\n<p><img src=\"/pic/lsof%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9.png\" alt=\"\"></p>"},{"title":"Linux网络编程流程","date":"2019-03-12T11:40:26.000Z","_content":"\n## 服务器端\n\n1.创建socket\n\nint socket(int domain,int type,int protocol)；\n\n自Linux内核2.6.17起，type参数可以接收SOCK_NONBLOCK和SOCK_CLOEXEC\n\n分别表示将新创建的socket设置为非阻塞(fcntl也能完成)，以及用fork调用创建子进程时在子进程中关闭该socket\n\n<!--more-->\n\n2.命名socket\n\nint bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);\n\n将一个socket和socket地址绑定称为给socket命名\n\nsocket地址分为通用socket地址和专用socket地址，具体参见《Linux高性能服务器编程》p71-73\n\n成功返回0，错误返回-1并设置errno。常见的errno是EACCES和AADDRINUSE\n\n- EACCES：被绑定的地址是受保护的地址，进超级用户能访问，比如普通用户将socket绑定到知名服务端口\n- EADDRINUSE：被绑定的地址正在使用中。比如讲socket绑定到一个处于TIME_WAIT状态的地址\n\n在构建socket地址的时候涉及一些转换函数。\n\n主机字节序和网络字节序之间的转换（大小端）\n\n       uint32_t htonl(uint32_t hostlong);\n       uint16_t htons(uint16_t hostshort);\n       uint32_t ntohl(uint32_t netlong);\n       uint16_t ntohs(uint16_t netshort);\nIP地址转换函数\n\n       in_addr_t inet_addr(const char *cp);\n       int inet_aton(const char *cp, struct in_addr *inp);\n       char *inet_ntoa(struct in_addr in);  不可重入函数，内部用静态变量保存结果\n       /*上面三个针对IPv4，下面两个IPv4和IPv6都适用*/\n       in_addr_t inet_addr(const char *cp);\n       const char *inet_ntop(int af, const void *src,char *dst, socklen_t size);\n3.监听socket\n\nint listen(int sockfd,int backlog);\n\n创建监听队列来存放待处理的客户连接。\n\nLinux内核2.2之后，backlog参数表示处于完全连接状态(ESTABLISHED)的socket的上限。\n\n处于半连接状态的socket上限由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义\n\n下面通过程序测试，[代码链接](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_3.cpp)\n\n启动服务器，设置backlog参数值为5\n\n![](/pic/listen测试.png)\n\n在本机开启终端用telnet连接服务器\n\n![](/pic/listen测试2.png)\n\n在本机开启了8个终端，连接到服务器，然后用netstat观察\n\n![](/pic/listen测试3.png)\n\n观察到8个连接中有6个处于ESTABLISHED状态，两个处于SYN_RECV状态。\n\n可见处于ESTABLISHED状态的连接最多是backlog+1个，改变backlog值重新测试，也能得到相同结论。\n\n在不同系统上，结果可能会不同。一般完整连接数都略大于backlog的值。(有待考证)\n\n4.接受连接\n\nint accept(int sockfd,struct sockaddr* addr,socklen_t *addrlen_t);\n\n对于接受连接的accept函数，它从监听队列中取出一个连接，与其建立连接，而不管其处于ESTABLISHED或CLOSE_WAIT状态，更不关心任何网络变化。\n\n考虑一种特殊情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常等原因导致提前退出，根据上述的结论，accept也能调用成功。\n\n5.数据读写\n\nTCP:\n\nssize_t recv(int sockfd,void* buf,size_t len,int flags);\n\nssize_t send(int sockfd,const void* buf,size_t len,int flags);\n\n因为Unix下一切皆文件，因此对文件的读写操作read和write同样适用于socket\n\nflags参数为数据收发提供了额外的控制，一般设置为0。它可以设置为下图选项中的一个或几个。\n\n![](/pic/数据读写flags.png)\n\nsend和recv接发普通数据和带外数据,[客户端](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_6.cpp)、[服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_7.cpp)\n\n总共发送了三次数据\n\n普通数据 \"123\"\n\n带外数据 \"abc\"\n\n普通数据 “123\"\n\n服务器端的输出为：\n\n![](/pic/TCP收发数据结果.png)\n\n客户端发给服务器的3字节带外数据“abc”中，仅有最后一个字符‘c’被服务器当成真正的带外数据接收。\n\n并且服务器对正常数据的接收被带外数据截断。\"123ab\"和“123”不能被一个recv全部读出来。\n\ntcpdump关于带外数据的输出：\n\n![](/pic/抓包带外数据.png)\n\n标志U代表TCP头部设置了紧急标志，\"urg 3\"是紧急偏移值，指出带外数据在字节流中的位置的下一个字节位置是7(4+3,4是该TCP报文的序号值的相对初始序号值的偏移)。因此带外数据是字节流中的第6个字符，即'c'。\n\n注意：flags参数支队send和recv的当前调用生效。通过setsockopt可以永久性修改socket的某些属性。\n\n关于带外数据：\n\n很多时候，我们无法预期带外数据何时到来，但是好在Linux内核检测到TCP紧急标志时，会通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式：\n\n- I/O复用产生的异常事件\n- SIGURG信号\n\n除了需要知道有带外数据到达，还需要知道带外数据在字节流中的位置。\n\nint sockatmark(int sockfd);   \n\n该函数的作用是判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据，如果是，返回1，此时就可以利用带MSG_OOB标记的recv调用来接收带外数据。 如果不是，返回0。\n\nUDP：\n\nssize_t recvfrom(int sockfd,void* buf,size_t len,int flags,struct sockaddr* src_addr,socklen_t* addrlen);\n\nssize_t sendto(int sockfd,const void* buf,size_t len,int flags,const struct sockaddr* dest_addr,socklen_t addflen);\n\n因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址。\n\n特别的：recvfrom/sendto也可以用于面向连接（STREAM）的socket的数据读写， 只需要把最后两个参数设置为NULL。\n\n通用数据读写函数：\nssize_t recvmsg(int sockfd,struct msghdr* msg,int flags);\n\nssize_t sendmsg(int sockfd,struct msghdr* msg,int flags);\n\n```\nstruct msghdr{\n\tvoid* msg_name;              //socket地址\n    socklen_t msg_namelen;       //socket地址的长度\n    struct iovec* msg_iov;       //分散的内存块\n    int msg_iovlen;              //分散内存块的数量\n    void* msg_control;           //指向辅助数据的起始位置\n    socklen_t msg_controllen;    //辅助数据的大小\n    int msg_flags;               //复制函数中的flags参数，并在调用过程中更新\n};\n\nstruct iovec{\n  \tvoid* iov_base;              //内存起始地址\n    size_t iov_len;              //这块内存的长度\n};\n```\n\n对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的结构体指定，这称为分散读。\n\n对于sendmsg而言，msg_iovlen块分散内存中的数据将一并发送，这称为集中写。\n\n6.关闭连接\n\nint close(int fd);\n\n注意：close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1.只有当fd的引用计数为0时才真正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。(创建socket的时候有SOCK_CLOEXEC选项可以解决这个问题)\n\nint shutdown(int sockfd,int howto);\n\n无论如何都要立即终止连接，而不是将socket的引用计数减1。\n\n![](/pic/shutdown参数.png)\n\n\n\n\n\n## 客户端\n\n1.创建socket\n\n注意：客户端不需要命名socket，只需要用操作系统自动分配的socket地址，服务器需要bind，是因为客户端需要找到它，因此每次都需要一个固定的ip+port。\n\n2.发起连接\n\nint connect(int sockfd,const struct sockaddr* serv_addr,socklen_t addrlen);\n\n发起连接需要知道服务器的socket地址\n\n成功返回通信的socket，失败返回-1并设置errno,常见的errno\n\n- ECONNREFUSED:目标端口不存在，连接被拒绝\n- ETIMEOUT:连接超时\n- EINPROGRESS:发生在对非阻塞的socket调用connect，而连接又没有立即建立。这时候我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。如果错误码为0，表示连接成功建立，否则连接失败\n\n[非阻塞connect](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/unblock_connect.cpp)\n\n3.数据读写\n\n4.关闭连接\n\n\n\n## 一些额外的信息\n\n**地址信息函数**\n\nint getsockname(int sockfd,struct  sockaddr* address,socklen_t* address_len);\n\nint getpeername(int sockfd,struct sockaddr* address,socklen_t* address_len);\n\n分别的作用是获取sockfd对应的本端socket地址和远端socket地址。\n\n**网络信息函数**\n\nsocket地址两个要素：ip+port，都是数值，不方便记忆。\n\n可以用主机名来访问一台机器，用服务名来代替端口号。\n\nstruct hostent* gethostbyname(const char* name);\n\n根据主机名称获取主机的完整信息，通常先在/etc/hosts配置文件中查找主机，如果没找到，再访问DNS服务器\n\nstruct hostent* gethostbyaddr(const void* addr,size_t len,int type);\n\n根据IP地址获取主机的完成信息\n\n```\nstruct hostent{\n\tchar* h_name;         //主机名\n    char** h_aliases;     //主机别名列表\n    int h_addrtype;       //地址类型(地址族)\n    int h_length;         //地址长度\n    char** h_addr_list;   //按网络字节序列出的主机IP地址列表\n};\n```\n\nstruct servent* getservbyname(const char* name,const char* proto);\n\n根据名称获取某个服务的完整信息\n\nstruct servent* getservbyport(int port,const char* proto);\n\n根据端口号获取某个服务的完整信息\n\n实际上两个函数都是通过读取/etc/services文件来获取服务信息的\n\n```\nstruct servent{\n\tchar* s_name;            //服务名称\n    char** s_aliases;        //服务的别名列表\n    int s_port;              //端口号\n    char* s_proto;           //服务类型  tcp/udp\n};\n```\n\n\n\nint getaddrinfo(const char* hostname,const char* service,const struct addrinfo* hints,struct addrinfo** result);\n\n该函数既能通过主机名获得IP地址，也能通过服务器获得端口号。\n\nhostname既可以是主机名，也可以是IP地址\n\nservice既可以是服务器，也可以是字符串表示的十进制端口号\n\nhints是用来对getaddrinfo输出进行更精确的控制，也可以设置为NULL\n\nresult参数返回的是一个链表，该链表用来存储getaddrinfo反馈的结果\n\nvoid freeaddrinfo(struct addrinfo* res)；\n\n释放getaddrinfo为res申请的堆空间\n\n```\nstruct addrinfo{\n\tint ai_flags;                   //见下图\n    int ai_family;                  //地址族\n    int ai_socktype;                //服务类型  SOCK_STREAM/SOCK_DGRAM\n    int ai_protocol;                //具体网络协议  通常为0\n    socklen_t ai_addrlen;           //socket地址长度\n    char* ai_addrlen;               //主机的别名\n    struct sockaddr* ai_addr;       //指向socket地址\n    struct addrinfo* ai_next;       //指向下一个addrinfo对象\n};\n```\n\n![](/pic/ai_flags.png)\n\n\n\nint getnameinfo(const struct sockaddr* sockaddr,socklen_t addrlen,char* host,socklen_t hostlen,char* serv,socklen_t servlen,int flags);\n\n该函数能通过socket地址同时获得以字符串表示的主机名和服务名。\n\nflags参数\n\n![](/pic/gestnameinfo_flags.png)\n\ngetaddrinfo和getnameinfo返回的错误码\n\n![](/pic/地址信息错误码.png)","source":"_posts/linux网络编程流程.md","raw":"---\ntitle: Linux网络编程流程\ndate: 2019-03-12 19:40:26\ntags:\n- 网络\n- Linux\n- Linux高性能服务器编程\n---\n\n## 服务器端\n\n1.创建socket\n\nint socket(int domain,int type,int protocol)；\n\n自Linux内核2.6.17起，type参数可以接收SOCK_NONBLOCK和SOCK_CLOEXEC\n\n分别表示将新创建的socket设置为非阻塞(fcntl也能完成)，以及用fork调用创建子进程时在子进程中关闭该socket\n\n<!--more-->\n\n2.命名socket\n\nint bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);\n\n将一个socket和socket地址绑定称为给socket命名\n\nsocket地址分为通用socket地址和专用socket地址，具体参见《Linux高性能服务器编程》p71-73\n\n成功返回0，错误返回-1并设置errno。常见的errno是EACCES和AADDRINUSE\n\n- EACCES：被绑定的地址是受保护的地址，进超级用户能访问，比如普通用户将socket绑定到知名服务端口\n- EADDRINUSE：被绑定的地址正在使用中。比如讲socket绑定到一个处于TIME_WAIT状态的地址\n\n在构建socket地址的时候涉及一些转换函数。\n\n主机字节序和网络字节序之间的转换（大小端）\n\n       uint32_t htonl(uint32_t hostlong);\n       uint16_t htons(uint16_t hostshort);\n       uint32_t ntohl(uint32_t netlong);\n       uint16_t ntohs(uint16_t netshort);\nIP地址转换函数\n\n       in_addr_t inet_addr(const char *cp);\n       int inet_aton(const char *cp, struct in_addr *inp);\n       char *inet_ntoa(struct in_addr in);  不可重入函数，内部用静态变量保存结果\n       /*上面三个针对IPv4，下面两个IPv4和IPv6都适用*/\n       in_addr_t inet_addr(const char *cp);\n       const char *inet_ntop(int af, const void *src,char *dst, socklen_t size);\n3.监听socket\n\nint listen(int sockfd,int backlog);\n\n创建监听队列来存放待处理的客户连接。\n\nLinux内核2.2之后，backlog参数表示处于完全连接状态(ESTABLISHED)的socket的上限。\n\n处于半连接状态的socket上限由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义\n\n下面通过程序测试，[代码链接](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_3.cpp)\n\n启动服务器，设置backlog参数值为5\n\n![](/pic/listen测试.png)\n\n在本机开启终端用telnet连接服务器\n\n![](/pic/listen测试2.png)\n\n在本机开启了8个终端，连接到服务器，然后用netstat观察\n\n![](/pic/listen测试3.png)\n\n观察到8个连接中有6个处于ESTABLISHED状态，两个处于SYN_RECV状态。\n\n可见处于ESTABLISHED状态的连接最多是backlog+1个，改变backlog值重新测试，也能得到相同结论。\n\n在不同系统上，结果可能会不同。一般完整连接数都略大于backlog的值。(有待考证)\n\n4.接受连接\n\nint accept(int sockfd,struct sockaddr* addr,socklen_t *addrlen_t);\n\n对于接受连接的accept函数，它从监听队列中取出一个连接，与其建立连接，而不管其处于ESTABLISHED或CLOSE_WAIT状态，更不关心任何网络变化。\n\n考虑一种特殊情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常等原因导致提前退出，根据上述的结论，accept也能调用成功。\n\n5.数据读写\n\nTCP:\n\nssize_t recv(int sockfd,void* buf,size_t len,int flags);\n\nssize_t send(int sockfd,const void* buf,size_t len,int flags);\n\n因为Unix下一切皆文件，因此对文件的读写操作read和write同样适用于socket\n\nflags参数为数据收发提供了额外的控制，一般设置为0。它可以设置为下图选项中的一个或几个。\n\n![](/pic/数据读写flags.png)\n\nsend和recv接发普通数据和带外数据,[客户端](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_6.cpp)、[服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_7.cpp)\n\n总共发送了三次数据\n\n普通数据 \"123\"\n\n带外数据 \"abc\"\n\n普通数据 “123\"\n\n服务器端的输出为：\n\n![](/pic/TCP收发数据结果.png)\n\n客户端发给服务器的3字节带外数据“abc”中，仅有最后一个字符‘c’被服务器当成真正的带外数据接收。\n\n并且服务器对正常数据的接收被带外数据截断。\"123ab\"和“123”不能被一个recv全部读出来。\n\ntcpdump关于带外数据的输出：\n\n![](/pic/抓包带外数据.png)\n\n标志U代表TCP头部设置了紧急标志，\"urg 3\"是紧急偏移值，指出带外数据在字节流中的位置的下一个字节位置是7(4+3,4是该TCP报文的序号值的相对初始序号值的偏移)。因此带外数据是字节流中的第6个字符，即'c'。\n\n注意：flags参数支队send和recv的当前调用生效。通过setsockopt可以永久性修改socket的某些属性。\n\n关于带外数据：\n\n很多时候，我们无法预期带外数据何时到来，但是好在Linux内核检测到TCP紧急标志时，会通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式：\n\n- I/O复用产生的异常事件\n- SIGURG信号\n\n除了需要知道有带外数据到达，还需要知道带外数据在字节流中的位置。\n\nint sockatmark(int sockfd);   \n\n该函数的作用是判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据，如果是，返回1，此时就可以利用带MSG_OOB标记的recv调用来接收带外数据。 如果不是，返回0。\n\nUDP：\n\nssize_t recvfrom(int sockfd,void* buf,size_t len,int flags,struct sockaddr* src_addr,socklen_t* addrlen);\n\nssize_t sendto(int sockfd,const void* buf,size_t len,int flags,const struct sockaddr* dest_addr,socklen_t addflen);\n\n因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址。\n\n特别的：recvfrom/sendto也可以用于面向连接（STREAM）的socket的数据读写， 只需要把最后两个参数设置为NULL。\n\n通用数据读写函数：\nssize_t recvmsg(int sockfd,struct msghdr* msg,int flags);\n\nssize_t sendmsg(int sockfd,struct msghdr* msg,int flags);\n\n```\nstruct msghdr{\n\tvoid* msg_name;              //socket地址\n    socklen_t msg_namelen;       //socket地址的长度\n    struct iovec* msg_iov;       //分散的内存块\n    int msg_iovlen;              //分散内存块的数量\n    void* msg_control;           //指向辅助数据的起始位置\n    socklen_t msg_controllen;    //辅助数据的大小\n    int msg_flags;               //复制函数中的flags参数，并在调用过程中更新\n};\n\nstruct iovec{\n  \tvoid* iov_base;              //内存起始地址\n    size_t iov_len;              //这块内存的长度\n};\n```\n\n对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的结构体指定，这称为分散读。\n\n对于sendmsg而言，msg_iovlen块分散内存中的数据将一并发送，这称为集中写。\n\n6.关闭连接\n\nint close(int fd);\n\n注意：close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1.只有当fd的引用计数为0时才真正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。(创建socket的时候有SOCK_CLOEXEC选项可以解决这个问题)\n\nint shutdown(int sockfd,int howto);\n\n无论如何都要立即终止连接，而不是将socket的引用计数减1。\n\n![](/pic/shutdown参数.png)\n\n\n\n\n\n## 客户端\n\n1.创建socket\n\n注意：客户端不需要命名socket，只需要用操作系统自动分配的socket地址，服务器需要bind，是因为客户端需要找到它，因此每次都需要一个固定的ip+port。\n\n2.发起连接\n\nint connect(int sockfd,const struct sockaddr* serv_addr,socklen_t addrlen);\n\n发起连接需要知道服务器的socket地址\n\n成功返回通信的socket，失败返回-1并设置errno,常见的errno\n\n- ECONNREFUSED:目标端口不存在，连接被拒绝\n- ETIMEOUT:连接超时\n- EINPROGRESS:发生在对非阻塞的socket调用connect，而连接又没有立即建立。这时候我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。如果错误码为0，表示连接成功建立，否则连接失败\n\n[非阻塞connect](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/unblock_connect.cpp)\n\n3.数据读写\n\n4.关闭连接\n\n\n\n## 一些额外的信息\n\n**地址信息函数**\n\nint getsockname(int sockfd,struct  sockaddr* address,socklen_t* address_len);\n\nint getpeername(int sockfd,struct sockaddr* address,socklen_t* address_len);\n\n分别的作用是获取sockfd对应的本端socket地址和远端socket地址。\n\n**网络信息函数**\n\nsocket地址两个要素：ip+port，都是数值，不方便记忆。\n\n可以用主机名来访问一台机器，用服务名来代替端口号。\n\nstruct hostent* gethostbyname(const char* name);\n\n根据主机名称获取主机的完整信息，通常先在/etc/hosts配置文件中查找主机，如果没找到，再访问DNS服务器\n\nstruct hostent* gethostbyaddr(const void* addr,size_t len,int type);\n\n根据IP地址获取主机的完成信息\n\n```\nstruct hostent{\n\tchar* h_name;         //主机名\n    char** h_aliases;     //主机别名列表\n    int h_addrtype;       //地址类型(地址族)\n    int h_length;         //地址长度\n    char** h_addr_list;   //按网络字节序列出的主机IP地址列表\n};\n```\n\nstruct servent* getservbyname(const char* name,const char* proto);\n\n根据名称获取某个服务的完整信息\n\nstruct servent* getservbyport(int port,const char* proto);\n\n根据端口号获取某个服务的完整信息\n\n实际上两个函数都是通过读取/etc/services文件来获取服务信息的\n\n```\nstruct servent{\n\tchar* s_name;            //服务名称\n    char** s_aliases;        //服务的别名列表\n    int s_port;              //端口号\n    char* s_proto;           //服务类型  tcp/udp\n};\n```\n\n\n\nint getaddrinfo(const char* hostname,const char* service,const struct addrinfo* hints,struct addrinfo** result);\n\n该函数既能通过主机名获得IP地址，也能通过服务器获得端口号。\n\nhostname既可以是主机名，也可以是IP地址\n\nservice既可以是服务器，也可以是字符串表示的十进制端口号\n\nhints是用来对getaddrinfo输出进行更精确的控制，也可以设置为NULL\n\nresult参数返回的是一个链表，该链表用来存储getaddrinfo反馈的结果\n\nvoid freeaddrinfo(struct addrinfo* res)；\n\n释放getaddrinfo为res申请的堆空间\n\n```\nstruct addrinfo{\n\tint ai_flags;                   //见下图\n    int ai_family;                  //地址族\n    int ai_socktype;                //服务类型  SOCK_STREAM/SOCK_DGRAM\n    int ai_protocol;                //具体网络协议  通常为0\n    socklen_t ai_addrlen;           //socket地址长度\n    char* ai_addrlen;               //主机的别名\n    struct sockaddr* ai_addr;       //指向socket地址\n    struct addrinfo* ai_next;       //指向下一个addrinfo对象\n};\n```\n\n![](/pic/ai_flags.png)\n\n\n\nint getnameinfo(const struct sockaddr* sockaddr,socklen_t addrlen,char* host,socklen_t hostlen,char* serv,socklen_t servlen,int flags);\n\n该函数能通过socket地址同时获得以字符串表示的主机名和服务名。\n\nflags参数\n\n![](/pic/gestnameinfo_flags.png)\n\ngetaddrinfo和getnameinfo返回的错误码\n\n![](/pic/地址信息错误码.png)","slug":"linux网络编程流程","published":1,"updated":"2021-12-06T05:30:36.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7l001296cahuo3c8t3","content":"<h2 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h2><p>1.创建socket</p>\n<p>int socket(int domain,int type,int protocol)；</p>\n<p>自Linux内核2.6.17起，type参数可以接收SOCK_NONBLOCK和SOCK_CLOEXEC</p>\n<p>分别表示将新创建的socket设置为非阻塞(fcntl也能完成)，以及用fork调用创建子进程时在子进程中关闭该socket</p>\n<a id=\"more\"></a>\n\n<p>2.命名socket</p>\n<p>int bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);</p>\n<p>将一个socket和socket地址绑定称为给socket命名</p>\n<p>socket地址分为通用socket地址和专用socket地址，具体参见《Linux高性能服务器编程》p71-73</p>\n<p>成功返回0，错误返回-1并设置errno。常见的errno是EACCES和AADDRINUSE</p>\n<ul>\n<li>EACCES：被绑定的地址是受保护的地址，进超级用户能访问，比如普通用户将socket绑定到知名服务端口</li>\n<li>EADDRINUSE：被绑定的地址正在使用中。比如讲socket绑定到一个处于TIME_WAIT状态的地址</li>\n</ul>\n<p>在构建socket地址的时候涉及一些转换函数。</p>\n<p>主机字节序和网络字节序之间的转换（大小端）</p>\n<pre><code>uint32_t htonl(uint32_t hostlong);\nuint16_t htons(uint16_t hostshort);\nuint32_t ntohl(uint32_t netlong);\nuint16_t ntohs(uint16_t netshort);</code></pre><p>IP地址转换函数</p>\n<pre><code>in_addr_t inet_addr(const char *cp);\nint inet_aton(const char *cp, struct in_addr *inp);\nchar *inet_ntoa(struct in_addr in);  不可重入函数，内部用静态变量保存结果\n/*上面三个针对IPv4，下面两个IPv4和IPv6都适用*/\nin_addr_t inet_addr(const char *cp);\nconst char *inet_ntop(int af, const void *src,char *dst, socklen_t size);</code></pre><p>3.监听socket</p>\n<p>int listen(int sockfd,int backlog);</p>\n<p>创建监听队列来存放待处理的客户连接。</p>\n<p>Linux内核2.2之后，backlog参数表示处于完全连接状态(ESTABLISHED)的socket的上限。</p>\n<p>处于半连接状态的socket上限由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义</p>\n<p>下面通过程序测试，<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_3.cpp\" target=\"_blank\" rel=\"noopener\">代码链接</a></p>\n<p>启动服务器，设置backlog参数值为5</p>\n<p><img src=\"/pic/listen%E6%B5%8B%E8%AF%95.png\" alt=\"\"></p>\n<p>在本机开启终端用telnet连接服务器</p>\n<p><img src=\"/pic/listen%E6%B5%8B%E8%AF%952.png\" alt=\"\"></p>\n<p>在本机开启了8个终端，连接到服务器，然后用netstat观察</p>\n<p><img src=\"/pic/listen%E6%B5%8B%E8%AF%953.png\" alt=\"\"></p>\n<p>观察到8个连接中有6个处于ESTABLISHED状态，两个处于SYN_RECV状态。</p>\n<p>可见处于ESTABLISHED状态的连接最多是backlog+1个，改变backlog值重新测试，也能得到相同结论。</p>\n<p>在不同系统上，结果可能会不同。一般完整连接数都略大于backlog的值。(有待考证)</p>\n<p>4.接受连接</p>\n<p>int accept(int sockfd,struct sockaddr* addr,socklen_t *addrlen_t);</p>\n<p>对于接受连接的accept函数，它从监听队列中取出一个连接，与其建立连接，而不管其处于ESTABLISHED或CLOSE_WAIT状态，更不关心任何网络变化。</p>\n<p>考虑一种特殊情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常等原因导致提前退出，根据上述的结论，accept也能调用成功。</p>\n<p>5.数据读写</p>\n<p>TCP:</p>\n<p>ssize_t recv(int sockfd,void* buf,size_t len,int flags);</p>\n<p>ssize_t send(int sockfd,const void* buf,size_t len,int flags);</p>\n<p>因为Unix下一切皆文件，因此对文件的读写操作read和write同样适用于socket</p>\n<p>flags参数为数据收发提供了额外的控制，一般设置为0。它可以设置为下图选项中的一个或几个。</p>\n<p><img src=\"/pic/%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99flags.png\" alt=\"\"></p>\n<p>send和recv接发普通数据和带外数据,<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_6.cpp\" target=\"_blank\" rel=\"noopener\">客户端</a>、<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_7.cpp\" target=\"_blank\" rel=\"noopener\">服务器</a></p>\n<p>总共发送了三次数据</p>\n<p>普通数据 “123”</p>\n<p>带外数据 “abc”</p>\n<p>普通数据 “123”</p>\n<p>服务器端的输出为：</p>\n<p><img src=\"/pic/TCP%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C.png\" alt=\"\"></p>\n<p>客户端发给服务器的3字节带外数据“abc”中，仅有最后一个字符‘c’被服务器当成真正的带外数据接收。</p>\n<p>并且服务器对正常数据的接收被带外数据截断。”123ab”和“123”不能被一个recv全部读出来。</p>\n<p>tcpdump关于带外数据的输出：</p>\n<p><img src=\"/pic/%E6%8A%93%E5%8C%85%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE.png\" alt=\"\"></p>\n<p>标志U代表TCP头部设置了紧急标志，”urg 3”是紧急偏移值，指出带外数据在字节流中的位置的下一个字节位置是7(4+3,4是该TCP报文的序号值的相对初始序号值的偏移)。因此带外数据是字节流中的第6个字符，即’c’。</p>\n<p>注意：flags参数支队send和recv的当前调用生效。通过setsockopt可以永久性修改socket的某些属性。</p>\n<p>关于带外数据：</p>\n<p>很多时候，我们无法预期带外数据何时到来，但是好在Linux内核检测到TCP紧急标志时，会通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式：</p>\n<ul>\n<li>I/O复用产生的异常事件</li>\n<li>SIGURG信号</li>\n</ul>\n<p>除了需要知道有带外数据到达，还需要知道带外数据在字节流中的位置。</p>\n<p>int sockatmark(int sockfd);   </p>\n<p>该函数的作用是判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据，如果是，返回1，此时就可以利用带MSG_OOB标记的recv调用来接收带外数据。 如果不是，返回0。</p>\n<p>UDP：</p>\n<p>ssize_t recvfrom(int sockfd,void* buf,size_t len,int flags,struct sockaddr* src_addr,socklen_t* addrlen);</p>\n<p>ssize_t sendto(int sockfd,const void* buf,size_t len,int flags,const struct sockaddr* dest_addr,socklen_t addflen);</p>\n<p>因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址。</p>\n<p>特别的：recvfrom/sendto也可以用于面向连接（STREAM）的socket的数据读写， 只需要把最后两个参数设置为NULL。</p>\n<p>通用数据读写函数：<br>ssize_t recvmsg(int sockfd,struct msghdr* msg,int flags);</p>\n<p>ssize_t sendmsg(int sockfd,struct msghdr* msg,int flags);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct msghdr&#123;</span><br><span class=\"line\">\tvoid* msg_name;              &#x2F;&#x2F;socket地址</span><br><span class=\"line\">    socklen_t msg_namelen;       &#x2F;&#x2F;socket地址的长度</span><br><span class=\"line\">    struct iovec* msg_iov;       &#x2F;&#x2F;分散的内存块</span><br><span class=\"line\">    int msg_iovlen;              &#x2F;&#x2F;分散内存块的数量</span><br><span class=\"line\">    void* msg_control;           &#x2F;&#x2F;指向辅助数据的起始位置</span><br><span class=\"line\">    socklen_t msg_controllen;    &#x2F;&#x2F;辅助数据的大小</span><br><span class=\"line\">    int msg_flags;               &#x2F;&#x2F;复制函数中的flags参数，并在调用过程中更新</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct iovec&#123;</span><br><span class=\"line\">  \tvoid* iov_base;              &#x2F;&#x2F;内存起始地址</span><br><span class=\"line\">    size_t iov_len;              &#x2F;&#x2F;这块内存的长度</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的结构体指定，这称为分散读。</p>\n<p>对于sendmsg而言，msg_iovlen块分散内存中的数据将一并发送，这称为集中写。</p>\n<p>6.关闭连接</p>\n<p>int close(int fd);</p>\n<p>注意：close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1.只有当fd的引用计数为0时才真正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。(创建socket的时候有SOCK_CLOEXEC选项可以解决这个问题)</p>\n<p>int shutdown(int sockfd,int howto);</p>\n<p>无论如何都要立即终止连接，而不是将socket的引用计数减1。</p>\n<p><img src=\"/pic/shutdown%E5%8F%82%E6%95%B0.png\" alt=\"\"></p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p>1.创建socket</p>\n<p>注意：客户端不需要命名socket，只需要用操作系统自动分配的socket地址，服务器需要bind，是因为客户端需要找到它，因此每次都需要一个固定的ip+port。</p>\n<p>2.发起连接</p>\n<p>int connect(int sockfd,const struct sockaddr* serv_addr,socklen_t addrlen);</p>\n<p>发起连接需要知道服务器的socket地址</p>\n<p>成功返回通信的socket，失败返回-1并设置errno,常见的errno</p>\n<ul>\n<li>ECONNREFUSED:目标端口不存在，连接被拒绝</li>\n<li>ETIMEOUT:连接超时</li>\n<li>EINPROGRESS:发生在对非阻塞的socket调用connect，而连接又没有立即建立。这时候我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。如果错误码为0，表示连接成功建立，否则连接失败</li>\n</ul>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/unblock_connect.cpp\" target=\"_blank\" rel=\"noopener\">非阻塞connect</a></p>\n<p>3.数据读写</p>\n<p>4.关闭连接</p>\n<h2 id=\"一些额外的信息\"><a href=\"#一些额外的信息\" class=\"headerlink\" title=\"一些额外的信息\"></a>一些额外的信息</h2><p><strong>地址信息函数</strong></p>\n<p>int getsockname(int sockfd,struct  sockaddr* address,socklen_t* address_len);</p>\n<p>int getpeername(int sockfd,struct sockaddr* address,socklen_t* address_len);</p>\n<p>分别的作用是获取sockfd对应的本端socket地址和远端socket地址。</p>\n<p><strong>网络信息函数</strong></p>\n<p>socket地址两个要素：ip+port，都是数值，不方便记忆。</p>\n<p>可以用主机名来访问一台机器，用服务名来代替端口号。</p>\n<p>struct hostent* gethostbyname(const char* name);</p>\n<p>根据主机名称获取主机的完整信息，通常先在/etc/hosts配置文件中查找主机，如果没找到，再访问DNS服务器</p>\n<p>struct hostent* gethostbyaddr(const void* addr,size_t len,int type);</p>\n<p>根据IP地址获取主机的完成信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct hostent&#123;</span><br><span class=\"line\">\tchar* h_name;         &#x2F;&#x2F;主机名</span><br><span class=\"line\">    char** h_aliases;     &#x2F;&#x2F;主机别名列表</span><br><span class=\"line\">    int h_addrtype;       &#x2F;&#x2F;地址类型(地址族)</span><br><span class=\"line\">    int h_length;         &#x2F;&#x2F;地址长度</span><br><span class=\"line\">    char** h_addr_list;   &#x2F;&#x2F;按网络字节序列出的主机IP地址列表</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>struct servent* getservbyname(const char* name,const char* proto);</p>\n<p>根据名称获取某个服务的完整信息</p>\n<p>struct servent* getservbyport(int port,const char* proto);</p>\n<p>根据端口号获取某个服务的完整信息</p>\n<p>实际上两个函数都是通过读取/etc/services文件来获取服务信息的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct servent&#123;</span><br><span class=\"line\">\tchar* s_name;            &#x2F;&#x2F;服务名称</span><br><span class=\"line\">    char** s_aliases;        &#x2F;&#x2F;服务的别名列表</span><br><span class=\"line\">    int s_port;              &#x2F;&#x2F;端口号</span><br><span class=\"line\">    char* s_proto;           &#x2F;&#x2F;服务类型  tcp&#x2F;udp</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>int getaddrinfo(const char* hostname,const char* service,const struct addrinfo* hints,struct addrinfo** result);</p>\n<p>该函数既能通过主机名获得IP地址，也能通过服务器获得端口号。</p>\n<p>hostname既可以是主机名，也可以是IP地址</p>\n<p>service既可以是服务器，也可以是字符串表示的十进制端口号</p>\n<p>hints是用来对getaddrinfo输出进行更精确的控制，也可以设置为NULL</p>\n<p>result参数返回的是一个链表，该链表用来存储getaddrinfo反馈的结果</p>\n<p>void freeaddrinfo(struct addrinfo* res)；</p>\n<p>释放getaddrinfo为res申请的堆空间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct addrinfo&#123;</span><br><span class=\"line\">\tint ai_flags;                   &#x2F;&#x2F;见下图</span><br><span class=\"line\">    int ai_family;                  &#x2F;&#x2F;地址族</span><br><span class=\"line\">    int ai_socktype;                &#x2F;&#x2F;服务类型  SOCK_STREAM&#x2F;SOCK_DGRAM</span><br><span class=\"line\">    int ai_protocol;                &#x2F;&#x2F;具体网络协议  通常为0</span><br><span class=\"line\">    socklen_t ai_addrlen;           &#x2F;&#x2F;socket地址长度</span><br><span class=\"line\">    char* ai_addrlen;               &#x2F;&#x2F;主机的别名</span><br><span class=\"line\">    struct sockaddr* ai_addr;       &#x2F;&#x2F;指向socket地址</span><br><span class=\"line\">    struct addrinfo* ai_next;       &#x2F;&#x2F;指向下一个addrinfo对象</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/pic/ai_flags.png\" alt=\"\"></p>\n<p>int getnameinfo(const struct sockaddr* sockaddr,socklen_t addrlen,char* host,socklen_t hostlen,char* serv,socklen_t servlen,int flags);</p>\n<p>该函数能通过socket地址同时获得以字符串表示的主机名和服务名。</p>\n<p>flags参数</p>\n<p><img src=\"/pic/gestnameinfo_flags.png\" alt=\"\"></p>\n<p>getaddrinfo和getnameinfo返回的错误码</p>\n<p><img src=\"/pic/%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E9%94%99%E8%AF%AF%E7%A0%81.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h2><p>1.创建socket</p>\n<p>int socket(int domain,int type,int protocol)；</p>\n<p>自Linux内核2.6.17起，type参数可以接收SOCK_NONBLOCK和SOCK_CLOEXEC</p>\n<p>分别表示将新创建的socket设置为非阻塞(fcntl也能完成)，以及用fork调用创建子进程时在子进程中关闭该socket</p>","more":"<p>2.命名socket</p>\n<p>int bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);</p>\n<p>将一个socket和socket地址绑定称为给socket命名</p>\n<p>socket地址分为通用socket地址和专用socket地址，具体参见《Linux高性能服务器编程》p71-73</p>\n<p>成功返回0，错误返回-1并设置errno。常见的errno是EACCES和AADDRINUSE</p>\n<ul>\n<li>EACCES：被绑定的地址是受保护的地址，进超级用户能访问，比如普通用户将socket绑定到知名服务端口</li>\n<li>EADDRINUSE：被绑定的地址正在使用中。比如讲socket绑定到一个处于TIME_WAIT状态的地址</li>\n</ul>\n<p>在构建socket地址的时候涉及一些转换函数。</p>\n<p>主机字节序和网络字节序之间的转换（大小端）</p>\n<pre><code>uint32_t htonl(uint32_t hostlong);\nuint16_t htons(uint16_t hostshort);\nuint32_t ntohl(uint32_t netlong);\nuint16_t ntohs(uint16_t netshort);</code></pre><p>IP地址转换函数</p>\n<pre><code>in_addr_t inet_addr(const char *cp);\nint inet_aton(const char *cp, struct in_addr *inp);\nchar *inet_ntoa(struct in_addr in);  不可重入函数，内部用静态变量保存结果\n/*上面三个针对IPv4，下面两个IPv4和IPv6都适用*/\nin_addr_t inet_addr(const char *cp);\nconst char *inet_ntop(int af, const void *src,char *dst, socklen_t size);</code></pre><p>3.监听socket</p>\n<p>int listen(int sockfd,int backlog);</p>\n<p>创建监听队列来存放待处理的客户连接。</p>\n<p>Linux内核2.2之后，backlog参数表示处于完全连接状态(ESTABLISHED)的socket的上限。</p>\n<p>处于半连接状态的socket上限由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义</p>\n<p>下面通过程序测试，<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_3.cpp\" target=\"_blank\" rel=\"noopener\">代码链接</a></p>\n<p>启动服务器，设置backlog参数值为5</p>\n<p><img src=\"/pic/listen%E6%B5%8B%E8%AF%95.png\" alt=\"\"></p>\n<p>在本机开启终端用telnet连接服务器</p>\n<p><img src=\"/pic/listen%E6%B5%8B%E8%AF%952.png\" alt=\"\"></p>\n<p>在本机开启了8个终端，连接到服务器，然后用netstat观察</p>\n<p><img src=\"/pic/listen%E6%B5%8B%E8%AF%953.png\" alt=\"\"></p>\n<p>观察到8个连接中有6个处于ESTABLISHED状态，两个处于SYN_RECV状态。</p>\n<p>可见处于ESTABLISHED状态的连接最多是backlog+1个，改变backlog值重新测试，也能得到相同结论。</p>\n<p>在不同系统上，结果可能会不同。一般完整连接数都略大于backlog的值。(有待考证)</p>\n<p>4.接受连接</p>\n<p>int accept(int sockfd,struct sockaddr* addr,socklen_t *addrlen_t);</p>\n<p>对于接受连接的accept函数，它从监听队列中取出一个连接，与其建立连接，而不管其处于ESTABLISHED或CLOSE_WAIT状态，更不关心任何网络变化。</p>\n<p>考虑一种特殊情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常等原因导致提前退出，根据上述的结论，accept也能调用成功。</p>\n<p>5.数据读写</p>\n<p>TCP:</p>\n<p>ssize_t recv(int sockfd,void* buf,size_t len,int flags);</p>\n<p>ssize_t send(int sockfd,const void* buf,size_t len,int flags);</p>\n<p>因为Unix下一切皆文件，因此对文件的读写操作read和write同样适用于socket</p>\n<p>flags参数为数据收发提供了额外的控制，一般设置为0。它可以设置为下图选项中的一个或几个。</p>\n<p><img src=\"/pic/%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99flags.png\" alt=\"\"></p>\n<p>send和recv接发普通数据和带外数据,<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_6.cpp\" target=\"_blank\" rel=\"noopener\">客户端</a>、<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_7.cpp\" target=\"_blank\" rel=\"noopener\">服务器</a></p>\n<p>总共发送了三次数据</p>\n<p>普通数据 “123”</p>\n<p>带外数据 “abc”</p>\n<p>普通数据 “123”</p>\n<p>服务器端的输出为：</p>\n<p><img src=\"/pic/TCP%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C.png\" alt=\"\"></p>\n<p>客户端发给服务器的3字节带外数据“abc”中，仅有最后一个字符‘c’被服务器当成真正的带外数据接收。</p>\n<p>并且服务器对正常数据的接收被带外数据截断。”123ab”和“123”不能被一个recv全部读出来。</p>\n<p>tcpdump关于带外数据的输出：</p>\n<p><img src=\"/pic/%E6%8A%93%E5%8C%85%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE.png\" alt=\"\"></p>\n<p>标志U代表TCP头部设置了紧急标志，”urg 3”是紧急偏移值，指出带外数据在字节流中的位置的下一个字节位置是7(4+3,4是该TCP报文的序号值的相对初始序号值的偏移)。因此带外数据是字节流中的第6个字符，即’c’。</p>\n<p>注意：flags参数支队send和recv的当前调用生效。通过setsockopt可以永久性修改socket的某些属性。</p>\n<p>关于带外数据：</p>\n<p>很多时候，我们无法预期带外数据何时到来，但是好在Linux内核检测到TCP紧急标志时，会通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式：</p>\n<ul>\n<li>I/O复用产生的异常事件</li>\n<li>SIGURG信号</li>\n</ul>\n<p>除了需要知道有带外数据到达，还需要知道带外数据在字节流中的位置。</p>\n<p>int sockatmark(int sockfd);   </p>\n<p>该函数的作用是判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据，如果是，返回1，此时就可以利用带MSG_OOB标记的recv调用来接收带外数据。 如果不是，返回0。</p>\n<p>UDP：</p>\n<p>ssize_t recvfrom(int sockfd,void* buf,size_t len,int flags,struct sockaddr* src_addr,socklen_t* addrlen);</p>\n<p>ssize_t sendto(int sockfd,const void* buf,size_t len,int flags,const struct sockaddr* dest_addr,socklen_t addflen);</p>\n<p>因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址。</p>\n<p>特别的：recvfrom/sendto也可以用于面向连接（STREAM）的socket的数据读写， 只需要把最后两个参数设置为NULL。</p>\n<p>通用数据读写函数：<br>ssize_t recvmsg(int sockfd,struct msghdr* msg,int flags);</p>\n<p>ssize_t sendmsg(int sockfd,struct msghdr* msg,int flags);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct msghdr&#123;</span><br><span class=\"line\">\tvoid* msg_name;              &#x2F;&#x2F;socket地址</span><br><span class=\"line\">    socklen_t msg_namelen;       &#x2F;&#x2F;socket地址的长度</span><br><span class=\"line\">    struct iovec* msg_iov;       &#x2F;&#x2F;分散的内存块</span><br><span class=\"line\">    int msg_iovlen;              &#x2F;&#x2F;分散内存块的数量</span><br><span class=\"line\">    void* msg_control;           &#x2F;&#x2F;指向辅助数据的起始位置</span><br><span class=\"line\">    socklen_t msg_controllen;    &#x2F;&#x2F;辅助数据的大小</span><br><span class=\"line\">    int msg_flags;               &#x2F;&#x2F;复制函数中的flags参数，并在调用过程中更新</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct iovec&#123;</span><br><span class=\"line\">  \tvoid* iov_base;              &#x2F;&#x2F;内存起始地址</span><br><span class=\"line\">    size_t iov_len;              &#x2F;&#x2F;这块内存的长度</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的结构体指定，这称为分散读。</p>\n<p>对于sendmsg而言，msg_iovlen块分散内存中的数据将一并发送，这称为集中写。</p>\n<p>6.关闭连接</p>\n<p>int close(int fd);</p>\n<p>注意：close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1.只有当fd的引用计数为0时才真正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。(创建socket的时候有SOCK_CLOEXEC选项可以解决这个问题)</p>\n<p>int shutdown(int sockfd,int howto);</p>\n<p>无论如何都要立即终止连接，而不是将socket的引用计数减1。</p>\n<p><img src=\"/pic/shutdown%E5%8F%82%E6%95%B0.png\" alt=\"\"></p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p>1.创建socket</p>\n<p>注意：客户端不需要命名socket，只需要用操作系统自动分配的socket地址，服务器需要bind，是因为客户端需要找到它，因此每次都需要一个固定的ip+port。</p>\n<p>2.发起连接</p>\n<p>int connect(int sockfd,const struct sockaddr* serv_addr,socklen_t addrlen);</p>\n<p>发起连接需要知道服务器的socket地址</p>\n<p>成功返回通信的socket，失败返回-1并设置errno,常见的errno</p>\n<ul>\n<li>ECONNREFUSED:目标端口不存在，连接被拒绝</li>\n<li>ETIMEOUT:连接超时</li>\n<li>EINPROGRESS:发生在对非阻塞的socket调用connect，而连接又没有立即建立。这时候我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。如果错误码为0，表示连接成功建立，否则连接失败</li>\n</ul>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/unblock_connect.cpp\" target=\"_blank\" rel=\"noopener\">非阻塞connect</a></p>\n<p>3.数据读写</p>\n<p>4.关闭连接</p>\n<h2 id=\"一些额外的信息\"><a href=\"#一些额外的信息\" class=\"headerlink\" title=\"一些额外的信息\"></a>一些额外的信息</h2><p><strong>地址信息函数</strong></p>\n<p>int getsockname(int sockfd,struct  sockaddr* address,socklen_t* address_len);</p>\n<p>int getpeername(int sockfd,struct sockaddr* address,socklen_t* address_len);</p>\n<p>分别的作用是获取sockfd对应的本端socket地址和远端socket地址。</p>\n<p><strong>网络信息函数</strong></p>\n<p>socket地址两个要素：ip+port，都是数值，不方便记忆。</p>\n<p>可以用主机名来访问一台机器，用服务名来代替端口号。</p>\n<p>struct hostent* gethostbyname(const char* name);</p>\n<p>根据主机名称获取主机的完整信息，通常先在/etc/hosts配置文件中查找主机，如果没找到，再访问DNS服务器</p>\n<p>struct hostent* gethostbyaddr(const void* addr,size_t len,int type);</p>\n<p>根据IP地址获取主机的完成信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct hostent&#123;</span><br><span class=\"line\">\tchar* h_name;         &#x2F;&#x2F;主机名</span><br><span class=\"line\">    char** h_aliases;     &#x2F;&#x2F;主机别名列表</span><br><span class=\"line\">    int h_addrtype;       &#x2F;&#x2F;地址类型(地址族)</span><br><span class=\"line\">    int h_length;         &#x2F;&#x2F;地址长度</span><br><span class=\"line\">    char** h_addr_list;   &#x2F;&#x2F;按网络字节序列出的主机IP地址列表</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>struct servent* getservbyname(const char* name,const char* proto);</p>\n<p>根据名称获取某个服务的完整信息</p>\n<p>struct servent* getservbyport(int port,const char* proto);</p>\n<p>根据端口号获取某个服务的完整信息</p>\n<p>实际上两个函数都是通过读取/etc/services文件来获取服务信息的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct servent&#123;</span><br><span class=\"line\">\tchar* s_name;            &#x2F;&#x2F;服务名称</span><br><span class=\"line\">    char** s_aliases;        &#x2F;&#x2F;服务的别名列表</span><br><span class=\"line\">    int s_port;              &#x2F;&#x2F;端口号</span><br><span class=\"line\">    char* s_proto;           &#x2F;&#x2F;服务类型  tcp&#x2F;udp</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>int getaddrinfo(const char* hostname,const char* service,const struct addrinfo* hints,struct addrinfo** result);</p>\n<p>该函数既能通过主机名获得IP地址，也能通过服务器获得端口号。</p>\n<p>hostname既可以是主机名，也可以是IP地址</p>\n<p>service既可以是服务器，也可以是字符串表示的十进制端口号</p>\n<p>hints是用来对getaddrinfo输出进行更精确的控制，也可以设置为NULL</p>\n<p>result参数返回的是一个链表，该链表用来存储getaddrinfo反馈的结果</p>\n<p>void freeaddrinfo(struct addrinfo* res)；</p>\n<p>释放getaddrinfo为res申请的堆空间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct addrinfo&#123;</span><br><span class=\"line\">\tint ai_flags;                   &#x2F;&#x2F;见下图</span><br><span class=\"line\">    int ai_family;                  &#x2F;&#x2F;地址族</span><br><span class=\"line\">    int ai_socktype;                &#x2F;&#x2F;服务类型  SOCK_STREAM&#x2F;SOCK_DGRAM</span><br><span class=\"line\">    int ai_protocol;                &#x2F;&#x2F;具体网络协议  通常为0</span><br><span class=\"line\">    socklen_t ai_addrlen;           &#x2F;&#x2F;socket地址长度</span><br><span class=\"line\">    char* ai_addrlen;               &#x2F;&#x2F;主机的别名</span><br><span class=\"line\">    struct sockaddr* ai_addr;       &#x2F;&#x2F;指向socket地址</span><br><span class=\"line\">    struct addrinfo* ai_next;       &#x2F;&#x2F;指向下一个addrinfo对象</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/pic/ai_flags.png\" alt=\"\"></p>\n<p>int getnameinfo(const struct sockaddr* sockaddr,socklen_t addrlen,char* host,socklen_t hostlen,char* serv,socklen_t servlen,int flags);</p>\n<p>该函数能通过socket地址同时获得以字符串表示的主机名和服务名。</p>\n<p>flags参数</p>\n<p><img src=\"/pic/gestnameinfo_flags.png\" alt=\"\"></p>\n<p>getaddrinfo和getnameinfo返回的错误码</p>\n<p><img src=\"/pic/%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E9%94%99%E8%AF%AF%E7%A0%81.png\" alt=\"\"></p>"},{"title":"IP协议","date":"2019-03-07T03:04:56.000Z","_content":"\n## 特点\n\nIP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。\n\n无状态：IP通信双方不同步传输数据的状态信息，因此所有的IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。UDP和HTTP都是无状态\n\n- 缺点：无法处理乱序和重复的IP数据报，因为数据报之间没有任何上下文关系\n  - 比如发送端发送的第N个IP数据报可能比第N+1个数据报后到达，就造成乱序\n  - 同一个IP数据报也可能经过不同的路径多次到达接收端\n- 优点：简单、高效，无须为保持通信的状态分配一些内核资源，也无须每次传输数据都携带状态信息\n\n无连接：IP通信双方不长久地维持对方的任何信息。因此，上层协议每次发送数据的时候，都必须明确指定对方的IP地址\n\n不可靠：IP协议不能保证IP数据报准确到达接收端，只是尽最大努力交付，很多情况都能导致IP数据报发送失败。\n\n- 某个中转路由器发现IP数据报在网络上存活时间太长(根据IP头部TTL字段)，那它将被丢弃，并返回一个ICMP错误信息(超时错误)给发送端。\n- 接收端发现收到的IP数据报不正确(通过CRC校验)，它也将丢弃之，并返回一个ICMP错误信息(IP头部参数错误)给发送端。\n\n无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议(比如TCP)需要自己实现数据确认、超时重传等机制来达到可靠传输的目的。\n\n<!--more -->\n\n## IPv4头部\n\n![](/pic/IPv4头部.png)\n\n4位版本号：指定IP协议的版本。对IPv4来说，值是4。其他IPv4协议的扩展版本(如SIP协议和PIP协议)则具有不同的版本号(头部也和上图不一样)\n\n4位头部长度：标识该IP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以IP头部最长是60字节\n\n8位服务类型：包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。4位的TOS字段分别表示：最小延时、最大吞吐量、最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要设置。比如像ssh和telnet这样的登录程序需要最小延时服务，文件传输程序则需要最大吞吐量服务。\n\n16位总长度：整个IP数据报的长度，以字节为单位，因此IP数据报最大长度时65535字节，但由于MTU的限制，长度超过MTU的数据报都将被分片传输。\n\n16位标识：唯一地标识主机发送的每一个数据报。其初始值由系统随机生成，每发送一个数据包，值就加1.该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都有相同的标识值。\n\n3位标志字段：第一位保留，第二位表示“禁止分片”，在这种情况下，如果IP数据报长度超过MTU，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位表示“更多分片”，除了数据报的最后一个分片外，其他分片都要置1\n\n13位分片偏移：是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位(乘8)后得到的，由于这个原因，**除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍**。\n\n8位生存时间（TTL）：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(通常是64)，数据报每经过一个路由，值就减1。减到0的时候就丢弃数据报，返回ICMP差错报文，**TTL的值可以防止数据报陷入路由循环**。\n\n8位协议：用来区分上层协议。ICMP是1，TCP是6，UDP是17\n\n16位头部校验和：由发送端填充，接收端对其使用CRC算法以验算IP数据报头部(只检验头部)在传输过程中是否损坏\n\n32位的源端IP和目的端IP用来标识数据报的发送端和接收端。\n\nIPv4最后一个字段是可变长的可选信息。最多包含40字节，列举常用的，更多可以看RFC 1393\n\n- 记录路由，告诉数据报途径的所有路由器都将自己的IP地址填入IP头部的选项部分，就可以跟踪数据报的传递路径\n- 时间戳：告诉每个路由器都将数据报被转发的时间(或时间与IP对)填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间\n- 松散源路由选择：指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器\n- 严格源路由选择：和松散源路由选择类似，不过数据报只能经过指定的路由器\n\n## tcpdump抓包\n\n在用telnet远程登录的时候，遇到一些问题。\n\n![](/pic/telnet问题.png)\n\n提示我无法连接到远程主机，连接被拒绝，上网查了一下发现telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。因此需要打开telnet服务。\n\n1.安装openbsd-inetd\n\nsudo apt-get install openbsd-inetd\n\n2.安装telnetd\n\nsudo apt-get install telnetd\n\n3.重启openbsd-inetd\n\nsudo /etc/init.d/openbsd-inetd restart\n\n4.查看telnet运行状态     没开启之前输出为空\n\nsudo netstat -a | grep telnet\n\n![](/pic/telnet测试.png)\n\n这时候开始进行抓包\n\nsudo tcpdump -i lo -ntx    #抓取本地回路上的数据包\n\n开启另外一个终端执行telnet命令\n\n![](/pic/IP抓包telnet.png)\n\n用tcpdump抓取到的第一个关于telmet的数据包(开头有两个DNS请求和应答的数据包)\n\n![](/pic/IP抓包tcpdump.png)\n\n该数据包描述的是一个IP数据报，由于使用telnet登录本机，所以IP数据报的源端IP地址和目的端IP地址都是\n\n“127.0.0.1”。telnet服务器程序使用的端口号是23，而telnet客户端程序使用临时端口号34620与服务器通信。\n\n\"Flags\"、“seq”、“win”、“options”都是TCP头部的信息，这里不展开。“length”描述的是IP数据报所携带的应用程序数据的长度。\n\n由上图可知，这个数据包共60字节，其中前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据\n\n分析IP头部：\n\n| 十六进制数 | 十进制表示 | IP头部信息                   |\n| ---------- | :--------- | :--------------------------- |\n| 0x4        | 4          | IP                           |\n| 0x5        | 5          | 头部长度为5个32位(20字节)    |\n| 0x10       |            | TOS选项中最小延时服务被开启  |\n| 0x003c     | 60         | 数据报总长度，60字节         |\n| 0x3174     |            | 数据报标识                   |\n| 0x4        |            | 设置了禁止                   |\n| 0x000      | 0          | 分片偏移                     |\n| 0x40       | 64         | TTL被设为64                  |\n| 0x06       | 6          | 协议字段为6，表示上层协议是T |\n| 0x0b36     |            | IP头部校验和                 |\n| 0x7f000001 |            | 32位源端IP地址127.0.0.1      |\n| 0x7f000001 |            | 32位目的端IP地址127.0.0.1    |\n\n由此可见，IPv4头部结构和分析的完全吻合，并且知道了telnet服务选择使用具有最小延时的服务，并且默认使用的传输层协议是TCP协议，并且这个IP数据报没有分片，因为它没有携带任何应用程序数据。\n\n## IP分片\n\n![](/pic/IP分片.png)\n\n第一个IP分片长度1500字节，IP头部设置了MF标志\n\n第二个IP分片长度21字节，没有设置MF标志，因为已经是最后一个分片\n\n需要注意的是：第二个IP分片里面没有ICMP的头部信息，因为IP模块重组ICMP报文的只需要一份ICMP头部信息\n\n通过抓包来分析IP分片\n\nping www.baidu.com -s 1473     #指定放1473字节的数据\n\n抓包的IP数据包如下：\n\n![](/pic/IP分片抓包.png)\n\n这两个数据包标识值都是46843，说明他们是同一个IP数据报的分片。第一个分片的片偏移值是0，而第二个是1480。第一个分片设置了MF标志标识(flags[+])还有后续分片,第二个没设置说明是最后一个分片。两个分片的长度分别是1500和21字节。\n\n由此可见，通过tcpdump抓包的分析和图片的分析完全一致。\n\n## IP路由\n\nIP协议的核心任务是数据报的路由，也就是决定数据报到目标机器的路径。\n\n#### 工作流程图\n\n![](/pic/IP模块工作流程图.png)\n\n此图的具体分析可以参考游双老师的《Linux高性能服务器编程》P23\n\n#### 路由机制\n\n首先了解一下路由表，可以用route命令或者netstat查看\n\n![](/pic/route命令.png)\n\n各个字段的解释：\n\n![](/pic/路由表.png)\n\n接下来需要考虑的问题：路由表如何按照IP地址进行分类？或者说给定数据报的IP地址，将匹配路由表中的哪一项？这也就是IP的路由机制，有三个步骤。\n\n- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。如果找到，就使用路由项，没找到就跳转步骤2\n- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址(例如route命令展示的路由表的第三项)，如果找到就使用该路由项，没找到就跳转步骤3\n- 选择默认路由项，这通常意味着数据报的下一跳路由是网关\n\n也就是说，对于本机，所有发送到IP地址为192.168.152.*的机器的IP数据报都可以直接发送到目标机器，而所有访问因特网的请求都将通过网关来转发。\n\n#### 路由表更新\n\n可以用route命令来修改路由表(路由缓存  加-C选项)\n\nsudo route add -host 192.168.152.1 dev ens33  \n\n添加主机192.168.152.1对应的路由项，以后所有从本机发送到192.168.152.1的IP数据报将通过网卡ens33直接发送到目标机器的接收网卡。\n\nsudo route del -net 192.168.152.0 netmask 255.255.255.0\n\n删除网络192.168.152.0对应的路由项，这样主机就无法访问该局域网上的任何其他机器\n\nsudo route del  default\n\n删除默认路由项，这样就无法访问因特网\n\n\n\n通过route命令和其他工具修改的路由表，都是静态的路由更新方式。对于大型路由器，通常是通过BGP、RIP、OSPF等协议来发现路径，并更新自己的路由表，这样式动态的、自动的。\n\n#### IP转发\n\n路由器都能执行数据报的转发操作，而主机一般只能发送和接收数据报，因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。\n\n可以修改这个参数使主机具有数据报转发能力\n\n1.用root身份   sudo  su\n\n2.echo 1 > /proc/sys/net/ipv4/ip_forward\n\n路由器或主机进行数据报转发的操作：\n\n- 检查数据报头部的TTL值，为0就丢弃\n- 查看数据报头部的严格源路由选择项。如果该选项被设置，就检测数据报的目标IP是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端。\n- 如果有必要，就给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一个路由器\n- 将TTL值减1\n- 处理IP头部选项\n- 如果有必要，则执行IP分片操作\n\n#### 重定向\n\n![](/pic/ICMP重定向报文.png)\n\n重定向报文类型值是5，代码字段有4个可选值，代表不同的重定向类型。\n\n/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文\n\n/proc/sys/net/ipv4/conf/all/accept_redirects内核参数指定是否允许接收ICMP重定向报文\n\n一般，主机只能接收，路由器只能发送。\n\n## IPv6（RFC 2460）\n\n不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如\n\n- 增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制\n- 引入自动配置功能，使得局域网管理更方便\n- 增加专门的网络安全功能\n\n![](/pic/IPv6头部.png)\n\n4位版本号：指定IP协议的版本。对IPv6来说，值是6\n\n8位通信类型：指定数据流通信类型或优先级，和IPv4中的TOS类似\n\n20位流标签：IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输\n\n16位净荷长度：IPv6扩展头部和应用程序数据长度之和，不包括固定头部长度\n\n8位下一个包头：指出紧跟IPv6固定头部后的包头类型，如扩展头或某个上层协议头\n\n8位跳数限制：类似于IPv4中的TTL\n\nIPv6用128位(16字节)来表示IP地址，IP地址总数达到2^128个\n\n32位表示的IPv4地址一般用点分十进制来表示，而IPv6地址一般用十六进制字符串来表示\n\n\"FE80:0000:0000:0000:1234 :5678:0000:0012\"用：分割成8组，每组16位\n\n\"FE80:​:1234 :5678:0000:0012​\" 零压缩法------省略连续的、全零的组，一个地址中只能用一次，所以后面的零没压缩\n\nIPv6扩展头部\n\n![](/pic/IPv6扩展头部.png)\n\n","source":"_posts/IP协议.md","raw":"---\ntitle: IP协议\ndate: 2019-03-07 11:04:56\ntags:\n- 网络\n- Linux高性能服务器编程\n---\n\n## 特点\n\nIP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。\n\n无状态：IP通信双方不同步传输数据的状态信息，因此所有的IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。UDP和HTTP都是无状态\n\n- 缺点：无法处理乱序和重复的IP数据报，因为数据报之间没有任何上下文关系\n  - 比如发送端发送的第N个IP数据报可能比第N+1个数据报后到达，就造成乱序\n  - 同一个IP数据报也可能经过不同的路径多次到达接收端\n- 优点：简单、高效，无须为保持通信的状态分配一些内核资源，也无须每次传输数据都携带状态信息\n\n无连接：IP通信双方不长久地维持对方的任何信息。因此，上层协议每次发送数据的时候，都必须明确指定对方的IP地址\n\n不可靠：IP协议不能保证IP数据报准确到达接收端，只是尽最大努力交付，很多情况都能导致IP数据报发送失败。\n\n- 某个中转路由器发现IP数据报在网络上存活时间太长(根据IP头部TTL字段)，那它将被丢弃，并返回一个ICMP错误信息(超时错误)给发送端。\n- 接收端发现收到的IP数据报不正确(通过CRC校验)，它也将丢弃之，并返回一个ICMP错误信息(IP头部参数错误)给发送端。\n\n无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议(比如TCP)需要自己实现数据确认、超时重传等机制来达到可靠传输的目的。\n\n<!--more -->\n\n## IPv4头部\n\n![](/pic/IPv4头部.png)\n\n4位版本号：指定IP协议的版本。对IPv4来说，值是4。其他IPv4协议的扩展版本(如SIP协议和PIP协议)则具有不同的版本号(头部也和上图不一样)\n\n4位头部长度：标识该IP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以IP头部最长是60字节\n\n8位服务类型：包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。4位的TOS字段分别表示：最小延时、最大吞吐量、最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要设置。比如像ssh和telnet这样的登录程序需要最小延时服务，文件传输程序则需要最大吞吐量服务。\n\n16位总长度：整个IP数据报的长度，以字节为单位，因此IP数据报最大长度时65535字节，但由于MTU的限制，长度超过MTU的数据报都将被分片传输。\n\n16位标识：唯一地标识主机发送的每一个数据报。其初始值由系统随机生成，每发送一个数据包，值就加1.该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都有相同的标识值。\n\n3位标志字段：第一位保留，第二位表示“禁止分片”，在这种情况下，如果IP数据报长度超过MTU，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位表示“更多分片”，除了数据报的最后一个分片外，其他分片都要置1\n\n13位分片偏移：是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位(乘8)后得到的，由于这个原因，**除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍**。\n\n8位生存时间（TTL）：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(通常是64)，数据报每经过一个路由，值就减1。减到0的时候就丢弃数据报，返回ICMP差错报文，**TTL的值可以防止数据报陷入路由循环**。\n\n8位协议：用来区分上层协议。ICMP是1，TCP是6，UDP是17\n\n16位头部校验和：由发送端填充，接收端对其使用CRC算法以验算IP数据报头部(只检验头部)在传输过程中是否损坏\n\n32位的源端IP和目的端IP用来标识数据报的发送端和接收端。\n\nIPv4最后一个字段是可变长的可选信息。最多包含40字节，列举常用的，更多可以看RFC 1393\n\n- 记录路由，告诉数据报途径的所有路由器都将自己的IP地址填入IP头部的选项部分，就可以跟踪数据报的传递路径\n- 时间戳：告诉每个路由器都将数据报被转发的时间(或时间与IP对)填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间\n- 松散源路由选择：指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器\n- 严格源路由选择：和松散源路由选择类似，不过数据报只能经过指定的路由器\n\n## tcpdump抓包\n\n在用telnet远程登录的时候，遇到一些问题。\n\n![](/pic/telnet问题.png)\n\n提示我无法连接到远程主机，连接被拒绝，上网查了一下发现telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。因此需要打开telnet服务。\n\n1.安装openbsd-inetd\n\nsudo apt-get install openbsd-inetd\n\n2.安装telnetd\n\nsudo apt-get install telnetd\n\n3.重启openbsd-inetd\n\nsudo /etc/init.d/openbsd-inetd restart\n\n4.查看telnet运行状态     没开启之前输出为空\n\nsudo netstat -a | grep telnet\n\n![](/pic/telnet测试.png)\n\n这时候开始进行抓包\n\nsudo tcpdump -i lo -ntx    #抓取本地回路上的数据包\n\n开启另外一个终端执行telnet命令\n\n![](/pic/IP抓包telnet.png)\n\n用tcpdump抓取到的第一个关于telmet的数据包(开头有两个DNS请求和应答的数据包)\n\n![](/pic/IP抓包tcpdump.png)\n\n该数据包描述的是一个IP数据报，由于使用telnet登录本机，所以IP数据报的源端IP地址和目的端IP地址都是\n\n“127.0.0.1”。telnet服务器程序使用的端口号是23，而telnet客户端程序使用临时端口号34620与服务器通信。\n\n\"Flags\"、“seq”、“win”、“options”都是TCP头部的信息，这里不展开。“length”描述的是IP数据报所携带的应用程序数据的长度。\n\n由上图可知，这个数据包共60字节，其中前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据\n\n分析IP头部：\n\n| 十六进制数 | 十进制表示 | IP头部信息                   |\n| ---------- | :--------- | :--------------------------- |\n| 0x4        | 4          | IP                           |\n| 0x5        | 5          | 头部长度为5个32位(20字节)    |\n| 0x10       |            | TOS选项中最小延时服务被开启  |\n| 0x003c     | 60         | 数据报总长度，60字节         |\n| 0x3174     |            | 数据报标识                   |\n| 0x4        |            | 设置了禁止                   |\n| 0x000      | 0          | 分片偏移                     |\n| 0x40       | 64         | TTL被设为64                  |\n| 0x06       | 6          | 协议字段为6，表示上层协议是T |\n| 0x0b36     |            | IP头部校验和                 |\n| 0x7f000001 |            | 32位源端IP地址127.0.0.1      |\n| 0x7f000001 |            | 32位目的端IP地址127.0.0.1    |\n\n由此可见，IPv4头部结构和分析的完全吻合，并且知道了telnet服务选择使用具有最小延时的服务，并且默认使用的传输层协议是TCP协议，并且这个IP数据报没有分片，因为它没有携带任何应用程序数据。\n\n## IP分片\n\n![](/pic/IP分片.png)\n\n第一个IP分片长度1500字节，IP头部设置了MF标志\n\n第二个IP分片长度21字节，没有设置MF标志，因为已经是最后一个分片\n\n需要注意的是：第二个IP分片里面没有ICMP的头部信息，因为IP模块重组ICMP报文的只需要一份ICMP头部信息\n\n通过抓包来分析IP分片\n\nping www.baidu.com -s 1473     #指定放1473字节的数据\n\n抓包的IP数据包如下：\n\n![](/pic/IP分片抓包.png)\n\n这两个数据包标识值都是46843，说明他们是同一个IP数据报的分片。第一个分片的片偏移值是0，而第二个是1480。第一个分片设置了MF标志标识(flags[+])还有后续分片,第二个没设置说明是最后一个分片。两个分片的长度分别是1500和21字节。\n\n由此可见，通过tcpdump抓包的分析和图片的分析完全一致。\n\n## IP路由\n\nIP协议的核心任务是数据报的路由，也就是决定数据报到目标机器的路径。\n\n#### 工作流程图\n\n![](/pic/IP模块工作流程图.png)\n\n此图的具体分析可以参考游双老师的《Linux高性能服务器编程》P23\n\n#### 路由机制\n\n首先了解一下路由表，可以用route命令或者netstat查看\n\n![](/pic/route命令.png)\n\n各个字段的解释：\n\n![](/pic/路由表.png)\n\n接下来需要考虑的问题：路由表如何按照IP地址进行分类？或者说给定数据报的IP地址，将匹配路由表中的哪一项？这也就是IP的路由机制，有三个步骤。\n\n- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。如果找到，就使用路由项，没找到就跳转步骤2\n- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址(例如route命令展示的路由表的第三项)，如果找到就使用该路由项，没找到就跳转步骤3\n- 选择默认路由项，这通常意味着数据报的下一跳路由是网关\n\n也就是说，对于本机，所有发送到IP地址为192.168.152.*的机器的IP数据报都可以直接发送到目标机器，而所有访问因特网的请求都将通过网关来转发。\n\n#### 路由表更新\n\n可以用route命令来修改路由表(路由缓存  加-C选项)\n\nsudo route add -host 192.168.152.1 dev ens33  \n\n添加主机192.168.152.1对应的路由项，以后所有从本机发送到192.168.152.1的IP数据报将通过网卡ens33直接发送到目标机器的接收网卡。\n\nsudo route del -net 192.168.152.0 netmask 255.255.255.0\n\n删除网络192.168.152.0对应的路由项，这样主机就无法访问该局域网上的任何其他机器\n\nsudo route del  default\n\n删除默认路由项，这样就无法访问因特网\n\n\n\n通过route命令和其他工具修改的路由表，都是静态的路由更新方式。对于大型路由器，通常是通过BGP、RIP、OSPF等协议来发现路径，并更新自己的路由表，这样式动态的、自动的。\n\n#### IP转发\n\n路由器都能执行数据报的转发操作，而主机一般只能发送和接收数据报，因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。\n\n可以修改这个参数使主机具有数据报转发能力\n\n1.用root身份   sudo  su\n\n2.echo 1 > /proc/sys/net/ipv4/ip_forward\n\n路由器或主机进行数据报转发的操作：\n\n- 检查数据报头部的TTL值，为0就丢弃\n- 查看数据报头部的严格源路由选择项。如果该选项被设置，就检测数据报的目标IP是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端。\n- 如果有必要，就给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一个路由器\n- 将TTL值减1\n- 处理IP头部选项\n- 如果有必要，则执行IP分片操作\n\n#### 重定向\n\n![](/pic/ICMP重定向报文.png)\n\n重定向报文类型值是5，代码字段有4个可选值，代表不同的重定向类型。\n\n/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文\n\n/proc/sys/net/ipv4/conf/all/accept_redirects内核参数指定是否允许接收ICMP重定向报文\n\n一般，主机只能接收，路由器只能发送。\n\n## IPv6（RFC 2460）\n\n不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如\n\n- 增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制\n- 引入自动配置功能，使得局域网管理更方便\n- 增加专门的网络安全功能\n\n![](/pic/IPv6头部.png)\n\n4位版本号：指定IP协议的版本。对IPv6来说，值是6\n\n8位通信类型：指定数据流通信类型或优先级，和IPv4中的TOS类似\n\n20位流标签：IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输\n\n16位净荷长度：IPv6扩展头部和应用程序数据长度之和，不包括固定头部长度\n\n8位下一个包头：指出紧跟IPv6固定头部后的包头类型，如扩展头或某个上层协议头\n\n8位跳数限制：类似于IPv4中的TTL\n\nIPv6用128位(16字节)来表示IP地址，IP地址总数达到2^128个\n\n32位表示的IPv4地址一般用点分十进制来表示，而IPv6地址一般用十六进制字符串来表示\n\n\"FE80:0000:0000:0000:1234 :5678:0000:0012\"用：分割成8组，每组16位\n\n\"FE80:​:1234 :5678:0000:0012​\" 零压缩法------省略连续的、全零的组，一个地址中只能用一次，所以后面的零没压缩\n\nIPv6扩展头部\n\n![](/pic/IPv6扩展头部.png)\n\n","slug":"IP协议","published":1,"updated":"2021-12-06T05:30:36.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7l001496caapq00y0p","content":"<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>\n<p>无状态：IP通信双方不同步传输数据的状态信息，因此所有的IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。UDP和HTTP都是无状态</p>\n<ul>\n<li>缺点：无法处理乱序和重复的IP数据报，因为数据报之间没有任何上下文关系<ul>\n<li>比如发送端发送的第N个IP数据报可能比第N+1个数据报后到达，就造成乱序</li>\n<li>同一个IP数据报也可能经过不同的路径多次到达接收端</li>\n</ul>\n</li>\n<li>优点：简单、高效，无须为保持通信的状态分配一些内核资源，也无须每次传输数据都携带状态信息</li>\n</ul>\n<p>无连接：IP通信双方不长久地维持对方的任何信息。因此，上层协议每次发送数据的时候，都必须明确指定对方的IP地址</p>\n<p>不可靠：IP协议不能保证IP数据报准确到达接收端，只是尽最大努力交付，很多情况都能导致IP数据报发送失败。</p>\n<ul>\n<li>某个中转路由器发现IP数据报在网络上存活时间太长(根据IP头部TTL字段)，那它将被丢弃，并返回一个ICMP错误信息(超时错误)给发送端。</li>\n<li>接收端发现收到的IP数据报不正确(通过CRC校验)，它也将丢弃之，并返回一个ICMP错误信息(IP头部参数错误)给发送端。</li>\n</ul>\n<p>无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议(比如TCP)需要自己实现数据确认、超时重传等机制来达到可靠传输的目的。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"IPv4头部\"><a href=\"#IPv4头部\" class=\"headerlink\" title=\"IPv4头部\"></a>IPv4头部</h2><p><img src=\"/pic/IPv4%E5%A4%B4%E9%83%A8.png\" alt=\"\"></p>\n<p>4位版本号：指定IP协议的版本。对IPv4来说，值是4。其他IPv4协议的扩展版本(如SIP协议和PIP协议)则具有不同的版本号(头部也和上图不一样)</p>\n<p>4位头部长度：标识该IP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以IP头部最长是60字节</p>\n<p>8位服务类型：包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。4位的TOS字段分别表示：最小延时、最大吞吐量、最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要设置。比如像ssh和telnet这样的登录程序需要最小延时服务，文件传输程序则需要最大吞吐量服务。</p>\n<p>16位总长度：整个IP数据报的长度，以字节为单位，因此IP数据报最大长度时65535字节，但由于MTU的限制，长度超过MTU的数据报都将被分片传输。</p>\n<p>16位标识：唯一地标识主机发送的每一个数据报。其初始值由系统随机生成，每发送一个数据包，值就加1.该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都有相同的标识值。</p>\n<p>3位标志字段：第一位保留，第二位表示“禁止分片”，在这种情况下，如果IP数据报长度超过MTU，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位表示“更多分片”，除了数据报的最后一个分片外，其他分片都要置1</p>\n<p>13位分片偏移：是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位(乘8)后得到的，由于这个原因，<strong>除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍</strong>。</p>\n<p>8位生存时间（TTL）：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(通常是64)，数据报每经过一个路由，值就减1。减到0的时候就丢弃数据报，返回ICMP差错报文，<strong>TTL的值可以防止数据报陷入路由循环</strong>。</p>\n<p>8位协议：用来区分上层协议。ICMP是1，TCP是6，UDP是17</p>\n<p>16位头部校验和：由发送端填充，接收端对其使用CRC算法以验算IP数据报头部(只检验头部)在传输过程中是否损坏</p>\n<p>32位的源端IP和目的端IP用来标识数据报的发送端和接收端。</p>\n<p>IPv4最后一个字段是可变长的可选信息。最多包含40字节，列举常用的，更多可以看RFC 1393</p>\n<ul>\n<li>记录路由，告诉数据报途径的所有路由器都将自己的IP地址填入IP头部的选项部分，就可以跟踪数据报的传递路径</li>\n<li>时间戳：告诉每个路由器都将数据报被转发的时间(或时间与IP对)填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间</li>\n<li>松散源路由选择：指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器</li>\n<li>严格源路由选择：和松散源路由选择类似，不过数据报只能经过指定的路由器</li>\n</ul>\n<h2 id=\"tcpdump抓包\"><a href=\"#tcpdump抓包\" class=\"headerlink\" title=\"tcpdump抓包\"></a>tcpdump抓包</h2><p>在用telnet远程登录的时候，遇到一些问题。</p>\n<p><img src=\"/pic/telnet%E9%97%AE%E9%A2%98.png\" alt=\"\"></p>\n<p>提示我无法连接到远程主机，连接被拒绝，上网查了一下发现telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。因此需要打开telnet服务。</p>\n<p>1.安装openbsd-inetd</p>\n<p>sudo apt-get install openbsd-inetd</p>\n<p>2.安装telnetd</p>\n<p>sudo apt-get install telnetd</p>\n<p>3.重启openbsd-inetd</p>\n<p>sudo /etc/init.d/openbsd-inetd restart</p>\n<p>4.查看telnet运行状态     没开启之前输出为空</p>\n<p>sudo netstat -a | grep telnet</p>\n<p><img src=\"/pic/telnet%E6%B5%8B%E8%AF%95.png\" alt=\"\"></p>\n<p>这时候开始进行抓包</p>\n<p>sudo tcpdump -i lo -ntx    #抓取本地回路上的数据包</p>\n<p>开启另外一个终端执行telnet命令</p>\n<p><img src=\"/pic/IP%E6%8A%93%E5%8C%85telnet.png\" alt=\"\"></p>\n<p>用tcpdump抓取到的第一个关于telmet的数据包(开头有两个DNS请求和应答的数据包)</p>\n<p><img src=\"/pic/IP%E6%8A%93%E5%8C%85tcpdump.png\" alt=\"\"></p>\n<p>该数据包描述的是一个IP数据报，由于使用telnet登录本机，所以IP数据报的源端IP地址和目的端IP地址都是</p>\n<p>“127.0.0.1”。telnet服务器程序使用的端口号是23，而telnet客户端程序使用临时端口号34620与服务器通信。</p>\n<p>“Flags”、“seq”、“win”、“options”都是TCP头部的信息，这里不展开。“length”描述的是IP数据报所携带的应用程序数据的长度。</p>\n<p>由上图可知，这个数据包共60字节，其中前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据</p>\n<p>分析IP头部：</p>\n<table>\n<thead>\n<tr>\n<th>十六进制数</th>\n<th align=\"left\">十进制表示</th>\n<th align=\"left\">IP头部信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x4</td>\n<td align=\"left\">4</td>\n<td align=\"left\">IP</td>\n</tr>\n<tr>\n<td>0x5</td>\n<td align=\"left\">5</td>\n<td align=\"left\">头部长度为5个32位(20字节)</td>\n</tr>\n<tr>\n<td>0x10</td>\n<td align=\"left\"></td>\n<td align=\"left\">TOS选项中最小延时服务被开启</td>\n</tr>\n<tr>\n<td>0x003c</td>\n<td align=\"left\">60</td>\n<td align=\"left\">数据报总长度，60字节</td>\n</tr>\n<tr>\n<td>0x3174</td>\n<td align=\"left\"></td>\n<td align=\"left\">数据报标识</td>\n</tr>\n<tr>\n<td>0x4</td>\n<td align=\"left\"></td>\n<td align=\"left\">设置了禁止</td>\n</tr>\n<tr>\n<td>0x000</td>\n<td align=\"left\">0</td>\n<td align=\"left\">分片偏移</td>\n</tr>\n<tr>\n<td>0x40</td>\n<td align=\"left\">64</td>\n<td align=\"left\">TTL被设为64</td>\n</tr>\n<tr>\n<td>0x06</td>\n<td align=\"left\">6</td>\n<td align=\"left\">协议字段为6，表示上层协议是T</td>\n</tr>\n<tr>\n<td>0x0b36</td>\n<td align=\"left\"></td>\n<td align=\"left\">IP头部校验和</td>\n</tr>\n<tr>\n<td>0x7f000001</td>\n<td align=\"left\"></td>\n<td align=\"left\">32位源端IP地址127.0.0.1</td>\n</tr>\n<tr>\n<td>0x7f000001</td>\n<td align=\"left\"></td>\n<td align=\"left\">32位目的端IP地址127.0.0.1</td>\n</tr>\n</tbody></table>\n<p>由此可见，IPv4头部结构和分析的完全吻合，并且知道了telnet服务选择使用具有最小延时的服务，并且默认使用的传输层协议是TCP协议，并且这个IP数据报没有分片，因为它没有携带任何应用程序数据。</p>\n<h2 id=\"IP分片\"><a href=\"#IP分片\" class=\"headerlink\" title=\"IP分片\"></a>IP分片</h2><p><img src=\"/pic/IP%E5%88%86%E7%89%87.png\" alt=\"\"></p>\n<p>第一个IP分片长度1500字节，IP头部设置了MF标志</p>\n<p>第二个IP分片长度21字节，没有设置MF标志，因为已经是最后一个分片</p>\n<p>需要注意的是：第二个IP分片里面没有ICMP的头部信息，因为IP模块重组ICMP报文的只需要一份ICMP头部信息</p>\n<p>通过抓包来分析IP分片</p>\n<p>ping <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a> -s 1473     #指定放1473字节的数据</p>\n<p>抓包的IP数据包如下：</p>\n<p><img src=\"/pic/IP%E5%88%86%E7%89%87%E6%8A%93%E5%8C%85.png\" alt=\"\"></p>\n<p>这两个数据包标识值都是46843，说明他们是同一个IP数据报的分片。第一个分片的片偏移值是0，而第二个是1480。第一个分片设置了MF标志标识(flags[+])还有后续分片,第二个没设置说明是最后一个分片。两个分片的长度分别是1500和21字节。</p>\n<p>由此可见，通过tcpdump抓包的分析和图片的分析完全一致。</p>\n<h2 id=\"IP路由\"><a href=\"#IP路由\" class=\"headerlink\" title=\"IP路由\"></a>IP路由</h2><p>IP协议的核心任务是数据报的路由，也就是决定数据报到目标机器的路径。</p>\n<h4 id=\"工作流程图\"><a href=\"#工作流程图\" class=\"headerlink\" title=\"工作流程图\"></a>工作流程图</h4><p><img src=\"/pic/IP%E6%A8%A1%E5%9D%97%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"\"></p>\n<p>此图的具体分析可以参考游双老师的《Linux高性能服务器编程》P23</p>\n<h4 id=\"路由机制\"><a href=\"#路由机制\" class=\"headerlink\" title=\"路由机制\"></a>路由机制</h4><p>首先了解一下路由表，可以用route命令或者netstat查看</p>\n<p><img src=\"/pic/route%E5%91%BD%E4%BB%A4.png\" alt=\"\"></p>\n<p>各个字段的解释：</p>\n<p><img src=\"/pic/%E8%B7%AF%E7%94%B1%E8%A1%A8.png\" alt=\"\"></p>\n<p>接下来需要考虑的问题：路由表如何按照IP地址进行分类？或者说给定数据报的IP地址，将匹配路由表中的哪一项？这也就是IP的路由机制，有三个步骤。</p>\n<ul>\n<li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。如果找到，就使用路由项，没找到就跳转步骤2</li>\n<li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址(例如route命令展示的路由表的第三项)，如果找到就使用该路由项，没找到就跳转步骤3</li>\n<li>选择默认路由项，这通常意味着数据报的下一跳路由是网关</li>\n</ul>\n<p>也就是说，对于本机，所有发送到IP地址为192.168.152.*的机器的IP数据报都可以直接发送到目标机器，而所有访问因特网的请求都将通过网关来转发。</p>\n<h4 id=\"路由表更新\"><a href=\"#路由表更新\" class=\"headerlink\" title=\"路由表更新\"></a>路由表更新</h4><p>可以用route命令来修改路由表(路由缓存  加-C选项)</p>\n<p>sudo route add -host 192.168.152.1 dev ens33  </p>\n<p>添加主机192.168.152.1对应的路由项，以后所有从本机发送到192.168.152.1的IP数据报将通过网卡ens33直接发送到目标机器的接收网卡。</p>\n<p>sudo route del -net 192.168.152.0 netmask 255.255.255.0</p>\n<p>删除网络192.168.152.0对应的路由项，这样主机就无法访问该局域网上的任何其他机器</p>\n<p>sudo route del  default</p>\n<p>删除默认路由项，这样就无法访问因特网</p>\n<p>通过route命令和其他工具修改的路由表，都是静态的路由更新方式。对于大型路由器，通常是通过BGP、RIP、OSPF等协议来发现路径，并更新自己的路由表，这样式动态的、自动的。</p>\n<h4 id=\"IP转发\"><a href=\"#IP转发\" class=\"headerlink\" title=\"IP转发\"></a>IP转发</h4><p>路由器都能执行数据报的转发操作，而主机一般只能发送和接收数据报，因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。</p>\n<p>可以修改这个参数使主机具有数据报转发能力</p>\n<p>1.用root身份   sudo  su</p>\n<p>2.echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p>\n<p>路由器或主机进行数据报转发的操作：</p>\n<ul>\n<li>检查数据报头部的TTL值，为0就丢弃</li>\n<li>查看数据报头部的严格源路由选择项。如果该选项被设置，就检测数据报的目标IP是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端。</li>\n<li>如果有必要，就给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一个路由器</li>\n<li>将TTL值减1</li>\n<li>处理IP头部选项</li>\n<li>如果有必要，则执行IP分片操作</li>\n</ul>\n<h4 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h4><p><img src=\"/pic/ICMP%E9%87%8D%E5%AE%9A%E5%90%91%E6%8A%A5%E6%96%87.png\" alt=\"\"></p>\n<p>重定向报文类型值是5，代码字段有4个可选值，代表不同的重定向类型。</p>\n<p>/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文</p>\n<p>/proc/sys/net/ipv4/conf/all/accept_redirects内核参数指定是否允许接收ICMP重定向报文</p>\n<p>一般，主机只能接收，路由器只能发送。</p>\n<h2 id=\"IPv6（RFC-2460）\"><a href=\"#IPv6（RFC-2460）\" class=\"headerlink\" title=\"IPv6（RFC 2460）\"></a>IPv6（RFC 2460）</h2><p>不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如</p>\n<ul>\n<li>增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制</li>\n<li>引入自动配置功能，使得局域网管理更方便</li>\n<li>增加专门的网络安全功能</li>\n</ul>\n<p><img src=\"/pic/IPv6%E5%A4%B4%E9%83%A8.png\" alt=\"\"></p>\n<p>4位版本号：指定IP协议的版本。对IPv6来说，值是6</p>\n<p>8位通信类型：指定数据流通信类型或优先级，和IPv4中的TOS类似</p>\n<p>20位流标签：IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输</p>\n<p>16位净荷长度：IPv6扩展头部和应用程序数据长度之和，不包括固定头部长度</p>\n<p>8位下一个包头：指出紧跟IPv6固定头部后的包头类型，如扩展头或某个上层协议头</p>\n<p>8位跳数限制：类似于IPv4中的TTL</p>\n<p>IPv6用128位(16字节)来表示IP地址，IP地址总数达到2^128个</p>\n<p>32位表示的IPv4地址一般用点分十进制来表示，而IPv6地址一般用十六进制字符串来表示</p>\n<p>“FE80:0000:0000:0000:1234 :5678:0000:0012”用：分割成8组，每组16位</p>\n<p>“FE80:​:1234 :5678:0000:0012​” 零压缩法——省略连续的、全零的组，一个地址中只能用一次，所以后面的零没压缩</p>\n<p>IPv6扩展头部</p>\n<p><img src=\"/pic/IPv6%E6%89%A9%E5%B1%95%E5%A4%B4%E9%83%A8.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>\n<p>无状态：IP通信双方不同步传输数据的状态信息，因此所有的IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。UDP和HTTP都是无状态</p>\n<ul>\n<li>缺点：无法处理乱序和重复的IP数据报，因为数据报之间没有任何上下文关系<ul>\n<li>比如发送端发送的第N个IP数据报可能比第N+1个数据报后到达，就造成乱序</li>\n<li>同一个IP数据报也可能经过不同的路径多次到达接收端</li>\n</ul>\n</li>\n<li>优点：简单、高效，无须为保持通信的状态分配一些内核资源，也无须每次传输数据都携带状态信息</li>\n</ul>\n<p>无连接：IP通信双方不长久地维持对方的任何信息。因此，上层协议每次发送数据的时候，都必须明确指定对方的IP地址</p>\n<p>不可靠：IP协议不能保证IP数据报准确到达接收端，只是尽最大努力交付，很多情况都能导致IP数据报发送失败。</p>\n<ul>\n<li>某个中转路由器发现IP数据报在网络上存活时间太长(根据IP头部TTL字段)，那它将被丢弃，并返回一个ICMP错误信息(超时错误)给发送端。</li>\n<li>接收端发现收到的IP数据报不正确(通过CRC校验)，它也将丢弃之，并返回一个ICMP错误信息(IP头部参数错误)给发送端。</li>\n</ul>\n<p>无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议(比如TCP)需要自己实现数据确认、超时重传等机制来达到可靠传输的目的。</p>","more":"<h2 id=\"IPv4头部\"><a href=\"#IPv4头部\" class=\"headerlink\" title=\"IPv4头部\"></a>IPv4头部</h2><p><img src=\"/pic/IPv4%E5%A4%B4%E9%83%A8.png\" alt=\"\"></p>\n<p>4位版本号：指定IP协议的版本。对IPv4来说，值是4。其他IPv4协议的扩展版本(如SIP协议和PIP协议)则具有不同的版本号(头部也和上图不一样)</p>\n<p>4位头部长度：标识该IP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以IP头部最长是60字节</p>\n<p>8位服务类型：包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。4位的TOS字段分别表示：最小延时、最大吞吐量、最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要设置。比如像ssh和telnet这样的登录程序需要最小延时服务，文件传输程序则需要最大吞吐量服务。</p>\n<p>16位总长度：整个IP数据报的长度，以字节为单位，因此IP数据报最大长度时65535字节，但由于MTU的限制，长度超过MTU的数据报都将被分片传输。</p>\n<p>16位标识：唯一地标识主机发送的每一个数据报。其初始值由系统随机生成，每发送一个数据包，值就加1.该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都有相同的标识值。</p>\n<p>3位标志字段：第一位保留，第二位表示“禁止分片”，在这种情况下，如果IP数据报长度超过MTU，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位表示“更多分片”，除了数据报的最后一个分片外，其他分片都要置1</p>\n<p>13位分片偏移：是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位(乘8)后得到的，由于这个原因，<strong>除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍</strong>。</p>\n<p>8位生存时间（TTL）：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(通常是64)，数据报每经过一个路由，值就减1。减到0的时候就丢弃数据报，返回ICMP差错报文，<strong>TTL的值可以防止数据报陷入路由循环</strong>。</p>\n<p>8位协议：用来区分上层协议。ICMP是1，TCP是6，UDP是17</p>\n<p>16位头部校验和：由发送端填充，接收端对其使用CRC算法以验算IP数据报头部(只检验头部)在传输过程中是否损坏</p>\n<p>32位的源端IP和目的端IP用来标识数据报的发送端和接收端。</p>\n<p>IPv4最后一个字段是可变长的可选信息。最多包含40字节，列举常用的，更多可以看RFC 1393</p>\n<ul>\n<li>记录路由，告诉数据报途径的所有路由器都将自己的IP地址填入IP头部的选项部分，就可以跟踪数据报的传递路径</li>\n<li>时间戳：告诉每个路由器都将数据报被转发的时间(或时间与IP对)填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间</li>\n<li>松散源路由选择：指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器</li>\n<li>严格源路由选择：和松散源路由选择类似，不过数据报只能经过指定的路由器</li>\n</ul>\n<h2 id=\"tcpdump抓包\"><a href=\"#tcpdump抓包\" class=\"headerlink\" title=\"tcpdump抓包\"></a>tcpdump抓包</h2><p>在用telnet远程登录的时候，遇到一些问题。</p>\n<p><img src=\"/pic/telnet%E9%97%AE%E9%A2%98.png\" alt=\"\"></p>\n<p>提示我无法连接到远程主机，连接被拒绝，上网查了一下发现telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。因此需要打开telnet服务。</p>\n<p>1.安装openbsd-inetd</p>\n<p>sudo apt-get install openbsd-inetd</p>\n<p>2.安装telnetd</p>\n<p>sudo apt-get install telnetd</p>\n<p>3.重启openbsd-inetd</p>\n<p>sudo /etc/init.d/openbsd-inetd restart</p>\n<p>4.查看telnet运行状态     没开启之前输出为空</p>\n<p>sudo netstat -a | grep telnet</p>\n<p><img src=\"/pic/telnet%E6%B5%8B%E8%AF%95.png\" alt=\"\"></p>\n<p>这时候开始进行抓包</p>\n<p>sudo tcpdump -i lo -ntx    #抓取本地回路上的数据包</p>\n<p>开启另外一个终端执行telnet命令</p>\n<p><img src=\"/pic/IP%E6%8A%93%E5%8C%85telnet.png\" alt=\"\"></p>\n<p>用tcpdump抓取到的第一个关于telmet的数据包(开头有两个DNS请求和应答的数据包)</p>\n<p><img src=\"/pic/IP%E6%8A%93%E5%8C%85tcpdump.png\" alt=\"\"></p>\n<p>该数据包描述的是一个IP数据报，由于使用telnet登录本机，所以IP数据报的源端IP地址和目的端IP地址都是</p>\n<p>“127.0.0.1”。telnet服务器程序使用的端口号是23，而telnet客户端程序使用临时端口号34620与服务器通信。</p>\n<p>“Flags”、“seq”、“win”、“options”都是TCP头部的信息，这里不展开。“length”描述的是IP数据报所携带的应用程序数据的长度。</p>\n<p>由上图可知，这个数据包共60字节，其中前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据</p>\n<p>分析IP头部：</p>\n<table>\n<thead>\n<tr>\n<th>十六进制数</th>\n<th align=\"left\">十进制表示</th>\n<th align=\"left\">IP头部信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x4</td>\n<td align=\"left\">4</td>\n<td align=\"left\">IP</td>\n</tr>\n<tr>\n<td>0x5</td>\n<td align=\"left\">5</td>\n<td align=\"left\">头部长度为5个32位(20字节)</td>\n</tr>\n<tr>\n<td>0x10</td>\n<td align=\"left\"></td>\n<td align=\"left\">TOS选项中最小延时服务被开启</td>\n</tr>\n<tr>\n<td>0x003c</td>\n<td align=\"left\">60</td>\n<td align=\"left\">数据报总长度，60字节</td>\n</tr>\n<tr>\n<td>0x3174</td>\n<td align=\"left\"></td>\n<td align=\"left\">数据报标识</td>\n</tr>\n<tr>\n<td>0x4</td>\n<td align=\"left\"></td>\n<td align=\"left\">设置了禁止</td>\n</tr>\n<tr>\n<td>0x000</td>\n<td align=\"left\">0</td>\n<td align=\"left\">分片偏移</td>\n</tr>\n<tr>\n<td>0x40</td>\n<td align=\"left\">64</td>\n<td align=\"left\">TTL被设为64</td>\n</tr>\n<tr>\n<td>0x06</td>\n<td align=\"left\">6</td>\n<td align=\"left\">协议字段为6，表示上层协议是T</td>\n</tr>\n<tr>\n<td>0x0b36</td>\n<td align=\"left\"></td>\n<td align=\"left\">IP头部校验和</td>\n</tr>\n<tr>\n<td>0x7f000001</td>\n<td align=\"left\"></td>\n<td align=\"left\">32位源端IP地址127.0.0.1</td>\n</tr>\n<tr>\n<td>0x7f000001</td>\n<td align=\"left\"></td>\n<td align=\"left\">32位目的端IP地址127.0.0.1</td>\n</tr>\n</tbody></table>\n<p>由此可见，IPv4头部结构和分析的完全吻合，并且知道了telnet服务选择使用具有最小延时的服务，并且默认使用的传输层协议是TCP协议，并且这个IP数据报没有分片，因为它没有携带任何应用程序数据。</p>\n<h2 id=\"IP分片\"><a href=\"#IP分片\" class=\"headerlink\" title=\"IP分片\"></a>IP分片</h2><p><img src=\"/pic/IP%E5%88%86%E7%89%87.png\" alt=\"\"></p>\n<p>第一个IP分片长度1500字节，IP头部设置了MF标志</p>\n<p>第二个IP分片长度21字节，没有设置MF标志，因为已经是最后一个分片</p>\n<p>需要注意的是：第二个IP分片里面没有ICMP的头部信息，因为IP模块重组ICMP报文的只需要一份ICMP头部信息</p>\n<p>通过抓包来分析IP分片</p>\n<p>ping <a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a> -s 1473     #指定放1473字节的数据</p>\n<p>抓包的IP数据包如下：</p>\n<p><img src=\"/pic/IP%E5%88%86%E7%89%87%E6%8A%93%E5%8C%85.png\" alt=\"\"></p>\n<p>这两个数据包标识值都是46843，说明他们是同一个IP数据报的分片。第一个分片的片偏移值是0，而第二个是1480。第一个分片设置了MF标志标识(flags[+])还有后续分片,第二个没设置说明是最后一个分片。两个分片的长度分别是1500和21字节。</p>\n<p>由此可见，通过tcpdump抓包的分析和图片的分析完全一致。</p>\n<h2 id=\"IP路由\"><a href=\"#IP路由\" class=\"headerlink\" title=\"IP路由\"></a>IP路由</h2><p>IP协议的核心任务是数据报的路由，也就是决定数据报到目标机器的路径。</p>\n<h4 id=\"工作流程图\"><a href=\"#工作流程图\" class=\"headerlink\" title=\"工作流程图\"></a>工作流程图</h4><p><img src=\"/pic/IP%E6%A8%A1%E5%9D%97%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"\"></p>\n<p>此图的具体分析可以参考游双老师的《Linux高性能服务器编程》P23</p>\n<h4 id=\"路由机制\"><a href=\"#路由机制\" class=\"headerlink\" title=\"路由机制\"></a>路由机制</h4><p>首先了解一下路由表，可以用route命令或者netstat查看</p>\n<p><img src=\"/pic/route%E5%91%BD%E4%BB%A4.png\" alt=\"\"></p>\n<p>各个字段的解释：</p>\n<p><img src=\"/pic/%E8%B7%AF%E7%94%B1%E8%A1%A8.png\" alt=\"\"></p>\n<p>接下来需要考虑的问题：路由表如何按照IP地址进行分类？或者说给定数据报的IP地址，将匹配路由表中的哪一项？这也就是IP的路由机制，有三个步骤。</p>\n<ul>\n<li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。如果找到，就使用路由项，没找到就跳转步骤2</li>\n<li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址(例如route命令展示的路由表的第三项)，如果找到就使用该路由项，没找到就跳转步骤3</li>\n<li>选择默认路由项，这通常意味着数据报的下一跳路由是网关</li>\n</ul>\n<p>也就是说，对于本机，所有发送到IP地址为192.168.152.*的机器的IP数据报都可以直接发送到目标机器，而所有访问因特网的请求都将通过网关来转发。</p>\n<h4 id=\"路由表更新\"><a href=\"#路由表更新\" class=\"headerlink\" title=\"路由表更新\"></a>路由表更新</h4><p>可以用route命令来修改路由表(路由缓存  加-C选项)</p>\n<p>sudo route add -host 192.168.152.1 dev ens33  </p>\n<p>添加主机192.168.152.1对应的路由项，以后所有从本机发送到192.168.152.1的IP数据报将通过网卡ens33直接发送到目标机器的接收网卡。</p>\n<p>sudo route del -net 192.168.152.0 netmask 255.255.255.0</p>\n<p>删除网络192.168.152.0对应的路由项，这样主机就无法访问该局域网上的任何其他机器</p>\n<p>sudo route del  default</p>\n<p>删除默认路由项，这样就无法访问因特网</p>\n<p>通过route命令和其他工具修改的路由表，都是静态的路由更新方式。对于大型路由器，通常是通过BGP、RIP、OSPF等协议来发现路径，并更新自己的路由表，这样式动态的、自动的。</p>\n<h4 id=\"IP转发\"><a href=\"#IP转发\" class=\"headerlink\" title=\"IP转发\"></a>IP转发</h4><p>路由器都能执行数据报的转发操作，而主机一般只能发送和接收数据报，因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。</p>\n<p>可以修改这个参数使主机具有数据报转发能力</p>\n<p>1.用root身份   sudo  su</p>\n<p>2.echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p>\n<p>路由器或主机进行数据报转发的操作：</p>\n<ul>\n<li>检查数据报头部的TTL值，为0就丢弃</li>\n<li>查看数据报头部的严格源路由选择项。如果该选项被设置，就检测数据报的目标IP是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端。</li>\n<li>如果有必要，就给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一个路由器</li>\n<li>将TTL值减1</li>\n<li>处理IP头部选项</li>\n<li>如果有必要，则执行IP分片操作</li>\n</ul>\n<h4 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h4><p><img src=\"/pic/ICMP%E9%87%8D%E5%AE%9A%E5%90%91%E6%8A%A5%E6%96%87.png\" alt=\"\"></p>\n<p>重定向报文类型值是5，代码字段有4个可选值，代表不同的重定向类型。</p>\n<p>/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文</p>\n<p>/proc/sys/net/ipv4/conf/all/accept_redirects内核参数指定是否允许接收ICMP重定向报文</p>\n<p>一般，主机只能接收，路由器只能发送。</p>\n<h2 id=\"IPv6（RFC-2460）\"><a href=\"#IPv6（RFC-2460）\" class=\"headerlink\" title=\"IPv6（RFC 2460）\"></a>IPv6（RFC 2460）</h2><p>不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如</p>\n<ul>\n<li>增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制</li>\n<li>引入自动配置功能，使得局域网管理更方便</li>\n<li>增加专门的网络安全功能</li>\n</ul>\n<p><img src=\"/pic/IPv6%E5%A4%B4%E9%83%A8.png\" alt=\"\"></p>\n<p>4位版本号：指定IP协议的版本。对IPv6来说，值是6</p>\n<p>8位通信类型：指定数据流通信类型或优先级，和IPv4中的TOS类似</p>\n<p>20位流标签：IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输</p>\n<p>16位净荷长度：IPv6扩展头部和应用程序数据长度之和，不包括固定头部长度</p>\n<p>8位下一个包头：指出紧跟IPv6固定头部后的包头类型，如扩展头或某个上层协议头</p>\n<p>8位跳数限制：类似于IPv4中的TTL</p>\n<p>IPv6用128位(16字节)来表示IP地址，IP地址总数达到2^128个</p>\n<p>32位表示的IPv4地址一般用点分十进制来表示，而IPv6地址一般用十六进制字符串来表示</p>\n<p>“FE80:0000:0000:0000:1234 :5678:0000:0012”用：分割成8组，每组16位</p>\n<p>“FE80:​:1234 :5678:0000:0012​” 零压缩法——省略连续的、全零的组，一个地址中只能用一次，所以后面的零没压缩</p>\n<p>IPv6扩展头部</p>\n<p><img src=\"/pic/IPv6%E6%89%A9%E5%B1%95%E5%A4%B4%E9%83%A8.png\" alt=\"\"></p>"},{"title":"poll","date":"2018-11-30T13:51:59.000Z","_content":"\n## 模型特点\n\n1.和select类似，但是突破了并发量的限制。\n2.采用的依旧是轮询\n3.采用struct pollfd结构体记录fd的状态\n\n<!-- more -->\n\n## 具体使用\n\n**int poll(struct pollfd *fds, nfds_t nfds, int timeout);**\n\n成功返回就绪的文件描述符个数，失败返回-1并设置errno\nfds:结构体数组首地址\nnfds:数组元素个数\ntimeout：3种情况\n\n- -1 永远等待\n\n- 0     立即返回\n- 大于0  等待指定数目的毫秒数\n\nstruct pollfd {\n​　　　int fd;  //文件描述符\n​　　　short events; //监控的事件\n​　　　short revents; //监控事件中满足条件返回的事件\n};\n\n![](/pic/poll事件表.png)\n\n如果不再监控某个文件描述符时，可以把pollfd中的fd设置为-1，poll不再监控此fd,该pollfd中的revents返回0\n\n每次poll调用都会自动把上次的revents清空\n\n## 优缺点分析\n\n优点:\n1.突破了select并发量的限制，但是需要设置进程最大打开的文件描述符个数\n2.做到了传入传出分离，更易于操作\n\n缺点：\n1.采用轮询，随着fd的线性增长，效率呈线性下降\n2.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。\n3.每次调用poll传入时都需要从用户空间拷贝到内核空间，poll返回时传出结果从内核拷贝用用户，有着很大的拷贝开销，并且很多时候是重复的工作。\n\n4.只支持毫秒级别的精度\n\n## 注意点:\n\n1.在我的虚拟机上Ubuntu16.04一个进程默认的最大打开文件描述符是1024，为了实现poll的高并发需要自己修改这个值。[修改文件描述符个数方法](https://blog.csdn.net/hellozpc/article/details/47952867)\n\n2.在判断对应的事件是否发生的时候用位与操作。\n\n- 为什么不用相等？加入我注册的事件是POLLIN(这是POLLRDNORM|POLLRDBAND)，这时候POLLRDNORM触发了，如果是相等就不对了。\n\n3.应用程序需要根据recv调用的返回值来区分socket上接收到的是有效数据还是对方关闭连接的请求，并做相应的处理。自Linux内核2.6.17开始，GNU为poll增加了一个POLLRDHUP事件，它在socket上接收到对方关闭连接的请求之后触发，这为区分上述的两种情况提供了一种就简便方法。但在使用POLLRDHUP事件的时候，需要在代码最开始定义_GNU_SOURCE。\n\n4.poll在事件触发之后，要对revent进行清空操作。\n\npoll聊天室练习\n\n[客户端](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/chat_client.cpp)\n\n[服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/chat_server.cpp)\n\n## 服务器代码(客户端代码同多进程模型)\n\n```\n#include<stdio.h>\n#include<sys/time.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<arpa/inet.h>\n#include<ctype.h>\n#include<pthread.h>\n#include<sys/select.h>\n#include<poll.h>\n\n\n#define IPSIZE 16\n#define BUFSIZE 1500\n#define POLLFD_SIZE 1500\n#define PORT 1234\n#define LISTEN_SIZE 128\n\nint main()\n{   \n\n\n\tstruct sockaddr_in addr, clientaddr;\n\n\tint ListenSock;\n\tchar ip[IPSIZE];\n\n\tbzero(&addr,sizeof(addr));\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(PORT);\n\n\tListenSock = socket(AF_INET,SOCK_STREAM,0);\n\n\tif(ListenSock == -1){\n\t\tperror(\"SCOKET CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tif(bind(ListenSock,(struct sockaddr *)&addr,sizeof(addr)) == -1){\n\t   perror(\"BIND CALL FAILED\");\n\t   exit(-1);\n\t}\n\n\tif(listen(ListenSock,LISTEN_SIZE) == -1){\n       perror(\"LISTEN CALL FAILED\");\n\t   exit(-1);\n\t}\n\n\tprintf(\"Poll Server is Running\\n\");\n\n\tchar buf[BUFSIZE];\n\tint ready,nlen;\n\tstruct pollfd PollArr[POLLFD_SIZE];\n\n\t//memset(ClientSockArr,-1,sizeof(ClientSockArr));\n\n\tfor(int i = 0;i<POLLFD_SIZE;i++)\n\t\tPollArr[i].fd = -1;\t\n\t\n\tPollArr[0].fd = ListenSock;\n\tPollArr[0].events = POLLIN;\n\n\twhile(1){\n\t\tready = poll(PollArr,POLLFD_SIZE,-1);\n\t\tif(ready == -1){\n\t\t\tperror(\"POLL Filed\");\n\t\t\texit(-1);\n\t\t}\n\t\twhile(ready){\n\t\t\tif(PollArr[0].revents & POLLIN){//ListenSock就绪\n\t\t\t\tint addrsize = sizeof(clientaddr);\n\t\t\t\tint ClientSock;\n\t\t\t\tClientSock = accept(ListenSock,(struct sockaddr* )&clientaddr,&addrsize);\n\t\t\t\tif(ClientSock == -1)\n\t\t\t\t\tperror(\"ACCEPT ERROR\");\n\t\t\t\tif(ClientSock>0){\n\t\t\t\t\tinet_ntop(AF_INET,&clientaddr.sin_addr.s_addr,ip,sizeof(ip));\n\t\t\t\t\tprintf(\"IP:%s  Port:%d ClientSock:%d\\n\",ip,clientaddr.sin_port,ClientSock);\n\n\t\t\t\t\t//加入到数组当中\n\t\t\t\t\tfor(int i = 1;i<POLLFD_SIZE;i++){\n\t\t\t\t\t\tif(PollArr[i].fd == -1){\n\t\t\t\t\t\t\tPollArr[i].fd = ClientSock;\n\t\t\t\t\t\t\tPollArr[i].events = POLLIN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//遍历客户端数组找出哪个有事件发生\n\t\t\t\tfor(int i = 1;i<POLLFD_SIZE;i++){\n\t\t\t\t\tif(PollArr[i].fd != -1){\n\t\t\t\t\t\tif(PollArr[i].revents & POLLIN ){ //判断是否就绪\n\n\t\t\t\t\t\t\tnlen = read(PollArr[i].fd,buf,sizeof(buf));\n\t\t\t\t\t\t\tif(nlen == 0) {//客户端关闭\n\t\t\t\t\t\t\t\tclose(PollArr[i].fd);\n\t\t\t\t\t\t\t\tprintf(\"ClientSock:%d断开连接\\n\",PollArr[i].fd);\n\t\t\t\t\t\t\t\tPollArr[i].fd = -1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j = 0;j<nlen;j++){\n\t\t\t\t\t\t\t\tbuf[j] = toupper(buf[j]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twrite(PollArr[i].fd,buf,nlen);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tready--;\n\t\t}\n\n\t}\n\n\tclose(ListenSock);\n\treturn 0;\n}\t\n```\n\n","source":"_posts/poll.md","raw":"---\ntitle: poll\ndate: 2018-11-30 21:51:59\ntags: \n- IO复用\n- Linux\n- 网络\n- Linux高性能服务器编程\n---\n\n## 模型特点\n\n1.和select类似，但是突破了并发量的限制。\n2.采用的依旧是轮询\n3.采用struct pollfd结构体记录fd的状态\n\n<!-- more -->\n\n## 具体使用\n\n**int poll(struct pollfd *fds, nfds_t nfds, int timeout);**\n\n成功返回就绪的文件描述符个数，失败返回-1并设置errno\nfds:结构体数组首地址\nnfds:数组元素个数\ntimeout：3种情况\n\n- -1 永远等待\n\n- 0     立即返回\n- 大于0  等待指定数目的毫秒数\n\nstruct pollfd {\n​　　　int fd;  //文件描述符\n​　　　short events; //监控的事件\n​　　　short revents; //监控事件中满足条件返回的事件\n};\n\n![](/pic/poll事件表.png)\n\n如果不再监控某个文件描述符时，可以把pollfd中的fd设置为-1，poll不再监控此fd,该pollfd中的revents返回0\n\n每次poll调用都会自动把上次的revents清空\n\n## 优缺点分析\n\n优点:\n1.突破了select并发量的限制，但是需要设置进程最大打开的文件描述符个数\n2.做到了传入传出分离，更易于操作\n\n缺点：\n1.采用轮询，随着fd的线性增长，效率呈线性下降\n2.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。\n3.每次调用poll传入时都需要从用户空间拷贝到内核空间，poll返回时传出结果从内核拷贝用用户，有着很大的拷贝开销，并且很多时候是重复的工作。\n\n4.只支持毫秒级别的精度\n\n## 注意点:\n\n1.在我的虚拟机上Ubuntu16.04一个进程默认的最大打开文件描述符是1024，为了实现poll的高并发需要自己修改这个值。[修改文件描述符个数方法](https://blog.csdn.net/hellozpc/article/details/47952867)\n\n2.在判断对应的事件是否发生的时候用位与操作。\n\n- 为什么不用相等？加入我注册的事件是POLLIN(这是POLLRDNORM|POLLRDBAND)，这时候POLLRDNORM触发了，如果是相等就不对了。\n\n3.应用程序需要根据recv调用的返回值来区分socket上接收到的是有效数据还是对方关闭连接的请求，并做相应的处理。自Linux内核2.6.17开始，GNU为poll增加了一个POLLRDHUP事件，它在socket上接收到对方关闭连接的请求之后触发，这为区分上述的两种情况提供了一种就简便方法。但在使用POLLRDHUP事件的时候，需要在代码最开始定义_GNU_SOURCE。\n\n4.poll在事件触发之后，要对revent进行清空操作。\n\npoll聊天室练习\n\n[客户端](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/chat_client.cpp)\n\n[服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/chat_server.cpp)\n\n## 服务器代码(客户端代码同多进程模型)\n\n```\n#include<stdio.h>\n#include<sys/time.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<arpa/inet.h>\n#include<ctype.h>\n#include<pthread.h>\n#include<sys/select.h>\n#include<poll.h>\n\n\n#define IPSIZE 16\n#define BUFSIZE 1500\n#define POLLFD_SIZE 1500\n#define PORT 1234\n#define LISTEN_SIZE 128\n\nint main()\n{   \n\n\n\tstruct sockaddr_in addr, clientaddr;\n\n\tint ListenSock;\n\tchar ip[IPSIZE];\n\n\tbzero(&addr,sizeof(addr));\n\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(PORT);\n\n\tListenSock = socket(AF_INET,SOCK_STREAM,0);\n\n\tif(ListenSock == -1){\n\t\tperror(\"SCOKET CALL FAILED\");\n\t\texit(-1);\n\t}\n\n\tif(bind(ListenSock,(struct sockaddr *)&addr,sizeof(addr)) == -1){\n\t   perror(\"BIND CALL FAILED\");\n\t   exit(-1);\n\t}\n\n\tif(listen(ListenSock,LISTEN_SIZE) == -1){\n       perror(\"LISTEN CALL FAILED\");\n\t   exit(-1);\n\t}\n\n\tprintf(\"Poll Server is Running\\n\");\n\n\tchar buf[BUFSIZE];\n\tint ready,nlen;\n\tstruct pollfd PollArr[POLLFD_SIZE];\n\n\t//memset(ClientSockArr,-1,sizeof(ClientSockArr));\n\n\tfor(int i = 0;i<POLLFD_SIZE;i++)\n\t\tPollArr[i].fd = -1;\t\n\t\n\tPollArr[0].fd = ListenSock;\n\tPollArr[0].events = POLLIN;\n\n\twhile(1){\n\t\tready = poll(PollArr,POLLFD_SIZE,-1);\n\t\tif(ready == -1){\n\t\t\tperror(\"POLL Filed\");\n\t\t\texit(-1);\n\t\t}\n\t\twhile(ready){\n\t\t\tif(PollArr[0].revents & POLLIN){//ListenSock就绪\n\t\t\t\tint addrsize = sizeof(clientaddr);\n\t\t\t\tint ClientSock;\n\t\t\t\tClientSock = accept(ListenSock,(struct sockaddr* )&clientaddr,&addrsize);\n\t\t\t\tif(ClientSock == -1)\n\t\t\t\t\tperror(\"ACCEPT ERROR\");\n\t\t\t\tif(ClientSock>0){\n\t\t\t\t\tinet_ntop(AF_INET,&clientaddr.sin_addr.s_addr,ip,sizeof(ip));\n\t\t\t\t\tprintf(\"IP:%s  Port:%d ClientSock:%d\\n\",ip,clientaddr.sin_port,ClientSock);\n\n\t\t\t\t\t//加入到数组当中\n\t\t\t\t\tfor(int i = 1;i<POLLFD_SIZE;i++){\n\t\t\t\t\t\tif(PollArr[i].fd == -1){\n\t\t\t\t\t\t\tPollArr[i].fd = ClientSock;\n\t\t\t\t\t\t\tPollArr[i].events = POLLIN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//遍历客户端数组找出哪个有事件发生\n\t\t\t\tfor(int i = 1;i<POLLFD_SIZE;i++){\n\t\t\t\t\tif(PollArr[i].fd != -1){\n\t\t\t\t\t\tif(PollArr[i].revents & POLLIN ){ //判断是否就绪\n\n\t\t\t\t\t\t\tnlen = read(PollArr[i].fd,buf,sizeof(buf));\n\t\t\t\t\t\t\tif(nlen == 0) {//客户端关闭\n\t\t\t\t\t\t\t\tclose(PollArr[i].fd);\n\t\t\t\t\t\t\t\tprintf(\"ClientSock:%d断开连接\\n\",PollArr[i].fd);\n\t\t\t\t\t\t\t\tPollArr[i].fd = -1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor(int j = 0;j<nlen;j++){\n\t\t\t\t\t\t\t\tbuf[j] = toupper(buf[j]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twrite(PollArr[i].fd,buf,nlen);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tready--;\n\t\t}\n\n\t}\n\n\tclose(ListenSock);\n\treturn 0;\n}\t\n```\n\n","slug":"poll","published":1,"updated":"2021-12-06T05:30:36.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7m001796ca82ks0129","content":"<h2 id=\"模型特点\"><a href=\"#模型特点\" class=\"headerlink\" title=\"模型特点\"></a>模型特点</h2><p>1.和select类似，但是突破了并发量的限制。<br>2.采用的依旧是轮询<br>3.采用struct pollfd结构体记录fd的状态</p>\n<a id=\"more\"></a>\n\n<h2 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h2><p><strong>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</strong></p>\n<p>成功返回就绪的文件描述符个数，失败返回-1并设置errno<br>fds:结构体数组首地址<br>nfds:数组元素个数<br>timeout：3种情况</p>\n<ul>\n<li><p>-1 永远等待</p>\n</li>\n<li><p>0     立即返回</p>\n</li>\n<li><p>大于0  等待指定数目的毫秒数</p>\n</li>\n</ul>\n<p>struct pollfd {<br>​　　　int fd;  //文件描述符<br>​　　　short events; //监控的事件<br>​　　　short revents; //监控事件中满足条件返回的事件<br>};</p>\n<p><img src=\"/pic/poll%E4%BA%8B%E4%BB%B6%E8%A1%A8.png\" alt=\"\"></p>\n<p>如果不再监控某个文件描述符时，可以把pollfd中的fd设置为-1，poll不再监控此fd,该pollfd中的revents返回0</p>\n<p>每次poll调用都会自动把上次的revents清空</p>\n<h2 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h2><p>优点:<br>1.突破了select并发量的限制，但是需要设置进程最大打开的文件描述符个数<br>2.做到了传入传出分离，更易于操作</p>\n<p>缺点：<br>1.采用轮询，随着fd的线性增长，效率呈线性下降<br>2.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。<br>3.每次调用poll传入时都需要从用户空间拷贝到内核空间，poll返回时传出结果从内核拷贝用用户，有着很大的拷贝开销，并且很多时候是重复的工作。</p>\n<p>4.只支持毫秒级别的精度</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点:\"></a>注意点:</h2><p>1.在我的虚拟机上Ubuntu16.04一个进程默认的最大打开文件描述符是1024，为了实现poll的高并发需要自己修改这个值。<a href=\"https://blog.csdn.net/hellozpc/article/details/47952867\" target=\"_blank\" rel=\"noopener\">修改文件描述符个数方法</a></p>\n<p>2.在判断对应的事件是否发生的时候用位与操作。</p>\n<ul>\n<li>为什么不用相等？加入我注册的事件是POLLIN(这是POLLRDNORM|POLLRDBAND)，这时候POLLRDNORM触发了，如果是相等就不对了。</li>\n</ul>\n<p>3.应用程序需要根据recv调用的返回值来区分socket上接收到的是有效数据还是对方关闭连接的请求，并做相应的处理。自Linux内核2.6.17开始，GNU为poll增加了一个POLLRDHUP事件，它在socket上接收到对方关闭连接的请求之后触发，这为区分上述的两种情况提供了一种就简便方法。但在使用POLLRDHUP事件的时候，需要在代码最开始定义_GNU_SOURCE。</p>\n<p>4.poll在事件触发之后，要对revent进行清空操作。</p>\n<p>poll聊天室练习</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/chat_client.cpp\" target=\"_blank\" rel=\"noopener\">客户端</a></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/chat_server.cpp\" target=\"_blank\" rel=\"noopener\">服务器</a></p>\n<h2 id=\"服务器代码-客户端代码同多进程模型\"><a href=\"#服务器代码-客户端代码同多进程模型\" class=\"headerlink\" title=\"服务器代码(客户端代码同多进程模型)\"></a>服务器代码(客户端代码同多进程模型)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;stdio.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;time.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;types.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;unistd.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class=\"line\">#include&lt;ctype.h&gt;</span><br><span class=\"line\">#include&lt;pthread.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;select.h&gt;</span><br><span class=\"line\">#include&lt;poll.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#define IPSIZE 16</span><br><span class=\"line\">#define BUFSIZE 1500</span><br><span class=\"line\">#define POLLFD_SIZE 1500</span><br><span class=\"line\">#define PORT 1234</span><br><span class=\"line\">#define LISTEN_SIZE 128</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct sockaddr_in addr, clientaddr;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint ListenSock;</span><br><span class=\"line\">\tchar ip[IPSIZE];</span><br><span class=\"line\"></span><br><span class=\"line\">\tbzero(&amp;addr,sizeof(addr));</span><br><span class=\"line\"></span><br><span class=\"line\">\taddr.sin_family &#x3D; AF_INET;</span><br><span class=\"line\">\taddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</span><br><span class=\"line\">\taddr.sin_port &#x3D; htons(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">\tListenSock &#x3D; socket(AF_INET,SOCK_STREAM,0);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(ListenSock &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\tperror(&quot;SCOKET CALL FAILED&quot;);</span><br><span class=\"line\">\t\texit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(bind(ListenSock,(struct sockaddr *)&amp;addr,sizeof(addr)) &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t   perror(&quot;BIND CALL FAILED&quot;);</span><br><span class=\"line\">\t   exit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(listen(ListenSock,LISTEN_SIZE) &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">       perror(&quot;LISTEN CALL FAILED&quot;);</span><br><span class=\"line\">\t   exit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(&quot;Poll Server is Running\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tchar buf[BUFSIZE];</span><br><span class=\"line\">\tint ready,nlen;</span><br><span class=\"line\">\tstruct pollfd PollArr[POLLFD_SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;memset(ClientSockArr,-1,sizeof(ClientSockArr));</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor(int i &#x3D; 0;i&lt;POLLFD_SIZE;i++)</span><br><span class=\"line\">\t\tPollArr[i].fd &#x3D; -1;\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPollArr[0].fd &#x3D; ListenSock;</span><br><span class=\"line\">\tPollArr[0].events &#x3D; POLLIN;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tready &#x3D; poll(PollArr,POLLFD_SIZE,-1);</span><br><span class=\"line\">\t\tif(ready &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\tperror(&quot;POLL Filed&quot;);</span><br><span class=\"line\">\t\t\texit(-1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile(ready)&#123;</span><br><span class=\"line\">\t\t\tif(PollArr[0].revents &amp; POLLIN)&#123;&#x2F;&#x2F;ListenSock就绪</span><br><span class=\"line\">\t\t\t\tint addrsize &#x3D; sizeof(clientaddr);</span><br><span class=\"line\">\t\t\t\tint ClientSock;</span><br><span class=\"line\">\t\t\t\tClientSock &#x3D; accept(ListenSock,(struct sockaddr* )&amp;clientaddr,&amp;addrsize);</span><br><span class=\"line\">\t\t\t\tif(ClientSock &#x3D;&#x3D; -1)</span><br><span class=\"line\">\t\t\t\t\tperror(&quot;ACCEPT ERROR&quot;);</span><br><span class=\"line\">\t\t\t\tif(ClientSock&gt;0)&#123;</span><br><span class=\"line\">\t\t\t\t\tinet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,ip,sizeof(ip));</span><br><span class=\"line\">\t\t\t\t\tprintf(&quot;IP:%s  Port:%d ClientSock:%d\\n&quot;,ip,clientaddr.sin_port,ClientSock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F;加入到数组当中</span><br><span class=\"line\">\t\t\t\t\tfor(int i &#x3D; 1;i&lt;POLLFD_SIZE;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tif(PollArr[i].fd &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tPollArr[i].fd &#x3D; ClientSock;</span><br><span class=\"line\">\t\t\t\t\t\t\tPollArr[i].events &#x3D; POLLIN;</span><br><span class=\"line\">\t\t\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse&#123;</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;遍历客户端数组找出哪个有事件发生</span><br><span class=\"line\">\t\t\t\tfor(int i &#x3D; 1;i&lt;POLLFD_SIZE;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\tif(PollArr[i].fd !&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tif(PollArr[i].revents &amp; POLLIN )&#123; &#x2F;&#x2F;判断是否就绪</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\tnlen &#x3D; read(PollArr[i].fd,buf,sizeof(buf));</span><br><span class=\"line\">\t\t\t\t\t\t\tif(nlen &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;客户端关闭</span><br><span class=\"line\">\t\t\t\t\t\t\t\tclose(PollArr[i].fd);</span><br><span class=\"line\">\t\t\t\t\t\t\t\tprintf(&quot;ClientSock:%d断开连接\\n&quot;,PollArr[i].fd);</span><br><span class=\"line\">\t\t\t\t\t\t\t\tPollArr[i].fd &#x3D; -1;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\tfor(int j &#x3D; 0;j&lt;nlen;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tbuf[j] &#x3D; toupper(buf[j]);</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\twrite(PollArr[i].fd,buf,nlen);</span><br><span class=\"line\">\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tready--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclose(ListenSock);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"模型特点\"><a href=\"#模型特点\" class=\"headerlink\" title=\"模型特点\"></a>模型特点</h2><p>1.和select类似，但是突破了并发量的限制。<br>2.采用的依旧是轮询<br>3.采用struct pollfd结构体记录fd的状态</p>","more":"<h2 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h2><p><strong>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</strong></p>\n<p>成功返回就绪的文件描述符个数，失败返回-1并设置errno<br>fds:结构体数组首地址<br>nfds:数组元素个数<br>timeout：3种情况</p>\n<ul>\n<li><p>-1 永远等待</p>\n</li>\n<li><p>0     立即返回</p>\n</li>\n<li><p>大于0  等待指定数目的毫秒数</p>\n</li>\n</ul>\n<p>struct pollfd {<br>​　　　int fd;  //文件描述符<br>​　　　short events; //监控的事件<br>​　　　short revents; //监控事件中满足条件返回的事件<br>};</p>\n<p><img src=\"/pic/poll%E4%BA%8B%E4%BB%B6%E8%A1%A8.png\" alt=\"\"></p>\n<p>如果不再监控某个文件描述符时，可以把pollfd中的fd设置为-1，poll不再监控此fd,该pollfd中的revents返回0</p>\n<p>每次poll调用都会自动把上次的revents清空</p>\n<h2 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h2><p>优点:<br>1.突破了select并发量的限制，但是需要设置进程最大打开的文件描述符个数<br>2.做到了传入传出分离，更易于操作</p>\n<p>缺点：<br>1.采用轮询，随着fd的线性增长，效率呈线性下降<br>2.实现的是伪并发，对于客户端的请求只能一个一个处理，并且如果处理流程过长，影响用户体验。<br>3.每次调用poll传入时都需要从用户空间拷贝到内核空间，poll返回时传出结果从内核拷贝用用户，有着很大的拷贝开销，并且很多时候是重复的工作。</p>\n<p>4.只支持毫秒级别的精度</p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点:\"></a>注意点:</h2><p>1.在我的虚拟机上Ubuntu16.04一个进程默认的最大打开文件描述符是1024，为了实现poll的高并发需要自己修改这个值。<a href=\"https://blog.csdn.net/hellozpc/article/details/47952867\" target=\"_blank\" rel=\"noopener\">修改文件描述符个数方法</a></p>\n<p>2.在判断对应的事件是否发生的时候用位与操作。</p>\n<ul>\n<li>为什么不用相等？加入我注册的事件是POLLIN(这是POLLRDNORM|POLLRDBAND)，这时候POLLRDNORM触发了，如果是相等就不对了。</li>\n</ul>\n<p>3.应用程序需要根据recv调用的返回值来区分socket上接收到的是有效数据还是对方关闭连接的请求，并做相应的处理。自Linux内核2.6.17开始，GNU为poll增加了一个POLLRDHUP事件，它在socket上接收到对方关闭连接的请求之后触发，这为区分上述的两种情况提供了一种就简便方法。但在使用POLLRDHUP事件的时候，需要在代码最开始定义_GNU_SOURCE。</p>\n<p>4.poll在事件触发之后，要对revent进行清空操作。</p>\n<p>poll聊天室练习</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/chat_client.cpp\" target=\"_blank\" rel=\"noopener\">客户端</a></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/9_chapter/chat_server.cpp\" target=\"_blank\" rel=\"noopener\">服务器</a></p>\n<h2 id=\"服务器代码-客户端代码同多进程模型\"><a href=\"#服务器代码-客户端代码同多进程模型\" class=\"headerlink\" title=\"服务器代码(客户端代码同多进程模型)\"></a>服务器代码(客户端代码同多进程模型)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;stdio.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;time.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;types.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;socket.h&gt;</span><br><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">#include&lt;unistd.h&gt;</span><br><span class=\"line\">#include&lt;stdlib.h&gt;</span><br><span class=\"line\">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class=\"line\">#include&lt;ctype.h&gt;</span><br><span class=\"line\">#include&lt;pthread.h&gt;</span><br><span class=\"line\">#include&lt;sys&#x2F;select.h&gt;</span><br><span class=\"line\">#include&lt;poll.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#define IPSIZE 16</span><br><span class=\"line\">#define BUFSIZE 1500</span><br><span class=\"line\">#define POLLFD_SIZE 1500</span><br><span class=\"line\">#define PORT 1234</span><br><span class=\"line\">#define LISTEN_SIZE 128</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct sockaddr_in addr, clientaddr;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint ListenSock;</span><br><span class=\"line\">\tchar ip[IPSIZE];</span><br><span class=\"line\"></span><br><span class=\"line\">\tbzero(&amp;addr,sizeof(addr));</span><br><span class=\"line\"></span><br><span class=\"line\">\taddr.sin_family &#x3D; AF_INET;</span><br><span class=\"line\">\taddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);</span><br><span class=\"line\">\taddr.sin_port &#x3D; htons(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">\tListenSock &#x3D; socket(AF_INET,SOCK_STREAM,0);</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(ListenSock &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\tperror(&quot;SCOKET CALL FAILED&quot;);</span><br><span class=\"line\">\t\texit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(bind(ListenSock,(struct sockaddr *)&amp;addr,sizeof(addr)) &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t   perror(&quot;BIND CALL FAILED&quot;);</span><br><span class=\"line\">\t   exit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif(listen(ListenSock,LISTEN_SIZE) &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">       perror(&quot;LISTEN CALL FAILED&quot;);</span><br><span class=\"line\">\t   exit(-1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(&quot;Poll Server is Running\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tchar buf[BUFSIZE];</span><br><span class=\"line\">\tint ready,nlen;</span><br><span class=\"line\">\tstruct pollfd PollArr[POLLFD_SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;memset(ClientSockArr,-1,sizeof(ClientSockArr));</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor(int i &#x3D; 0;i&lt;POLLFD_SIZE;i++)</span><br><span class=\"line\">\t\tPollArr[i].fd &#x3D; -1;\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPollArr[0].fd &#x3D; ListenSock;</span><br><span class=\"line\">\tPollArr[0].events &#x3D; POLLIN;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tready &#x3D; poll(PollArr,POLLFD_SIZE,-1);</span><br><span class=\"line\">\t\tif(ready &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\tperror(&quot;POLL Filed&quot;);</span><br><span class=\"line\">\t\t\texit(-1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile(ready)&#123;</span><br><span class=\"line\">\t\t\tif(PollArr[0].revents &amp; POLLIN)&#123;&#x2F;&#x2F;ListenSock就绪</span><br><span class=\"line\">\t\t\t\tint addrsize &#x3D; sizeof(clientaddr);</span><br><span class=\"line\">\t\t\t\tint ClientSock;</span><br><span class=\"line\">\t\t\t\tClientSock &#x3D; accept(ListenSock,(struct sockaddr* )&amp;clientaddr,&amp;addrsize);</span><br><span class=\"line\">\t\t\t\tif(ClientSock &#x3D;&#x3D; -1)</span><br><span class=\"line\">\t\t\t\t\tperror(&quot;ACCEPT ERROR&quot;);</span><br><span class=\"line\">\t\t\t\tif(ClientSock&gt;0)&#123;</span><br><span class=\"line\">\t\t\t\t\tinet_ntop(AF_INET,&amp;clientaddr.sin_addr.s_addr,ip,sizeof(ip));</span><br><span class=\"line\">\t\t\t\t\tprintf(&quot;IP:%s  Port:%d ClientSock:%d\\n&quot;,ip,clientaddr.sin_port,ClientSock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t&#x2F;&#x2F;加入到数组当中</span><br><span class=\"line\">\t\t\t\t\tfor(int i &#x3D; 1;i&lt;POLLFD_SIZE;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tif(PollArr[i].fd &#x3D;&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tPollArr[i].fd &#x3D; ClientSock;</span><br><span class=\"line\">\t\t\t\t\t\t\tPollArr[i].events &#x3D; POLLIN;</span><br><span class=\"line\">\t\t\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse&#123;</span><br><span class=\"line\">\t\t\t\t&#x2F;&#x2F;遍历客户端数组找出哪个有事件发生</span><br><span class=\"line\">\t\t\t\tfor(int i &#x3D; 1;i&lt;POLLFD_SIZE;i++)&#123;</span><br><span class=\"line\">\t\t\t\t\tif(PollArr[i].fd !&#x3D; -1)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tif(PollArr[i].revents &amp; POLLIN )&#123; &#x2F;&#x2F;判断是否就绪</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\tnlen &#x3D; read(PollArr[i].fd,buf,sizeof(buf));</span><br><span class=\"line\">\t\t\t\t\t\t\tif(nlen &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;客户端关闭</span><br><span class=\"line\">\t\t\t\t\t\t\t\tclose(PollArr[i].fd);</span><br><span class=\"line\">\t\t\t\t\t\t\t\tprintf(&quot;ClientSock:%d断开连接\\n&quot;,PollArr[i].fd);</span><br><span class=\"line\">\t\t\t\t\t\t\t\tPollArr[i].fd &#x3D; -1;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\tfor(int j &#x3D; 0;j&lt;nlen;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tbuf[j] &#x3D; toupper(buf[j]);</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t\twrite(PollArr[i].fd,buf,nlen);</span><br><span class=\"line\">\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tready--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tclose(ListenSock);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"socket选项","date":"2019-03-13T09:15:03.000Z","_content":"\nsocket文件描述符本质上也是文件，可以用fcntl系统调用来控制文件描述符属性(通用POSIX方法)\n\n专门操作socket文件描述符属性的函数：\n\nint getsockopt(int sockfd,int level,int option_name,void* option_value,socklen_t* restrict option_len);\n\nint setsockopt(int sockfd,int level,int option_name,const void* option_value,socklen_t option_len);\n\nlevel:操作那个协议  IPv4/IPv6/TCP...\n\n<!--more-->\n\n常用的选项：\n\n![](/pic/socket选项.png)\n\n需要注意的是：对服务器而言，有部分socket选项只能来listen调用前针对监听socket设置才有效。比如TCP_MAXSEG选项，代表TCP最大报文段大小，该选项只能由同步报文段来发送。accept从listen监听队列中接收的连接至少是TCP_RECV状态，也就是服务器已经给接收连接端发送了同步报文段，如果TCP_MAXSEG选项在这之后设置，就不起作用了。对客户端而言，这些选项要在connect之前设置。\n\n解决方案：对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。\n\n这些选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPLIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNFBUF、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY。\n\n## SO_REUSEADDR选项\n\n服务器可以通过设置socket选项SO_REUSERADDR来强制使用处于TIME_WAIT状态的连接占用的socket地址。\n\n```\nint sockfd = socket(AF_INET,SOCK_STREAM,0);\nassert(sockfd >= 0);\nint reuse = 1;\nsetsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&reuse,sizeof(reuse));\n```\n\n此外，也可以通过改变内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket\n\n0表示禁用，1表示开启\n\n## SO_RCVBUF和SO_SNDBUF\n\n分别表示TCP接受缓冲区和发送缓冲区的大小。\n\n用setsockopt选项设置TCP的接收缓冲区和发送缓冲区的大小时，系统会将其值加倍，并且不得小于某个最小值。\n\n下面编写修改发送缓冲区和接收缓冲区的程序。[客户端](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_10.cpp) [服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_11.cpp)\n\n服务器输出：\n\n![](/pic/SO_RCVBUF.png)\n\n改变输入参数：\n\n![](/pic/SO_RCVBUF.png)\n\n客户端输出：\n\n![](/pic/SNDBUF.png)\n\n改变输入参数：\n\n![](/pic/SNDBUF1.png)\n\n从服务器的输出可见，系统会将设置的接收缓冲区的值翻倍，但是如果翻倍的值不足系统默认的最小值，我的机器(Ubuntu16.04)默认2240字节，系统就设置成2240字节。\n\n从客户端的输出可见，系统会将设置的发送缓冲区的值翻倍，但是如果翻倍的值不足系统默认的最小值，系统就设置成4480字节。\n\n## SO_LINGER选项\n\n用来控制close系统调用在关闭TCP连接时的行为。\n\n设置SO_LINGER选项的值时，需要给setsockopt(getsockopt)系统调用传递一个linger类型的结构体\n\n```\nstruct linger{\n\tint l_onoff;    //开启(非0)还是关闭(0)该选项\n    int l_linger;   //滞留时间\n};\n```\n\n根据linger结构体两个成员变量的不同值，close系统调用可能产生如下3种行为：\n\n- l_onoff = 0。SO_LINGER不起作用。close采用默认行为关闭socket。\n\n​        默认行为：立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方\n\n- l_onoff !=0,l_linger = 0。close立即返回，TCP模块将丢弃被关闭的socket对杨的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供了异常终止一个连接的方法。\n\n- l_onoff != 0,l_linger > 0。此时close的行为取决于1.被关闭的socket对应的TCP发送缓冲区中是否有残留的数据。2.该socket是阻塞的，还是非阻塞的。\n\n  对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，close返回-1并设置errno为EWOULDBLOCK。\n\n  对于非阻塞的socket，close将立即返回，此时需要根据其返回值和errno来判断残留数据是否已经发送完毕。","source":"_posts/socket选项.md","raw":"---\ntitle: socket选项\ndate: 2019-03-13 17:15:03\ntags:\n- 网络\n- Linux高性能服务器编程\n---\n\nsocket文件描述符本质上也是文件，可以用fcntl系统调用来控制文件描述符属性(通用POSIX方法)\n\n专门操作socket文件描述符属性的函数：\n\nint getsockopt(int sockfd,int level,int option_name,void* option_value,socklen_t* restrict option_len);\n\nint setsockopt(int sockfd,int level,int option_name,const void* option_value,socklen_t option_len);\n\nlevel:操作那个协议  IPv4/IPv6/TCP...\n\n<!--more-->\n\n常用的选项：\n\n![](/pic/socket选项.png)\n\n需要注意的是：对服务器而言，有部分socket选项只能来listen调用前针对监听socket设置才有效。比如TCP_MAXSEG选项，代表TCP最大报文段大小，该选项只能由同步报文段来发送。accept从listen监听队列中接收的连接至少是TCP_RECV状态，也就是服务器已经给接收连接端发送了同步报文段，如果TCP_MAXSEG选项在这之后设置，就不起作用了。对客户端而言，这些选项要在connect之前设置。\n\n解决方案：对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。\n\n这些选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPLIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNFBUF、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY。\n\n## SO_REUSEADDR选项\n\n服务器可以通过设置socket选项SO_REUSERADDR来强制使用处于TIME_WAIT状态的连接占用的socket地址。\n\n```\nint sockfd = socket(AF_INET,SOCK_STREAM,0);\nassert(sockfd >= 0);\nint reuse = 1;\nsetsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&reuse,sizeof(reuse));\n```\n\n此外，也可以通过改变内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket\n\n0表示禁用，1表示开启\n\n## SO_RCVBUF和SO_SNDBUF\n\n分别表示TCP接受缓冲区和发送缓冲区的大小。\n\n用setsockopt选项设置TCP的接收缓冲区和发送缓冲区的大小时，系统会将其值加倍，并且不得小于某个最小值。\n\n下面编写修改发送缓冲区和接收缓冲区的程序。[客户端](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_10.cpp) [服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_11.cpp)\n\n服务器输出：\n\n![](/pic/SO_RCVBUF.png)\n\n改变输入参数：\n\n![](/pic/SO_RCVBUF.png)\n\n客户端输出：\n\n![](/pic/SNDBUF.png)\n\n改变输入参数：\n\n![](/pic/SNDBUF1.png)\n\n从服务器的输出可见，系统会将设置的接收缓冲区的值翻倍，但是如果翻倍的值不足系统默认的最小值，我的机器(Ubuntu16.04)默认2240字节，系统就设置成2240字节。\n\n从客户端的输出可见，系统会将设置的发送缓冲区的值翻倍，但是如果翻倍的值不足系统默认的最小值，系统就设置成4480字节。\n\n## SO_LINGER选项\n\n用来控制close系统调用在关闭TCP连接时的行为。\n\n设置SO_LINGER选项的值时，需要给setsockopt(getsockopt)系统调用传递一个linger类型的结构体\n\n```\nstruct linger{\n\tint l_onoff;    //开启(非0)还是关闭(0)该选项\n    int l_linger;   //滞留时间\n};\n```\n\n根据linger结构体两个成员变量的不同值，close系统调用可能产生如下3种行为：\n\n- l_onoff = 0。SO_LINGER不起作用。close采用默认行为关闭socket。\n\n​        默认行为：立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方\n\n- l_onoff !=0,l_linger = 0。close立即返回，TCP模块将丢弃被关闭的socket对杨的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供了异常终止一个连接的方法。\n\n- l_onoff != 0,l_linger > 0。此时close的行为取决于1.被关闭的socket对应的TCP发送缓冲区中是否有残留的数据。2.该socket是阻塞的，还是非阻塞的。\n\n  对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，close返回-1并设置errno为EWOULDBLOCK。\n\n  对于非阻塞的socket，close将立即返回，此时需要根据其返回值和errno来判断残留数据是否已经发送完毕。","slug":"socket选项","published":1,"updated":"2021-12-06T05:30:36.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7n001996caf2t33nr8","content":"<p>socket文件描述符本质上也是文件，可以用fcntl系统调用来控制文件描述符属性(通用POSIX方法)</p>\n<p>专门操作socket文件描述符属性的函数：</p>\n<p>int getsockopt(int sockfd,int level,int option_name,void* option_value,socklen_t* restrict option_len);</p>\n<p>int setsockopt(int sockfd,int level,int option_name,const void* option_value,socklen_t option_len);</p>\n<p>level:操作那个协议  IPv4/IPv6/TCP…</p>\n<a id=\"more\"></a>\n\n<p>常用的选项：</p>\n<p><img src=\"/pic/socket%E9%80%89%E9%A1%B9.png\" alt=\"\"></p>\n<p>需要注意的是：对服务器而言，有部分socket选项只能来listen调用前针对监听socket设置才有效。比如TCP_MAXSEG选项，代表TCP最大报文段大小，该选项只能由同步报文段来发送。accept从listen监听队列中接收的连接至少是TCP_RECV状态，也就是服务器已经给接收连接端发送了同步报文段，如果TCP_MAXSEG选项在这之后设置，就不起作用了。对客户端而言，这些选项要在connect之前设置。</p>\n<p>解决方案：对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。</p>\n<p>这些选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPLIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNFBUF、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY。</p>\n<h2 id=\"SO-REUSEADDR选项\"><a href=\"#SO-REUSEADDR选项\" class=\"headerlink\" title=\"SO_REUSEADDR选项\"></a>SO_REUSEADDR选项</h2><p>服务器可以通过设置socket选项SO_REUSERADDR来强制使用处于TIME_WAIT状态的连接占用的socket地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int sockfd &#x3D; socket(AF_INET,SOCK_STREAM,0);</span><br><span class=\"line\">assert(sockfd &gt;&#x3D; 0);</span><br><span class=\"line\">int reuse &#x3D; 1;</span><br><span class=\"line\">setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;reuse,sizeof(reuse));</span><br></pre></td></tr></table></figure>\n\n<p>此外，也可以通过改变内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket</p>\n<p>0表示禁用，1表示开启</p>\n<h2 id=\"SO-RCVBUF和SO-SNDBUF\"><a href=\"#SO-RCVBUF和SO-SNDBUF\" class=\"headerlink\" title=\"SO_RCVBUF和SO_SNDBUF\"></a>SO_RCVBUF和SO_SNDBUF</h2><p>分别表示TCP接受缓冲区和发送缓冲区的大小。</p>\n<p>用setsockopt选项设置TCP的接收缓冲区和发送缓冲区的大小时，系统会将其值加倍，并且不得小于某个最小值。</p>\n<p>下面编写修改发送缓冲区和接收缓冲区的程序。<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_10.cpp\" target=\"_blank\" rel=\"noopener\">客户端</a> <a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_11.cpp\" target=\"_blank\" rel=\"noopener\">服务器</a></p>\n<p>服务器输出：</p>\n<p><img src=\"/pic/SO_RCVBUF.png\" alt=\"\"></p>\n<p>改变输入参数：</p>\n<p><img src=\"/pic/SO_RCVBUF.png\" alt=\"\"></p>\n<p>客户端输出：</p>\n<p><img src=\"/pic/SNDBUF.png\" alt=\"\"></p>\n<p>改变输入参数：</p>\n<p><img src=\"/pic/SNDBUF1.png\" alt=\"\"></p>\n<p>从服务器的输出可见，系统会将设置的接收缓冲区的值翻倍，但是如果翻倍的值不足系统默认的最小值，我的机器(Ubuntu16.04)默认2240字节，系统就设置成2240字节。</p>\n<p>从客户端的输出可见，系统会将设置的发送缓冲区的值翻倍，但是如果翻倍的值不足系统默认的最小值，系统就设置成4480字节。</p>\n<h2 id=\"SO-LINGER选项\"><a href=\"#SO-LINGER选项\" class=\"headerlink\" title=\"SO_LINGER选项\"></a>SO_LINGER选项</h2><p>用来控制close系统调用在关闭TCP连接时的行为。</p>\n<p>设置SO_LINGER选项的值时，需要给setsockopt(getsockopt)系统调用传递一个linger类型的结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct linger&#123;</span><br><span class=\"line\">\tint l_onoff;    &#x2F;&#x2F;开启(非0)还是关闭(0)该选项</span><br><span class=\"line\">    int l_linger;   &#x2F;&#x2F;滞留时间</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>根据linger结构体两个成员变量的不同值，close系统调用可能产生如下3种行为：</p>\n<ul>\n<li>l_onoff = 0。SO_LINGER不起作用。close采用默认行为关闭socket。</li>\n</ul>\n<p>​        默认行为：立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方</p>\n<ul>\n<li><p>l_onoff !=0,l_linger = 0。close立即返回，TCP模块将丢弃被关闭的socket对杨的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供了异常终止一个连接的方法。</p>\n</li>\n<li><p>l_onoff != 0,l_linger &gt; 0。此时close的行为取决于1.被关闭的socket对应的TCP发送缓冲区中是否有残留的数据。2.该socket是阻塞的，还是非阻塞的。</p>\n<p>对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，close返回-1并设置errno为EWOULDBLOCK。</p>\n<p>对于非阻塞的socket，close将立即返回，此时需要根据其返回值和errno来判断残留数据是否已经发送完毕。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>socket文件描述符本质上也是文件，可以用fcntl系统调用来控制文件描述符属性(通用POSIX方法)</p>\n<p>专门操作socket文件描述符属性的函数：</p>\n<p>int getsockopt(int sockfd,int level,int option_name,void* option_value,socklen_t* restrict option_len);</p>\n<p>int setsockopt(int sockfd,int level,int option_name,const void* option_value,socklen_t option_len);</p>\n<p>level:操作那个协议  IPv4/IPv6/TCP…</p>","more":"<p>常用的选项：</p>\n<p><img src=\"/pic/socket%E9%80%89%E9%A1%B9.png\" alt=\"\"></p>\n<p>需要注意的是：对服务器而言，有部分socket选项只能来listen调用前针对监听socket设置才有效。比如TCP_MAXSEG选项，代表TCP最大报文段大小，该选项只能由同步报文段来发送。accept从listen监听队列中接收的连接至少是TCP_RECV状态，也就是服务器已经给接收连接端发送了同步报文段，如果TCP_MAXSEG选项在这之后设置，就不起作用了。对客户端而言，这些选项要在connect之前设置。</p>\n<p>解决方案：对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。</p>\n<p>这些选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPLIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNFBUF、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY。</p>\n<h2 id=\"SO-REUSEADDR选项\"><a href=\"#SO-REUSEADDR选项\" class=\"headerlink\" title=\"SO_REUSEADDR选项\"></a>SO_REUSEADDR选项</h2><p>服务器可以通过设置socket选项SO_REUSERADDR来强制使用处于TIME_WAIT状态的连接占用的socket地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int sockfd &#x3D; socket(AF_INET,SOCK_STREAM,0);</span><br><span class=\"line\">assert(sockfd &gt;&#x3D; 0);</span><br><span class=\"line\">int reuse &#x3D; 1;</span><br><span class=\"line\">setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;reuse,sizeof(reuse));</span><br></pre></td></tr></table></figure>\n\n<p>此外，也可以通过改变内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket</p>\n<p>0表示禁用，1表示开启</p>\n<h2 id=\"SO-RCVBUF和SO-SNDBUF\"><a href=\"#SO-RCVBUF和SO-SNDBUF\" class=\"headerlink\" title=\"SO_RCVBUF和SO_SNDBUF\"></a>SO_RCVBUF和SO_SNDBUF</h2><p>分别表示TCP接受缓冲区和发送缓冲区的大小。</p>\n<p>用setsockopt选项设置TCP的接收缓冲区和发送缓冲区的大小时，系统会将其值加倍，并且不得小于某个最小值。</p>\n<p>下面编写修改发送缓冲区和接收缓冲区的程序。<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_10.cpp\" target=\"_blank\" rel=\"noopener\">客户端</a> <a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/5_chapter/5_11.cpp\" target=\"_blank\" rel=\"noopener\">服务器</a></p>\n<p>服务器输出：</p>\n<p><img src=\"/pic/SO_RCVBUF.png\" alt=\"\"></p>\n<p>改变输入参数：</p>\n<p><img src=\"/pic/SO_RCVBUF.png\" alt=\"\"></p>\n<p>客户端输出：</p>\n<p><img src=\"/pic/SNDBUF.png\" alt=\"\"></p>\n<p>改变输入参数：</p>\n<p><img src=\"/pic/SNDBUF1.png\" alt=\"\"></p>\n<p>从服务器的输出可见，系统会将设置的接收缓冲区的值翻倍，但是如果翻倍的值不足系统默认的最小值，我的机器(Ubuntu16.04)默认2240字节，系统就设置成2240字节。</p>\n<p>从客户端的输出可见，系统会将设置的发送缓冲区的值翻倍，但是如果翻倍的值不足系统默认的最小值，系统就设置成4480字节。</p>\n<h2 id=\"SO-LINGER选项\"><a href=\"#SO-LINGER选项\" class=\"headerlink\" title=\"SO_LINGER选项\"></a>SO_LINGER选项</h2><p>用来控制close系统调用在关闭TCP连接时的行为。</p>\n<p>设置SO_LINGER选项的值时，需要给setsockopt(getsockopt)系统调用传递一个linger类型的结构体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct linger&#123;</span><br><span class=\"line\">\tint l_onoff;    &#x2F;&#x2F;开启(非0)还是关闭(0)该选项</span><br><span class=\"line\">    int l_linger;   &#x2F;&#x2F;滞留时间</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>根据linger结构体两个成员变量的不同值，close系统调用可能产生如下3种行为：</p>\n<ul>\n<li>l_onoff = 0。SO_LINGER不起作用。close采用默认行为关闭socket。</li>\n</ul>\n<p>​        默认行为：立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方</p>\n<ul>\n<li><p>l_onoff !=0,l_linger = 0。close立即返回，TCP模块将丢弃被关闭的socket对杨的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供了异常终止一个连接的方法。</p>\n</li>\n<li><p>l_onoff != 0,l_linger &gt; 0。此时close的行为取决于1.被关闭的socket对应的TCP发送缓冲区中是否有残留的数据。2.该socket是阻塞的，还是非阻塞的。</p>\n<p>对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，close返回-1并设置errno为EWOULDBLOCK。</p>\n<p>对于非阻塞的socket，close将立即返回，此时需要根据其返回值和errno来判断残留数据是否已经发送完毕。</p>\n</li>\n</ul>"},{"title":"三次握手四次挥手","date":"2018-11-17T12:51:23.000Z","_content":"\n前面说过TCP是一种面向连接的、可靠的、数据流传输协议。\n\n现在就来谈谈TCP是如何建立连接和结束连接的。\n\n## 三次握手建立连接\n\n准备工作：服务器1.创建socket 2.bind 3. listen 4.阻塞在accept,等待客户端的连接\n客户端调用connet请求连接\n\n![三次握手](/pic/TCP三次握手建立连接.png)\n<!-- more -->\n\n过程解释：\n1.客户端向服务器发送SYN，序号是x，说明客户端请求建立连接，进入SYN_SENT状态\n2.服务器收到客户端发的SYN，回复给客户端SYN和ACK ，进入SYN_RECV状态\n注意:同步序号是新的y，确认序号是x+1\n3.客户端收到服务器发的SYN和ACK，回复ACK给服务器 ，进入ESTABLISHED状态\n注意:客户端的同步序号是x+1(服务器ACK的值),确认序号是y+1\n4.服务器收到客户端的ACK，代表连接已建立，可以进行数据传输,进入ESTABLISHED状态\n\n**这时候很自然就会产生一个疑惑，为什么要进行三次握手，不是一次两次或者四次?**\n\n一个比较官方的答案是：\n\n> 为了防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。\n>\n> ​                                             ——《计算机网络(第7版)》谢希仁\n\n对应具体的实例是：\n\n如果某个客户端发送SYN给服务器，但是由于网络中的某些原因在某个网络结点滞留了，对客户端来说，超过一定时间没收到这个报文就认为该报文失效了，但是如果之后这个报文又到达了服务器，此时服务器回复给客户端确认信息，并且发起连接请求。如果只有两次握手，客户端不回复给服务器，告诉它之前的是失效的报文，那么服务器就一直会阻塞等待客户端发送数据，造成错误，其实质就是为了建立可靠的信道。\n\n因为双方都需要确认对方收到了自己发送的序列号，从而建立可靠的信道，确认过程至少要进行三次通信。\n\n\n\n## 四次挥手结束连接\n\n![四次挥手](/pic/TCP四次挥手释放连接.png)\n\n过程解释:\n1.客户端发送FIN给服务器，序号为u，说明客户端不再发数据给服务器 请求释放从客户端到服务器的连接，进入FIN_WAIT_1状态。\n\n2.服务器收到FIN后，回复ACK，序号是v，确认序号是u+1，同意释放从客户端到服务器的连接，进入CLOSE_WAIT状态\n\n3.客户端收到ACK，此时从客户端到服务器的连接已经释放，但服务器到客户端的连接还没有释放，因此客户端还可以接收数据，进入FIN_WAIT_2状态\n\n4.服务器继续发送发送之前没发完的数据给客户端\n\n5.服务器给客户端发送FIN和ACK，说明服务器已经发送完数据了，请求释放和客户端的连接，就算没收到客户端回复，一段时间之后也会自动释放，进入LAST_ACK状态。\n\n注意：序号是新的w，确认序号依旧是u+1(因为上次ack请求的u+1没收到)\n\n6.客户端收到FIN和ACK，并回复给服务器ACK 序号是u+1，确认序号是w+1，进入TIME_WAIT状态(等待2MSL)\n\n7.服务器收到客户端的ACK后，释放从服务器到客户端的连接\n\n**和三次握手一样，同样会产生为什么需要进行四次挥手？**\n\n因为TCP是全双工通信，客户端请求关闭连接是第一、二次挥手，服务器继续传输之前没传完的数据给客户端，这也是为什么不能在第二次挥手的时候将ACK和FIN同时发给客户端，需要进行第三、四次挥手结束服务器到客户端的连接。\n\n正是由于服务器收到客户端的FIN请求之后，ACK和FIN是分两次发送的，中间隔着剩余数据传输，而建立连接服务器ACK和SYN是一起发给客户端的，所以结束连接比建立连接多一次。\n\n## TCP状态转移\n\nTCP连接的任意一端在任一时刻处在什么状态，当前状态都可以用netstat命令查看。\n\n![](/pic/TCP状态转移过程.png)\n\n虚线表示服务器连接的状态转移，实现表示客户端连接的状态转移\n\n具体分析见《Linux高性能服务器编程》P41\n\n## 连接与断开时候一些特殊情况\n\n#### 半关闭状态\n\n半关闭：连接的一端结束它的发送后还能接收来自另一端数据的状态\n\n发送FIN包意味着告诉另外一端本端已经完成数据的发送。\n\n服务器和客户端程序判断对方是否已经关闭连接的方法：read系统调用返回0(收到结束报文段)，Linux还有别的检测方法，以后补上。\n\n在四次挥手过程中，客户端发出FIN包，服务器确认FIN包，这时候客户端进入半关闭状态\n\nsocket网络编程接口通过shutdown提供对半关闭的支持\n\n#### 连接超时\n\n如果一个客户端访问一个距离它很远的服务器或者由于网络繁忙，导致服务器的回复包没有及时到达客户端，客户端会怎么办？\n\n必然是先进行重传(可能进行多次)，如果重传仍然无效，就通知应用程序连接超时。\n\n超时重连策略：连续发送5个SYN包，时间间隔分别为1s、2s、4s、8s、16s，最后一个TCP报文段的超时时间是32s。因此建立TCP连接的超时时间是63s(根据这个时间和间隔时间推出最后一个报文段的超时时间)。因此，TCP模块总共执行5次超时重连(不算第一个请求的包)。\n\n由/proc/sys/net/ipv4/tcp_syn_retries内核变量所定义，在应用程序中我们可以修改连接超时时间(具体方法以后码上)\n\n#### TIME_WAIT状态\n\n**首先考虑的是为什么要有这个状态，也就是为什么要有2MSL的等待时间？**\n\n首先解释一下MSL：报文段在网络中的最长生存时间。因为TCP报文段以IP数据报在网络内传输，而IP数据包有限制其生存时间的TTL字段。RFC 1122建议是2min。\n\n1.为了保证客户端发送的最后一个ACK报文能够到达服务器，也就是可靠地终止连接。若未成功到达，则服务器超时重传FIN和ACK报文段，客户端再重传ACK，最后客户端和服务器都正常退出。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。\n\n2.可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中消失，保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。就比如最后一个ACK丢包了，服务器重传了FIN+ACK，但是客户端没有2MSL直接结束，立即开启一个新的连接(相同ip+port)就会收到这个包，造成错误。(Linux中一个TCP连接处于TIME_WIAT状态，无法立即使用呢该连接占用的端口来建立一个新的连接)，也就是说TIME_WAIT保证了新的连接(相同ip+port)不会收到原来连接的数据包。\n\nTCP报文段最大生存时间是MSL，2MSL确保网络上两个传输方向尚未被接收到的、迟到的TCP报文段都消失。\n\n**如果有的时候我们希望避免TIME_WAIT状态怎么办？**\n\n也就是说在程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端口，程序无法启动。对于客户端程序，一般不会担心这种问题，因为客户端程序一般用系统自动分配的临时端口号来建立连接，一般都不同。但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。不过，可以通过socket选项SO_REUSEADDR来强制进程立即使用处在TIME_WAIT状态的连接占用的端口号。\n\n**tcpdump抓包测试TIME_WAIT**\n\n![](/pic/nc测试.png)\n\n这里连接的是百度的80端口，第一次接连之后马上退出，第二次尝试连接就显示端口被占用(两次都指定了12345)\n\n使用netstat -nat查看连接状态\n\n![](/pic/netstat命令1.png)\n\nFIN_WAIT2不是我们想要的状态，才能够FIN_WAIT2转换到TIME_WAIT需要收到服务器的FIN包，也就是百度服务器在四次挥手的时候并没有发送FIN包。\n\n通过tcpdump抓取和百度服务器四次挥手的过程进一步来证实我的想法\n\n![](/pic/telnet测试四次挥手.png)\n\n抓包结果为：\n\n![](/pic/tcpdump抓取四次挥手.png)\n\n前三个IP数据报是三次握手发送的，也就是说四次挥手过程中仅抓取到两个IP数据报，另言之就是百度服务器没有主动发送FIN包。\n\n**那问题来了，如果四次挥手的时候，服务器不给客户端发FIN包，会怎么样？**\n\n也就是说客户端处在FIN_WAIT_2状态，等待服务器发送FIN包从而转到TIME_WAIT状态，如果收不到服务器的FIN包，它将一直停留在这个状态。但是如果不是为了在半关闭状态下继续接受数据，连接长时间停留在FIN_WAIT_2状态毫无意义。如果客户端执行半关闭后，还没收到服务器的FIN包就强行退出，此时客户端连接应该由内核来接管，称为孤儿连接。Linux为了防止孤儿连接长时间存留在内核中，\n\n定义了两个内核变量：/proc/sys/net/ipv4/tcp_max_orphans和/proc/sys/net/ipv4/tcp_fin_timeout。\n\n前者指定内核能接管的孤儿连接的数目，后者指定孤儿连接在内核中生存的时间。\n\n#### 何时发送复位报文段(RST)\n\n复位报文段的作用是通知对方关闭连接或重新建立连接\n\n1.访问不存在的端口，目标主机对回复一个复位报文段。(如果客户端程序向服务器某个端口发起连接，但该端口仍被处于TIME_WAIT状态的连接所占用，客户端也会受到复位报文段)\n\n2.异常终止连接。TCP提供异常终止连接的一种方法是给对方发送一个复位报文段，一旦发送复位报文段，发送端所有排队等待发送的数据将被丢弃。应用程序可以使用SO_LINGER来发送复位报文段来异常终止连接。\n\n3.处理半打开连接\n\n半打开状态：服务器(或客户端)关闭或者异常终止了连接，而对方没有接收到结束报文段(比如网络故障)，此时客户端(或服务器)还维持着原来的连接，而服务器(或客户端)即使重启，也没有该连接的任何信息。\n\n如果客户端(或服务器)往处于半打开状态的连接写入数据，则对方回应一个复位报文段。\n\n\n\n\n\n","source":"_posts/三次握手四次挥手.md","raw":"---\ntitle: 三次握手四次挥手\ndate: 2018-11-17 20:51:23\ntags: \n- TCP\n- 网络\n- Linux高性能服务器编程\n---\n\n前面说过TCP是一种面向连接的、可靠的、数据流传输协议。\n\n现在就来谈谈TCP是如何建立连接和结束连接的。\n\n## 三次握手建立连接\n\n准备工作：服务器1.创建socket 2.bind 3. listen 4.阻塞在accept,等待客户端的连接\n客户端调用connet请求连接\n\n![三次握手](/pic/TCP三次握手建立连接.png)\n<!-- more -->\n\n过程解释：\n1.客户端向服务器发送SYN，序号是x，说明客户端请求建立连接，进入SYN_SENT状态\n2.服务器收到客户端发的SYN，回复给客户端SYN和ACK ，进入SYN_RECV状态\n注意:同步序号是新的y，确认序号是x+1\n3.客户端收到服务器发的SYN和ACK，回复ACK给服务器 ，进入ESTABLISHED状态\n注意:客户端的同步序号是x+1(服务器ACK的值),确认序号是y+1\n4.服务器收到客户端的ACK，代表连接已建立，可以进行数据传输,进入ESTABLISHED状态\n\n**这时候很自然就会产生一个疑惑，为什么要进行三次握手，不是一次两次或者四次?**\n\n一个比较官方的答案是：\n\n> 为了防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。\n>\n> ​                                             ——《计算机网络(第7版)》谢希仁\n\n对应具体的实例是：\n\n如果某个客户端发送SYN给服务器，但是由于网络中的某些原因在某个网络结点滞留了，对客户端来说，超过一定时间没收到这个报文就认为该报文失效了，但是如果之后这个报文又到达了服务器，此时服务器回复给客户端确认信息，并且发起连接请求。如果只有两次握手，客户端不回复给服务器，告诉它之前的是失效的报文，那么服务器就一直会阻塞等待客户端发送数据，造成错误，其实质就是为了建立可靠的信道。\n\n因为双方都需要确认对方收到了自己发送的序列号，从而建立可靠的信道，确认过程至少要进行三次通信。\n\n\n\n## 四次挥手结束连接\n\n![四次挥手](/pic/TCP四次挥手释放连接.png)\n\n过程解释:\n1.客户端发送FIN给服务器，序号为u，说明客户端不再发数据给服务器 请求释放从客户端到服务器的连接，进入FIN_WAIT_1状态。\n\n2.服务器收到FIN后，回复ACK，序号是v，确认序号是u+1，同意释放从客户端到服务器的连接，进入CLOSE_WAIT状态\n\n3.客户端收到ACK，此时从客户端到服务器的连接已经释放，但服务器到客户端的连接还没有释放，因此客户端还可以接收数据，进入FIN_WAIT_2状态\n\n4.服务器继续发送发送之前没发完的数据给客户端\n\n5.服务器给客户端发送FIN和ACK，说明服务器已经发送完数据了，请求释放和客户端的连接，就算没收到客户端回复，一段时间之后也会自动释放，进入LAST_ACK状态。\n\n注意：序号是新的w，确认序号依旧是u+1(因为上次ack请求的u+1没收到)\n\n6.客户端收到FIN和ACK，并回复给服务器ACK 序号是u+1，确认序号是w+1，进入TIME_WAIT状态(等待2MSL)\n\n7.服务器收到客户端的ACK后，释放从服务器到客户端的连接\n\n**和三次握手一样，同样会产生为什么需要进行四次挥手？**\n\n因为TCP是全双工通信，客户端请求关闭连接是第一、二次挥手，服务器继续传输之前没传完的数据给客户端，这也是为什么不能在第二次挥手的时候将ACK和FIN同时发给客户端，需要进行第三、四次挥手结束服务器到客户端的连接。\n\n正是由于服务器收到客户端的FIN请求之后，ACK和FIN是分两次发送的，中间隔着剩余数据传输，而建立连接服务器ACK和SYN是一起发给客户端的，所以结束连接比建立连接多一次。\n\n## TCP状态转移\n\nTCP连接的任意一端在任一时刻处在什么状态，当前状态都可以用netstat命令查看。\n\n![](/pic/TCP状态转移过程.png)\n\n虚线表示服务器连接的状态转移，实现表示客户端连接的状态转移\n\n具体分析见《Linux高性能服务器编程》P41\n\n## 连接与断开时候一些特殊情况\n\n#### 半关闭状态\n\n半关闭：连接的一端结束它的发送后还能接收来自另一端数据的状态\n\n发送FIN包意味着告诉另外一端本端已经完成数据的发送。\n\n服务器和客户端程序判断对方是否已经关闭连接的方法：read系统调用返回0(收到结束报文段)，Linux还有别的检测方法，以后补上。\n\n在四次挥手过程中，客户端发出FIN包，服务器确认FIN包，这时候客户端进入半关闭状态\n\nsocket网络编程接口通过shutdown提供对半关闭的支持\n\n#### 连接超时\n\n如果一个客户端访问一个距离它很远的服务器或者由于网络繁忙，导致服务器的回复包没有及时到达客户端，客户端会怎么办？\n\n必然是先进行重传(可能进行多次)，如果重传仍然无效，就通知应用程序连接超时。\n\n超时重连策略：连续发送5个SYN包，时间间隔分别为1s、2s、4s、8s、16s，最后一个TCP报文段的超时时间是32s。因此建立TCP连接的超时时间是63s(根据这个时间和间隔时间推出最后一个报文段的超时时间)。因此，TCP模块总共执行5次超时重连(不算第一个请求的包)。\n\n由/proc/sys/net/ipv4/tcp_syn_retries内核变量所定义，在应用程序中我们可以修改连接超时时间(具体方法以后码上)\n\n#### TIME_WAIT状态\n\n**首先考虑的是为什么要有这个状态，也就是为什么要有2MSL的等待时间？**\n\n首先解释一下MSL：报文段在网络中的最长生存时间。因为TCP报文段以IP数据报在网络内传输，而IP数据包有限制其生存时间的TTL字段。RFC 1122建议是2min。\n\n1.为了保证客户端发送的最后一个ACK报文能够到达服务器，也就是可靠地终止连接。若未成功到达，则服务器超时重传FIN和ACK报文段，客户端再重传ACK，最后客户端和服务器都正常退出。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。\n\n2.可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中消失，保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。就比如最后一个ACK丢包了，服务器重传了FIN+ACK，但是客户端没有2MSL直接结束，立即开启一个新的连接(相同ip+port)就会收到这个包，造成错误。(Linux中一个TCP连接处于TIME_WIAT状态，无法立即使用呢该连接占用的端口来建立一个新的连接)，也就是说TIME_WAIT保证了新的连接(相同ip+port)不会收到原来连接的数据包。\n\nTCP报文段最大生存时间是MSL，2MSL确保网络上两个传输方向尚未被接收到的、迟到的TCP报文段都消失。\n\n**如果有的时候我们希望避免TIME_WAIT状态怎么办？**\n\n也就是说在程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端口，程序无法启动。对于客户端程序，一般不会担心这种问题，因为客户端程序一般用系统自动分配的临时端口号来建立连接，一般都不同。但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。不过，可以通过socket选项SO_REUSEADDR来强制进程立即使用处在TIME_WAIT状态的连接占用的端口号。\n\n**tcpdump抓包测试TIME_WAIT**\n\n![](/pic/nc测试.png)\n\n这里连接的是百度的80端口，第一次接连之后马上退出，第二次尝试连接就显示端口被占用(两次都指定了12345)\n\n使用netstat -nat查看连接状态\n\n![](/pic/netstat命令1.png)\n\nFIN_WAIT2不是我们想要的状态，才能够FIN_WAIT2转换到TIME_WAIT需要收到服务器的FIN包，也就是百度服务器在四次挥手的时候并没有发送FIN包。\n\n通过tcpdump抓取和百度服务器四次挥手的过程进一步来证实我的想法\n\n![](/pic/telnet测试四次挥手.png)\n\n抓包结果为：\n\n![](/pic/tcpdump抓取四次挥手.png)\n\n前三个IP数据报是三次握手发送的，也就是说四次挥手过程中仅抓取到两个IP数据报，另言之就是百度服务器没有主动发送FIN包。\n\n**那问题来了，如果四次挥手的时候，服务器不给客户端发FIN包，会怎么样？**\n\n也就是说客户端处在FIN_WAIT_2状态，等待服务器发送FIN包从而转到TIME_WAIT状态，如果收不到服务器的FIN包，它将一直停留在这个状态。但是如果不是为了在半关闭状态下继续接受数据，连接长时间停留在FIN_WAIT_2状态毫无意义。如果客户端执行半关闭后，还没收到服务器的FIN包就强行退出，此时客户端连接应该由内核来接管，称为孤儿连接。Linux为了防止孤儿连接长时间存留在内核中，\n\n定义了两个内核变量：/proc/sys/net/ipv4/tcp_max_orphans和/proc/sys/net/ipv4/tcp_fin_timeout。\n\n前者指定内核能接管的孤儿连接的数目，后者指定孤儿连接在内核中生存的时间。\n\n#### 何时发送复位报文段(RST)\n\n复位报文段的作用是通知对方关闭连接或重新建立连接\n\n1.访问不存在的端口，目标主机对回复一个复位报文段。(如果客户端程序向服务器某个端口发起连接，但该端口仍被处于TIME_WAIT状态的连接所占用，客户端也会受到复位报文段)\n\n2.异常终止连接。TCP提供异常终止连接的一种方法是给对方发送一个复位报文段，一旦发送复位报文段，发送端所有排队等待发送的数据将被丢弃。应用程序可以使用SO_LINGER来发送复位报文段来异常终止连接。\n\n3.处理半打开连接\n\n半打开状态：服务器(或客户端)关闭或者异常终止了连接，而对方没有接收到结束报文段(比如网络故障)，此时客户端(或服务器)还维持着原来的连接，而服务器(或客户端)即使重启，也没有该连接的任何信息。\n\n如果客户端(或服务器)往处于半打开状态的连接写入数据，则对方回应一个复位报文段。\n\n\n\n\n\n","slug":"三次握手四次挥手","published":1,"updated":"2021-12-06T05:30:36.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7n001c96cad37k29qg","content":"<p>前面说过TCP是一种面向连接的、可靠的、数据流传输协议。</p>\n<p>现在就来谈谈TCP是如何建立连接和结束连接的。</p>\n<h2 id=\"三次握手建立连接\"><a href=\"#三次握手建立连接\" class=\"headerlink\" title=\"三次握手建立连接\"></a>三次握手建立连接</h2><p>准备工作：服务器1.创建socket 2.bind 3. listen 4.阻塞在accept,等待客户端的连接<br>客户端调用connet请求连接</p>\n<p><img src=\"/pic/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png\" alt=\"三次握手\"></p>\n<a id=\"more\"></a>\n\n<p>过程解释：<br>1.客户端向服务器发送SYN，序号是x，说明客户端请求建立连接，进入SYN_SENT状态<br>2.服务器收到客户端发的SYN，回复给客户端SYN和ACK ，进入SYN_RECV状态<br>注意:同步序号是新的y，确认序号是x+1<br>3.客户端收到服务器发的SYN和ACK，回复ACK给服务器 ，进入ESTABLISHED状态<br>注意:客户端的同步序号是x+1(服务器ACK的值),确认序号是y+1<br>4.服务器收到客户端的ACK，代表连接已建立，可以进行数据传输,进入ESTABLISHED状态</p>\n<p><strong>这时候很自然就会产生一个疑惑，为什么要进行三次握手，不是一次两次或者四次?</strong></p>\n<p>一个比较官方的答案是：</p>\n<blockquote>\n<p>为了防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。</p>\n<p>​                                             ——《计算机网络(第7版)》谢希仁</p>\n</blockquote>\n<p>对应具体的实例是：</p>\n<p>如果某个客户端发送SYN给服务器，但是由于网络中的某些原因在某个网络结点滞留了，对客户端来说，超过一定时间没收到这个报文就认为该报文失效了，但是如果之后这个报文又到达了服务器，此时服务器回复给客户端确认信息，并且发起连接请求。如果只有两次握手，客户端不回复给服务器，告诉它之前的是失效的报文，那么服务器就一直会阻塞等待客户端发送数据，造成错误，其实质就是为了建立可靠的信道。</p>\n<p>因为双方都需要确认对方收到了自己发送的序列号，从而建立可靠的信道，确认过程至少要进行三次通信。</p>\n<h2 id=\"四次挥手结束连接\"><a href=\"#四次挥手结束连接\" class=\"headerlink\" title=\"四次挥手结束连接\"></a>四次挥手结束连接</h2><p><img src=\"/pic/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png\" alt=\"四次挥手\"></p>\n<p>过程解释:<br>1.客户端发送FIN给服务器，序号为u，说明客户端不再发数据给服务器 请求释放从客户端到服务器的连接，进入FIN_WAIT_1状态。</p>\n<p>2.服务器收到FIN后，回复ACK，序号是v，确认序号是u+1，同意释放从客户端到服务器的连接，进入CLOSE_WAIT状态</p>\n<p>3.客户端收到ACK，此时从客户端到服务器的连接已经释放，但服务器到客户端的连接还没有释放，因此客户端还可以接收数据，进入FIN_WAIT_2状态</p>\n<p>4.服务器继续发送发送之前没发完的数据给客户端</p>\n<p>5.服务器给客户端发送FIN和ACK，说明服务器已经发送完数据了，请求释放和客户端的连接，就算没收到客户端回复，一段时间之后也会自动释放，进入LAST_ACK状态。</p>\n<p>注意：序号是新的w，确认序号依旧是u+1(因为上次ack请求的u+1没收到)</p>\n<p>6.客户端收到FIN和ACK，并回复给服务器ACK 序号是u+1，确认序号是w+1，进入TIME_WAIT状态(等待2MSL)</p>\n<p>7.服务器收到客户端的ACK后，释放从服务器到客户端的连接</p>\n<p><strong>和三次握手一样，同样会产生为什么需要进行四次挥手？</strong></p>\n<p>因为TCP是全双工通信，客户端请求关闭连接是第一、二次挥手，服务器继续传输之前没传完的数据给客户端，这也是为什么不能在第二次挥手的时候将ACK和FIN同时发给客户端，需要进行第三、四次挥手结束服务器到客户端的连接。</p>\n<p>正是由于服务器收到客户端的FIN请求之后，ACK和FIN是分两次发送的，中间隔着剩余数据传输，而建立连接服务器ACK和SYN是一起发给客户端的，所以结束连接比建立连接多一次。</p>\n<h2 id=\"TCP状态转移\"><a href=\"#TCP状态转移\" class=\"headerlink\" title=\"TCP状态转移\"></a>TCP状态转移</h2><p>TCP连接的任意一端在任一时刻处在什么状态，当前状态都可以用netstat命令查看。</p>\n<p><img src=\"/pic/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%BF%87%E7%A8%8B.png\" alt=\"\"></p>\n<p>虚线表示服务器连接的状态转移，实现表示客户端连接的状态转移</p>\n<p>具体分析见《Linux高性能服务器编程》P41</p>\n<h2 id=\"连接与断开时候一些特殊情况\"><a href=\"#连接与断开时候一些特殊情况\" class=\"headerlink\" title=\"连接与断开时候一些特殊情况\"></a>连接与断开时候一些特殊情况</h2><h4 id=\"半关闭状态\"><a href=\"#半关闭状态\" class=\"headerlink\" title=\"半关闭状态\"></a>半关闭状态</h4><p>半关闭：连接的一端结束它的发送后还能接收来自另一端数据的状态</p>\n<p>发送FIN包意味着告诉另外一端本端已经完成数据的发送。</p>\n<p>服务器和客户端程序判断对方是否已经关闭连接的方法：read系统调用返回0(收到结束报文段)，Linux还有别的检测方法，以后补上。</p>\n<p>在四次挥手过程中，客户端发出FIN包，服务器确认FIN包，这时候客户端进入半关闭状态</p>\n<p>socket网络编程接口通过shutdown提供对半关闭的支持</p>\n<h4 id=\"连接超时\"><a href=\"#连接超时\" class=\"headerlink\" title=\"连接超时\"></a>连接超时</h4><p>如果一个客户端访问一个距离它很远的服务器或者由于网络繁忙，导致服务器的回复包没有及时到达客户端，客户端会怎么办？</p>\n<p>必然是先进行重传(可能进行多次)，如果重传仍然无效，就通知应用程序连接超时。</p>\n<p>超时重连策略：连续发送5个SYN包，时间间隔分别为1s、2s、4s、8s、16s，最后一个TCP报文段的超时时间是32s。因此建立TCP连接的超时时间是63s(根据这个时间和间隔时间推出最后一个报文段的超时时间)。因此，TCP模块总共执行5次超时重连(不算第一个请求的包)。</p>\n<p>由/proc/sys/net/ipv4/tcp_syn_retries内核变量所定义，在应用程序中我们可以修改连接超时时间(具体方法以后码上)</p>\n<h4 id=\"TIME-WAIT状态\"><a href=\"#TIME-WAIT状态\" class=\"headerlink\" title=\"TIME_WAIT状态\"></a>TIME_WAIT状态</h4><p><strong>首先考虑的是为什么要有这个状态，也就是为什么要有2MSL的等待时间？</strong></p>\n<p>首先解释一下MSL：报文段在网络中的最长生存时间。因为TCP报文段以IP数据报在网络内传输，而IP数据包有限制其生存时间的TTL字段。RFC 1122建议是2min。</p>\n<p>1.为了保证客户端发送的最后一个ACK报文能够到达服务器，也就是可靠地终止连接。若未成功到达，则服务器超时重传FIN和ACK报文段，客户端再重传ACK，最后客户端和服务器都正常退出。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>\n<p>2.可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中消失，保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。就比如最后一个ACK丢包了，服务器重传了FIN+ACK，但是客户端没有2MSL直接结束，立即开启一个新的连接(相同ip+port)就会收到这个包，造成错误。(Linux中一个TCP连接处于TIME_WIAT状态，无法立即使用呢该连接占用的端口来建立一个新的连接)，也就是说TIME_WAIT保证了新的连接(相同ip+port)不会收到原来连接的数据包。</p>\n<p>TCP报文段最大生存时间是MSL，2MSL确保网络上两个传输方向尚未被接收到的、迟到的TCP报文段都消失。</p>\n<p><strong>如果有的时候我们希望避免TIME_WAIT状态怎么办？</strong></p>\n<p>也就是说在程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端口，程序无法启动。对于客户端程序，一般不会担心这种问题，因为客户端程序一般用系统自动分配的临时端口号来建立连接，一般都不同。但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。不过，可以通过socket选项SO_REUSEADDR来强制进程立即使用处在TIME_WAIT状态的连接占用的端口号。</p>\n<p><strong>tcpdump抓包测试TIME_WAIT</strong></p>\n<p><img src=\"/pic/nc%E6%B5%8B%E8%AF%95.png\" alt=\"\"></p>\n<p>这里连接的是百度的80端口，第一次接连之后马上退出，第二次尝试连接就显示端口被占用(两次都指定了12345)</p>\n<p>使用netstat -nat查看连接状态</p>\n<p><img src=\"/pic/netstat%E5%91%BD%E4%BB%A41.png\" alt=\"\"></p>\n<p>FIN_WAIT2不是我们想要的状态，才能够FIN_WAIT2转换到TIME_WAIT需要收到服务器的FIN包，也就是百度服务器在四次挥手的时候并没有发送FIN包。</p>\n<p>通过tcpdump抓取和百度服务器四次挥手的过程进一步来证实我的想法</p>\n<p><img src=\"/pic/telnet%E6%B5%8B%E8%AF%95%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png\" alt=\"\"></p>\n<p>抓包结果为：</p>\n<p><img src=\"/pic/tcpdump%E6%8A%93%E5%8F%96%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png\" alt=\"\"></p>\n<p>前三个IP数据报是三次握手发送的，也就是说四次挥手过程中仅抓取到两个IP数据报，另言之就是百度服务器没有主动发送FIN包。</p>\n<p><strong>那问题来了，如果四次挥手的时候，服务器不给客户端发FIN包，会怎么样？</strong></p>\n<p>也就是说客户端处在FIN_WAIT_2状态，等待服务器发送FIN包从而转到TIME_WAIT状态，如果收不到服务器的FIN包，它将一直停留在这个状态。但是如果不是为了在半关闭状态下继续接受数据，连接长时间停留在FIN_WAIT_2状态毫无意义。如果客户端执行半关闭后，还没收到服务器的FIN包就强行退出，此时客户端连接应该由内核来接管，称为孤儿连接。Linux为了防止孤儿连接长时间存留在内核中，</p>\n<p>定义了两个内核变量：/proc/sys/net/ipv4/tcp_max_orphans和/proc/sys/net/ipv4/tcp_fin_timeout。</p>\n<p>前者指定内核能接管的孤儿连接的数目，后者指定孤儿连接在内核中生存的时间。</p>\n<h4 id=\"何时发送复位报文段-RST\"><a href=\"#何时发送复位报文段-RST\" class=\"headerlink\" title=\"何时发送复位报文段(RST)\"></a>何时发送复位报文段(RST)</h4><p>复位报文段的作用是通知对方关闭连接或重新建立连接</p>\n<p>1.访问不存在的端口，目标主机对回复一个复位报文段。(如果客户端程序向服务器某个端口发起连接，但该端口仍被处于TIME_WAIT状态的连接所占用，客户端也会受到复位报文段)</p>\n<p>2.异常终止连接。TCP提供异常终止连接的一种方法是给对方发送一个复位报文段，一旦发送复位报文段，发送端所有排队等待发送的数据将被丢弃。应用程序可以使用SO_LINGER来发送复位报文段来异常终止连接。</p>\n<p>3.处理半打开连接</p>\n<p>半打开状态：服务器(或客户端)关闭或者异常终止了连接，而对方没有接收到结束报文段(比如网络故障)，此时客户端(或服务器)还维持着原来的连接，而服务器(或客户端)即使重启，也没有该连接的任何信息。</p>\n<p>如果客户端(或服务器)往处于半打开状态的连接写入数据，则对方回应一个复位报文段。</p>\n","site":{"data":{}},"excerpt":"<p>前面说过TCP是一种面向连接的、可靠的、数据流传输协议。</p>\n<p>现在就来谈谈TCP是如何建立连接和结束连接的。</p>\n<h2 id=\"三次握手建立连接\"><a href=\"#三次握手建立连接\" class=\"headerlink\" title=\"三次握手建立连接\"></a>三次握手建立连接</h2><p>准备工作：服务器1.创建socket 2.bind 3. listen 4.阻塞在accept,等待客户端的连接<br>客户端调用connet请求连接</p>\n<p><img src=\"/pic/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png\" alt=\"三次握手\"></p>","more":"<p>过程解释：<br>1.客户端向服务器发送SYN，序号是x，说明客户端请求建立连接，进入SYN_SENT状态<br>2.服务器收到客户端发的SYN，回复给客户端SYN和ACK ，进入SYN_RECV状态<br>注意:同步序号是新的y，确认序号是x+1<br>3.客户端收到服务器发的SYN和ACK，回复ACK给服务器 ，进入ESTABLISHED状态<br>注意:客户端的同步序号是x+1(服务器ACK的值),确认序号是y+1<br>4.服务器收到客户端的ACK，代表连接已建立，可以进行数据传输,进入ESTABLISHED状态</p>\n<p><strong>这时候很自然就会产生一个疑惑，为什么要进行三次握手，不是一次两次或者四次?</strong></p>\n<p>一个比较官方的答案是：</p>\n<blockquote>\n<p>为了防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。</p>\n<p>​                                             ——《计算机网络(第7版)》谢希仁</p>\n</blockquote>\n<p>对应具体的实例是：</p>\n<p>如果某个客户端发送SYN给服务器，但是由于网络中的某些原因在某个网络结点滞留了，对客户端来说，超过一定时间没收到这个报文就认为该报文失效了，但是如果之后这个报文又到达了服务器，此时服务器回复给客户端确认信息，并且发起连接请求。如果只有两次握手，客户端不回复给服务器，告诉它之前的是失效的报文，那么服务器就一直会阻塞等待客户端发送数据，造成错误，其实质就是为了建立可靠的信道。</p>\n<p>因为双方都需要确认对方收到了自己发送的序列号，从而建立可靠的信道，确认过程至少要进行三次通信。</p>\n<h2 id=\"四次挥手结束连接\"><a href=\"#四次挥手结束连接\" class=\"headerlink\" title=\"四次挥手结束连接\"></a>四次挥手结束连接</h2><p><img src=\"/pic/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png\" alt=\"四次挥手\"></p>\n<p>过程解释:<br>1.客户端发送FIN给服务器，序号为u，说明客户端不再发数据给服务器 请求释放从客户端到服务器的连接，进入FIN_WAIT_1状态。</p>\n<p>2.服务器收到FIN后，回复ACK，序号是v，确认序号是u+1，同意释放从客户端到服务器的连接，进入CLOSE_WAIT状态</p>\n<p>3.客户端收到ACK，此时从客户端到服务器的连接已经释放，但服务器到客户端的连接还没有释放，因此客户端还可以接收数据，进入FIN_WAIT_2状态</p>\n<p>4.服务器继续发送发送之前没发完的数据给客户端</p>\n<p>5.服务器给客户端发送FIN和ACK，说明服务器已经发送完数据了，请求释放和客户端的连接，就算没收到客户端回复，一段时间之后也会自动释放，进入LAST_ACK状态。</p>\n<p>注意：序号是新的w，确认序号依旧是u+1(因为上次ack请求的u+1没收到)</p>\n<p>6.客户端收到FIN和ACK，并回复给服务器ACK 序号是u+1，确认序号是w+1，进入TIME_WAIT状态(等待2MSL)</p>\n<p>7.服务器收到客户端的ACK后，释放从服务器到客户端的连接</p>\n<p><strong>和三次握手一样，同样会产生为什么需要进行四次挥手？</strong></p>\n<p>因为TCP是全双工通信，客户端请求关闭连接是第一、二次挥手，服务器继续传输之前没传完的数据给客户端，这也是为什么不能在第二次挥手的时候将ACK和FIN同时发给客户端，需要进行第三、四次挥手结束服务器到客户端的连接。</p>\n<p>正是由于服务器收到客户端的FIN请求之后，ACK和FIN是分两次发送的，中间隔着剩余数据传输，而建立连接服务器ACK和SYN是一起发给客户端的，所以结束连接比建立连接多一次。</p>\n<h2 id=\"TCP状态转移\"><a href=\"#TCP状态转移\" class=\"headerlink\" title=\"TCP状态转移\"></a>TCP状态转移</h2><p>TCP连接的任意一端在任一时刻处在什么状态，当前状态都可以用netstat命令查看。</p>\n<p><img src=\"/pic/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E8%BF%87%E7%A8%8B.png\" alt=\"\"></p>\n<p>虚线表示服务器连接的状态转移，实现表示客户端连接的状态转移</p>\n<p>具体分析见《Linux高性能服务器编程》P41</p>\n<h2 id=\"连接与断开时候一些特殊情况\"><a href=\"#连接与断开时候一些特殊情况\" class=\"headerlink\" title=\"连接与断开时候一些特殊情况\"></a>连接与断开时候一些特殊情况</h2><h4 id=\"半关闭状态\"><a href=\"#半关闭状态\" class=\"headerlink\" title=\"半关闭状态\"></a>半关闭状态</h4><p>半关闭：连接的一端结束它的发送后还能接收来自另一端数据的状态</p>\n<p>发送FIN包意味着告诉另外一端本端已经完成数据的发送。</p>\n<p>服务器和客户端程序判断对方是否已经关闭连接的方法：read系统调用返回0(收到结束报文段)，Linux还有别的检测方法，以后补上。</p>\n<p>在四次挥手过程中，客户端发出FIN包，服务器确认FIN包，这时候客户端进入半关闭状态</p>\n<p>socket网络编程接口通过shutdown提供对半关闭的支持</p>\n<h4 id=\"连接超时\"><a href=\"#连接超时\" class=\"headerlink\" title=\"连接超时\"></a>连接超时</h4><p>如果一个客户端访问一个距离它很远的服务器或者由于网络繁忙，导致服务器的回复包没有及时到达客户端，客户端会怎么办？</p>\n<p>必然是先进行重传(可能进行多次)，如果重传仍然无效，就通知应用程序连接超时。</p>\n<p>超时重连策略：连续发送5个SYN包，时间间隔分别为1s、2s、4s、8s、16s，最后一个TCP报文段的超时时间是32s。因此建立TCP连接的超时时间是63s(根据这个时间和间隔时间推出最后一个报文段的超时时间)。因此，TCP模块总共执行5次超时重连(不算第一个请求的包)。</p>\n<p>由/proc/sys/net/ipv4/tcp_syn_retries内核变量所定义，在应用程序中我们可以修改连接超时时间(具体方法以后码上)</p>\n<h4 id=\"TIME-WAIT状态\"><a href=\"#TIME-WAIT状态\" class=\"headerlink\" title=\"TIME_WAIT状态\"></a>TIME_WAIT状态</h4><p><strong>首先考虑的是为什么要有这个状态，也就是为什么要有2MSL的等待时间？</strong></p>\n<p>首先解释一下MSL：报文段在网络中的最长生存时间。因为TCP报文段以IP数据报在网络内传输，而IP数据包有限制其生存时间的TTL字段。RFC 1122建议是2min。</p>\n<p>1.为了保证客户端发送的最后一个ACK报文能够到达服务器，也就是可靠地终止连接。若未成功到达，则服务器超时重传FIN和ACK报文段，客户端再重传ACK，最后客户端和服务器都正常退出。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>\n<p>2.可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中消失，保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。就比如最后一个ACK丢包了，服务器重传了FIN+ACK，但是客户端没有2MSL直接结束，立即开启一个新的连接(相同ip+port)就会收到这个包，造成错误。(Linux中一个TCP连接处于TIME_WIAT状态，无法立即使用呢该连接占用的端口来建立一个新的连接)，也就是说TIME_WAIT保证了新的连接(相同ip+port)不会收到原来连接的数据包。</p>\n<p>TCP报文段最大生存时间是MSL，2MSL确保网络上两个传输方向尚未被接收到的、迟到的TCP报文段都消失。</p>\n<p><strong>如果有的时候我们希望避免TIME_WAIT状态怎么办？</strong></p>\n<p>也就是说在程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端口，程序无法启动。对于客户端程序，一般不会担心这种问题，因为客户端程序一般用系统自动分配的临时端口号来建立连接，一般都不同。但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。不过，可以通过socket选项SO_REUSEADDR来强制进程立即使用处在TIME_WAIT状态的连接占用的端口号。</p>\n<p><strong>tcpdump抓包测试TIME_WAIT</strong></p>\n<p><img src=\"/pic/nc%E6%B5%8B%E8%AF%95.png\" alt=\"\"></p>\n<p>这里连接的是百度的80端口，第一次接连之后马上退出，第二次尝试连接就显示端口被占用(两次都指定了12345)</p>\n<p>使用netstat -nat查看连接状态</p>\n<p><img src=\"/pic/netstat%E5%91%BD%E4%BB%A41.png\" alt=\"\"></p>\n<p>FIN_WAIT2不是我们想要的状态，才能够FIN_WAIT2转换到TIME_WAIT需要收到服务器的FIN包，也就是百度服务器在四次挥手的时候并没有发送FIN包。</p>\n<p>通过tcpdump抓取和百度服务器四次挥手的过程进一步来证实我的想法</p>\n<p><img src=\"/pic/telnet%E6%B5%8B%E8%AF%95%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png\" alt=\"\"></p>\n<p>抓包结果为：</p>\n<p><img src=\"/pic/tcpdump%E6%8A%93%E5%8F%96%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png\" alt=\"\"></p>\n<p>前三个IP数据报是三次握手发送的，也就是说四次挥手过程中仅抓取到两个IP数据报，另言之就是百度服务器没有主动发送FIN包。</p>\n<p><strong>那问题来了，如果四次挥手的时候，服务器不给客户端发FIN包，会怎么样？</strong></p>\n<p>也就是说客户端处在FIN_WAIT_2状态，等待服务器发送FIN包从而转到TIME_WAIT状态，如果收不到服务器的FIN包，它将一直停留在这个状态。但是如果不是为了在半关闭状态下继续接受数据，连接长时间停留在FIN_WAIT_2状态毫无意义。如果客户端执行半关闭后，还没收到服务器的FIN包就强行退出，此时客户端连接应该由内核来接管，称为孤儿连接。Linux为了防止孤儿连接长时间存留在内核中，</p>\n<p>定义了两个内核变量：/proc/sys/net/ipv4/tcp_max_orphans和/proc/sys/net/ipv4/tcp_fin_timeout。</p>\n<p>前者指定内核能接管的孤儿连接的数目，后者指定孤儿连接在内核中生存的时间。</p>\n<h4 id=\"何时发送复位报文段-RST\"><a href=\"#何时发送复位报文段-RST\" class=\"headerlink\" title=\"何时发送复位报文段(RST)\"></a>何时发送复位报文段(RST)</h4><p>复位报文段的作用是通知对方关闭连接或重新建立连接</p>\n<p>1.访问不存在的端口，目标主机对回复一个复位报文段。(如果客户端程序向服务器某个端口发起连接，但该端口仍被处于TIME_WAIT状态的连接所占用，客户端也会受到复位报文段)</p>\n<p>2.异常终止连接。TCP提供异常终止连接的一种方法是给对方发送一个复位报文段，一旦发送复位报文段，发送端所有排队等待发送的数据将被丢弃。应用程序可以使用SO_LINGER来发送复位报文段来异常终止连接。</p>\n<p>3.处理半打开连接</p>\n<p>半打开状态：服务器(或客户端)关闭或者异常终止了连接，而对方没有接收到结束报文段(比如网络故障)，此时客户端(或服务器)还维持着原来的连接，而服务器(或客户端)即使重启，也没有该连接的任何信息。</p>\n<p>如果客户端(或服务器)往处于半打开状态的连接写入数据，则对方回应一个复位报文段。</p>"},{"title":"八大设计原则","date":"2019-04-24T12:27:23.000Z","_content":"\n最近在看李建忠老师的设计模式的课程，做一下学习笔记,可以参考书籍《设计模式:可复用面向对象软件的基础》,这本书是四个人写的，所以也简称GOF设计模式。\n\n解决复杂问题主要的方式有两种：\n\n- 分解,分而治之。像C语言这种结构化的语言就是如此\n- 抽象。由于不能掌握全部的复杂对象，选择忽视它的非本质细节，而去锤泛化和理想化的对象模型\n\n在设计模式中和重要的一个东西就是抽象。\n\n<!--more-->\n\n#### 结构化VS面向对象\n\n演示的任务：画图形\n\n分解的设计方法,以伪码的方式展示：\n\n```\n//shape.h  封装一些特定的形状\nclass Point{\npublic:\n\tint x;\n\tint y;\n};\n\nclass Line{\npublic:\n\tPoint start;\n\tPoint end;\n\tLine(const Point&start,const Point&end){\n        this->start = start;\n        this->end = end;\n\t}\n};\n\nclass Rect{\npublic:\n\tPoint leftUp;\n\tint width;\n\tint height;\n\tRect(const Point& leftUp,int width,int height){\n        this->leftUp = leftUp;\n        this->width = width;\n        this->height = height;\n\t}\n};\n------------------------------------------------------------\n//MainForm.h  窗口类 负责处理各种事件 \n#include\"shape.h\"\nclass MainForm : public Form{\nprivate:\n\tPoint p1;\n\tPoint p2;    //鼠标画图的起始点和终止点\n\t\n\tvector<Line> linevector;\n\tvector<Rect> rectVector;\npublic:\n\tMainForm(){\n        //...\n\t}\nprotected:\n\tvirtual void OnMouseDown(const MouseEventArgs& e);\n\tvirtual void OnMouseUp(const MouseEventArgs& e);\n\tvirtual void OnPaint(const MouseEventArgs& e);\n};\nvoid MainForm::OnMouseDown(const MouseEventArgs& e){\n    p1.x = e.x;\n    p1.y = e.y;\n    //...\n    Form::OnMouseDown(e);\n}\nvoid MainForm::OnMouseUp(const MouseEventArgs& e){\n    p2.x = e.x;\n    p2.y = e.y;\n    \n    if(rdoLine.Checked){\n        Line line(p1,p2);\n        lineVector.push_back(line);\n    }\n    else if(rdoRect.Checked){\n        int width = abs(p2.x-p1.x);\n        int height = abs(p2.y-p1.y);\n        Rect rect(p1,width,height);\n        rectVector.push_back(rect);\n    }\n    //...\n    this->Refresh();\n    \n    Form::OnMouseUp(e);\n}\nvoid MainForm::OnPaint(const MouseEventArgs& e){\n    //针对直线\n    for(int i = 0;i<lineVector.size();i++){\n        e.Graphics.DrawLine(Pens.Red,\n                            lineVector[i].start.x,\n                            lineVector[i].start.y,\n                            lineVector[i].end.x,\n                            lineVector[i].end.y);\n    }\n    \n    //针对矩形\n    for(int i = 0;i<rectVector.size();i++){\n        e.Graphics.DrawRectangle(Pens.Res,\n                                 rectVector[i],leftUp,\n                                 rectVector[i].width,\n                                 rectVector[i].height);\n    }\n    //...\n    Form::OnPaint(e);\n}\n\n```\n\n抽象的设计方法：\n\n```\n//shape.h  \n//抽象出一个Shape的基类，让具体的形状类继承它\nclass Shape{   //抽象类\npublic:\n\tvirtual void Draw(const Graphics& g) = 0;\n\tvirtual ~Shape(){}\n}\nclass Point{\npublic:\n\tint x;\n\tint y;\n}\nclass Line:public Shape{\npublic:\n\tPoint start;\n\tPoint end;\n\t//Line的构造函数  同上\n\t\n\t//实现自己的Draw,负责画自己\n\tvirtual void Draw(const Graphics& g){\n\t\tg.DrawLine(Pens.Red,start.x,start.y,end.x,end.y);\n\t}\n};\n\nclass Rect{\npublic:\n\tPoint leftUp;\n\tint width;\n\tint height;\n\t//Rect的构造函数  同上\n\t\n\t//实现自己的Draw,负责画自己\n\tvirtual void Draw(const Graphics& g){\n\t\tg.DrawLine(Pens.Red,leftUp，width,height);\n\t}\n};\n-----------------------------------------------------------------\n#include\"shape.h\"\nclass MainForm : public Form{\nprivate:\n\tPoint p1;\n\tPoint p2;    //鼠标画图的起始点和终止点\n\t\n\t//针对所有形状\n\tvector<Shape*> shapeVector;  存储的是指针 因为需要多态性\npublic:\n\tMainForm(){\n        //...\n\t}\nprotected:\n\tvirtual void OnMouseDown(const MouseEventArgs& e);\n\tvirtual void OnMouseUp(const MouseEventArgs& e);\n\tvirtual void OnPaint(const MouseEventArgs& e);\n};\nvoid MainForm::OnMouseDown(const MouseEventArgs& e){\n    p1.x = e.x;\n    p1.y = e.y;\n    //...\n    Form::OnMouseDown(e);\n}\nvoid MainForm::OnMouseUp(const MouseEventArgs& e){\n    p2.x = e.x;\n    p2.y = e.y;\n    \n    if(rdoLine.Checked){\n    \t//需要注意的是 因为容器里放的是指针 因此不能放一个栈对象\n        lineVector.push_back(new Line(p1,p2));\n    }\n    else if(rdoRect.Checked){\n        int width = abs(p2.x-p1.x);\n        int height = abs(p2.y-p1.y);\n        rectVector.push_back(new Rect(p1,width,height));\n    }\n    //...\n    this->Refresh();\n    \n    Form::OnMouseUp(e);\n}\nvoid MainForm::OnPaint(const MouseEventArgs& e){\n\t\n\t//统一处理所有的形状\n\tfor(int i = 0;i<shapeVector.size();i++){\n    \tshapeVector[i]->Draw(e.Graphics); //多态调用，各负其责\t    \n\t}\n\t\n    //...\n    Form::OnPaint(e);\n}\n\n\n```\n\n通过加入一个新的需求来对比一下两种设计方法。\n\n比如要新加一个画图的功能。\n\n对于分解的方法：\n\n- 在shape文件中新添一个Circle类\n- 然后在MainForm里面加入一个vector存储所有的Circle对象，然后在OnMouseUp中添加一个加入Circle对象的判断，最后在OnPaint中加入一个循环遍历画出所有的Circle对象。\n\n对于抽象的方法：\n\n- 在shape文件中新添一个Circle类，继承Shape类，实现自己的Draw方法\n- 在MainForm，在OnMouseUp中添加一个加入Circle对象指针的判断(可以用工厂设计模式消除这种变化)。\n\n可以看见，对于一个新的需求的加入，抽象的方法改动的代码远远少于分解的方法，也就是扩展性、复用性的体现。\n\n#### 面向对象设计原则\n\n变化是复用的天敌。面向对象设计最大的优势在于：抵御变化！\n\n设计原则比模式更为重要，先码下来后面结合具体的设计模式再好好理解。\n\n- 依赖倒置原则（DIP）\n  - 高层模块(稳定)不应该依赖于底层模块(变化)，二者都应该依赖于抽象(稳定)\n  - 抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象\n\n对于上面的例子，第一种做法MainForm依赖于Line和Rect，MainForm就相当于高层模块，Line和Rect相当于低层模块。第二种做法MainForm依赖于Shape，Line和Rect也依赖Shape，这里的Shape就是抽象，从而实现隔离变化，这就符合了依赖倒置原则，简而言之，就是稳定的不能依赖不稳定的，要让不稳定的依赖稳定的。\n\n- 开放封闭原则（OCP）\n  - 对扩展开放，对更改封闭\n  - 类模块应该是可扩展的，但是不可修改。\n\n对于上面的例子，加入一个新的需求的时候，第一种做法改变源码的地方很多。在工程中，改变源码意味着需要重新编译，重新测试，重新部署，代价很高。第二种做法所做的变动很小，扩展性更好。\n\n- 单一职责原则（SRP）\n  - 一个类应该仅有一个引起它变化的原因\n  - 变化的方向隐含着类的责任\n\n- Liskov替换原则（LSP）\n  - 子类必须能够替换它们的基类(IS-A)\n  - 继承表达类型抽象\n\n- 接口隔离原则（ISP）\n  - 不应该强迫客户程序依赖它们不用的方法\n  - 接口应该小而完备(不要把不必要的方法public)\n\n- 优先使用对象组合，而不是类继承\n  - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”\n  - 继承在某种程度上破坏了封装性，子类父类耦合度高\n  - 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低\n\n- 封装变化点(封装更高层次的理解)\n  - 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。\n\n- 针对接口编程，而不是针对实现编程\n  - 不将变量类型声明为某个特定的具体类，而是声明为某个接口\n  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口\n  - 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案\n\n在之前的例子中，第一种做法MainForm里面包含Line，Rect的数组，这就是依赖了具体类，不符合针对接口编程。第二种做法就是包含Shape指针的数组，就是接口，然后只使用对象所具有的接口。\n\n#### 总结\n\n设计模式的学习一个漫长的过程，在不同的场景分析其特点准备运用设计模式是一个很困难的事情。在实际情况中，一般可以先满足需求，然后比对设计原则，分析代码的劣势，运用某些设计模式重构代码。\n\n软件设计的特征是“需求的频繁变化”，设计模式的要点就是寻找变化点，然后在变化点运用设计模式。\n\n#### 重构的关键技法\n\n- 静态转动态\n- 早绑定转晚绑定\n- 继承转组合\n- 编译时依赖转运行时依赖\n- 紧耦合转松耦合","source":"_posts/八大设计原则.md","raw":"---\ntitle: 八大设计原则\ndate: 2019-04-24 20:27:23\ntags:\n- 设计模式\n---\n\n最近在看李建忠老师的设计模式的课程，做一下学习笔记,可以参考书籍《设计模式:可复用面向对象软件的基础》,这本书是四个人写的，所以也简称GOF设计模式。\n\n解决复杂问题主要的方式有两种：\n\n- 分解,分而治之。像C语言这种结构化的语言就是如此\n- 抽象。由于不能掌握全部的复杂对象，选择忽视它的非本质细节，而去锤泛化和理想化的对象模型\n\n在设计模式中和重要的一个东西就是抽象。\n\n<!--more-->\n\n#### 结构化VS面向对象\n\n演示的任务：画图形\n\n分解的设计方法,以伪码的方式展示：\n\n```\n//shape.h  封装一些特定的形状\nclass Point{\npublic:\n\tint x;\n\tint y;\n};\n\nclass Line{\npublic:\n\tPoint start;\n\tPoint end;\n\tLine(const Point&start,const Point&end){\n        this->start = start;\n        this->end = end;\n\t}\n};\n\nclass Rect{\npublic:\n\tPoint leftUp;\n\tint width;\n\tint height;\n\tRect(const Point& leftUp,int width,int height){\n        this->leftUp = leftUp;\n        this->width = width;\n        this->height = height;\n\t}\n};\n------------------------------------------------------------\n//MainForm.h  窗口类 负责处理各种事件 \n#include\"shape.h\"\nclass MainForm : public Form{\nprivate:\n\tPoint p1;\n\tPoint p2;    //鼠标画图的起始点和终止点\n\t\n\tvector<Line> linevector;\n\tvector<Rect> rectVector;\npublic:\n\tMainForm(){\n        //...\n\t}\nprotected:\n\tvirtual void OnMouseDown(const MouseEventArgs& e);\n\tvirtual void OnMouseUp(const MouseEventArgs& e);\n\tvirtual void OnPaint(const MouseEventArgs& e);\n};\nvoid MainForm::OnMouseDown(const MouseEventArgs& e){\n    p1.x = e.x;\n    p1.y = e.y;\n    //...\n    Form::OnMouseDown(e);\n}\nvoid MainForm::OnMouseUp(const MouseEventArgs& e){\n    p2.x = e.x;\n    p2.y = e.y;\n    \n    if(rdoLine.Checked){\n        Line line(p1,p2);\n        lineVector.push_back(line);\n    }\n    else if(rdoRect.Checked){\n        int width = abs(p2.x-p1.x);\n        int height = abs(p2.y-p1.y);\n        Rect rect(p1,width,height);\n        rectVector.push_back(rect);\n    }\n    //...\n    this->Refresh();\n    \n    Form::OnMouseUp(e);\n}\nvoid MainForm::OnPaint(const MouseEventArgs& e){\n    //针对直线\n    for(int i = 0;i<lineVector.size();i++){\n        e.Graphics.DrawLine(Pens.Red,\n                            lineVector[i].start.x,\n                            lineVector[i].start.y,\n                            lineVector[i].end.x,\n                            lineVector[i].end.y);\n    }\n    \n    //针对矩形\n    for(int i = 0;i<rectVector.size();i++){\n        e.Graphics.DrawRectangle(Pens.Res,\n                                 rectVector[i],leftUp,\n                                 rectVector[i].width,\n                                 rectVector[i].height);\n    }\n    //...\n    Form::OnPaint(e);\n}\n\n```\n\n抽象的设计方法：\n\n```\n//shape.h  \n//抽象出一个Shape的基类，让具体的形状类继承它\nclass Shape{   //抽象类\npublic:\n\tvirtual void Draw(const Graphics& g) = 0;\n\tvirtual ~Shape(){}\n}\nclass Point{\npublic:\n\tint x;\n\tint y;\n}\nclass Line:public Shape{\npublic:\n\tPoint start;\n\tPoint end;\n\t//Line的构造函数  同上\n\t\n\t//实现自己的Draw,负责画自己\n\tvirtual void Draw(const Graphics& g){\n\t\tg.DrawLine(Pens.Red,start.x,start.y,end.x,end.y);\n\t}\n};\n\nclass Rect{\npublic:\n\tPoint leftUp;\n\tint width;\n\tint height;\n\t//Rect的构造函数  同上\n\t\n\t//实现自己的Draw,负责画自己\n\tvirtual void Draw(const Graphics& g){\n\t\tg.DrawLine(Pens.Red,leftUp，width,height);\n\t}\n};\n-----------------------------------------------------------------\n#include\"shape.h\"\nclass MainForm : public Form{\nprivate:\n\tPoint p1;\n\tPoint p2;    //鼠标画图的起始点和终止点\n\t\n\t//针对所有形状\n\tvector<Shape*> shapeVector;  存储的是指针 因为需要多态性\npublic:\n\tMainForm(){\n        //...\n\t}\nprotected:\n\tvirtual void OnMouseDown(const MouseEventArgs& e);\n\tvirtual void OnMouseUp(const MouseEventArgs& e);\n\tvirtual void OnPaint(const MouseEventArgs& e);\n};\nvoid MainForm::OnMouseDown(const MouseEventArgs& e){\n    p1.x = e.x;\n    p1.y = e.y;\n    //...\n    Form::OnMouseDown(e);\n}\nvoid MainForm::OnMouseUp(const MouseEventArgs& e){\n    p2.x = e.x;\n    p2.y = e.y;\n    \n    if(rdoLine.Checked){\n    \t//需要注意的是 因为容器里放的是指针 因此不能放一个栈对象\n        lineVector.push_back(new Line(p1,p2));\n    }\n    else if(rdoRect.Checked){\n        int width = abs(p2.x-p1.x);\n        int height = abs(p2.y-p1.y);\n        rectVector.push_back(new Rect(p1,width,height));\n    }\n    //...\n    this->Refresh();\n    \n    Form::OnMouseUp(e);\n}\nvoid MainForm::OnPaint(const MouseEventArgs& e){\n\t\n\t//统一处理所有的形状\n\tfor(int i = 0;i<shapeVector.size();i++){\n    \tshapeVector[i]->Draw(e.Graphics); //多态调用，各负其责\t    \n\t}\n\t\n    //...\n    Form::OnPaint(e);\n}\n\n\n```\n\n通过加入一个新的需求来对比一下两种设计方法。\n\n比如要新加一个画图的功能。\n\n对于分解的方法：\n\n- 在shape文件中新添一个Circle类\n- 然后在MainForm里面加入一个vector存储所有的Circle对象，然后在OnMouseUp中添加一个加入Circle对象的判断，最后在OnPaint中加入一个循环遍历画出所有的Circle对象。\n\n对于抽象的方法：\n\n- 在shape文件中新添一个Circle类，继承Shape类，实现自己的Draw方法\n- 在MainForm，在OnMouseUp中添加一个加入Circle对象指针的判断(可以用工厂设计模式消除这种变化)。\n\n可以看见，对于一个新的需求的加入，抽象的方法改动的代码远远少于分解的方法，也就是扩展性、复用性的体现。\n\n#### 面向对象设计原则\n\n变化是复用的天敌。面向对象设计最大的优势在于：抵御变化！\n\n设计原则比模式更为重要，先码下来后面结合具体的设计模式再好好理解。\n\n- 依赖倒置原则（DIP）\n  - 高层模块(稳定)不应该依赖于底层模块(变化)，二者都应该依赖于抽象(稳定)\n  - 抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象\n\n对于上面的例子，第一种做法MainForm依赖于Line和Rect，MainForm就相当于高层模块，Line和Rect相当于低层模块。第二种做法MainForm依赖于Shape，Line和Rect也依赖Shape，这里的Shape就是抽象，从而实现隔离变化，这就符合了依赖倒置原则，简而言之，就是稳定的不能依赖不稳定的，要让不稳定的依赖稳定的。\n\n- 开放封闭原则（OCP）\n  - 对扩展开放，对更改封闭\n  - 类模块应该是可扩展的，但是不可修改。\n\n对于上面的例子，加入一个新的需求的时候，第一种做法改变源码的地方很多。在工程中，改变源码意味着需要重新编译，重新测试，重新部署，代价很高。第二种做法所做的变动很小，扩展性更好。\n\n- 单一职责原则（SRP）\n  - 一个类应该仅有一个引起它变化的原因\n  - 变化的方向隐含着类的责任\n\n- Liskov替换原则（LSP）\n  - 子类必须能够替换它们的基类(IS-A)\n  - 继承表达类型抽象\n\n- 接口隔离原则（ISP）\n  - 不应该强迫客户程序依赖它们不用的方法\n  - 接口应该小而完备(不要把不必要的方法public)\n\n- 优先使用对象组合，而不是类继承\n  - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”\n  - 继承在某种程度上破坏了封装性，子类父类耦合度高\n  - 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低\n\n- 封装变化点(封装更高层次的理解)\n  - 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。\n\n- 针对接口编程，而不是针对实现编程\n  - 不将变量类型声明为某个特定的具体类，而是声明为某个接口\n  - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口\n  - 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案\n\n在之前的例子中，第一种做法MainForm里面包含Line，Rect的数组，这就是依赖了具体类，不符合针对接口编程。第二种做法就是包含Shape指针的数组，就是接口，然后只使用对象所具有的接口。\n\n#### 总结\n\n设计模式的学习一个漫长的过程，在不同的场景分析其特点准备运用设计模式是一个很困难的事情。在实际情况中，一般可以先满足需求，然后比对设计原则，分析代码的劣势，运用某些设计模式重构代码。\n\n软件设计的特征是“需求的频繁变化”，设计模式的要点就是寻找变化点，然后在变化点运用设计模式。\n\n#### 重构的关键技法\n\n- 静态转动态\n- 早绑定转晚绑定\n- 继承转组合\n- 编译时依赖转运行时依赖\n- 紧耦合转松耦合","slug":"八大设计原则","published":1,"updated":"2021-12-06T05:30:36.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7o001e96cadxo0gvk7","content":"<p>最近在看李建忠老师的设计模式的课程，做一下学习笔记,可以参考书籍《设计模式:可复用面向对象软件的基础》,这本书是四个人写的，所以也简称GOF设计模式。</p>\n<p>解决复杂问题主要的方式有两种：</p>\n<ul>\n<li>分解,分而治之。像C语言这种结构化的语言就是如此</li>\n<li>抽象。由于不能掌握全部的复杂对象，选择忽视它的非本质细节，而去锤泛化和理想化的对象模型</li>\n</ul>\n<p>在设计模式中和重要的一个东西就是抽象。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"结构化VS面向对象\"><a href=\"#结构化VS面向对象\" class=\"headerlink\" title=\"结构化VS面向对象\"></a>结构化VS面向对象</h4><p>演示的任务：画图形</p>\n<p>分解的设计方法,以伪码的方式展示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;shape.h  封装一些特定的形状</span><br><span class=\"line\">class Point&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint x;</span><br><span class=\"line\">\tint y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Line&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPoint start;</span><br><span class=\"line\">\tPoint end;</span><br><span class=\"line\">\tLine(const Point&amp;start,const Point&amp;end)&#123;</span><br><span class=\"line\">        this-&gt;start &#x3D; start;</span><br><span class=\"line\">        this-&gt;end &#x3D; end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Rect&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPoint leftUp;</span><br><span class=\"line\">\tint width;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\">\tRect(const Point&amp; leftUp,int width,int height)&#123;</span><br><span class=\"line\">        this-&gt;leftUp &#x3D; leftUp;</span><br><span class=\"line\">        this-&gt;width &#x3D; width;</span><br><span class=\"line\">        this-&gt;height &#x3D; height;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;MainForm.h  窗口类 负责处理各种事件 </span><br><span class=\"line\">#include&quot;shape.h&quot;</span><br><span class=\"line\">class MainForm : public Form&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tPoint p1;</span><br><span class=\"line\">\tPoint p2;    &#x2F;&#x2F;鼠标画图的起始点和终止点</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvector&lt;Line&gt; linevector;</span><br><span class=\"line\">\tvector&lt;Rect&gt; rectVector;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tMainForm()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvirtual void OnMouseDown(const MouseEventArgs&amp; e);</span><br><span class=\"line\">\tvirtual void OnMouseUp(const MouseEventArgs&amp; e);</span><br><span class=\"line\">\tvirtual void OnPaint(const MouseEventArgs&amp; e);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void MainForm::OnMouseDown(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    p1.x &#x3D; e.x;</span><br><span class=\"line\">    p1.y &#x3D; e.y;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    Form::OnMouseDown(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void MainForm::OnMouseUp(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    p2.x &#x3D; e.x;</span><br><span class=\"line\">    p2.y &#x3D; e.y;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(rdoLine.Checked)&#123;</span><br><span class=\"line\">        Line line(p1,p2);</span><br><span class=\"line\">        lineVector.push_back(line);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(rdoRect.Checked)&#123;</span><br><span class=\"line\">        int width &#x3D; abs(p2.x-p1.x);</span><br><span class=\"line\">        int height &#x3D; abs(p2.y-p1.y);</span><br><span class=\"line\">        Rect rect(p1,width,height);</span><br><span class=\"line\">        rectVector.push_back(rect);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    this-&gt;Refresh();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Form::OnMouseUp(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void MainForm::OnPaint(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;针对直线</span><br><span class=\"line\">    for(int i &#x3D; 0;i&lt;lineVector.size();i++)&#123;</span><br><span class=\"line\">        e.Graphics.DrawLine(Pens.Red,</span><br><span class=\"line\">                            lineVector[i].start.x,</span><br><span class=\"line\">                            lineVector[i].start.y,</span><br><span class=\"line\">                            lineVector[i].end.x,</span><br><span class=\"line\">                            lineVector[i].end.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;针对矩形</span><br><span class=\"line\">    for(int i &#x3D; 0;i&lt;rectVector.size();i++)&#123;</span><br><span class=\"line\">        e.Graphics.DrawRectangle(Pens.Res,</span><br><span class=\"line\">                                 rectVector[i],leftUp,</span><br><span class=\"line\">                                 rectVector[i].width,</span><br><span class=\"line\">                                 rectVector[i].height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    Form::OnPaint(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抽象的设计方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;shape.h  </span><br><span class=\"line\">&#x2F;&#x2F;抽象出一个Shape的基类，让具体的形状类继承它</span><br><span class=\"line\">class Shape&#123;   &#x2F;&#x2F;抽象类</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void Draw(const Graphics&amp; g) &#x3D; 0;</span><br><span class=\"line\">\tvirtual ~Shape()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Point&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint x;</span><br><span class=\"line\">\tint y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Line:public Shape&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPoint start;</span><br><span class=\"line\">\tPoint end;</span><br><span class=\"line\">\t&#x2F;&#x2F;Line的构造函数  同上</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;实现自己的Draw,负责画自己</span><br><span class=\"line\">\tvirtual void Draw(const Graphics&amp; g)&#123;</span><br><span class=\"line\">\t\tg.DrawLine(Pens.Red,start.x,start.y,end.x,end.y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Rect&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPoint leftUp;</span><br><span class=\"line\">\tint width;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\">\t&#x2F;&#x2F;Rect的构造函数  同上</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;实现自己的Draw,负责画自己</span><br><span class=\"line\">\tvirtual void Draw(const Graphics&amp; g)&#123;</span><br><span class=\"line\">\t\tg.DrawLine(Pens.Red,leftUp，width,height);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">-----------------------------------------------------------------</span><br><span class=\"line\">#include&quot;shape.h&quot;</span><br><span class=\"line\">class MainForm : public Form&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tPoint p1;</span><br><span class=\"line\">\tPoint p2;    &#x2F;&#x2F;鼠标画图的起始点和终止点</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;针对所有形状</span><br><span class=\"line\">\tvector&lt;Shape*&gt; shapeVector;  存储的是指针 因为需要多态性</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tMainForm()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvirtual void OnMouseDown(const MouseEventArgs&amp; e);</span><br><span class=\"line\">\tvirtual void OnMouseUp(const MouseEventArgs&amp; e);</span><br><span class=\"line\">\tvirtual void OnPaint(const MouseEventArgs&amp; e);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void MainForm::OnMouseDown(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    p1.x &#x3D; e.x;</span><br><span class=\"line\">    p1.y &#x3D; e.y;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    Form::OnMouseDown(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void MainForm::OnMouseUp(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    p2.x &#x3D; e.x;</span><br><span class=\"line\">    p2.y &#x3D; e.y;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(rdoLine.Checked)&#123;</span><br><span class=\"line\">    \t&#x2F;&#x2F;需要注意的是 因为容器里放的是指针 因此不能放一个栈对象</span><br><span class=\"line\">        lineVector.push_back(new Line(p1,p2));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(rdoRect.Checked)&#123;</span><br><span class=\"line\">        int width &#x3D; abs(p2.x-p1.x);</span><br><span class=\"line\">        int height &#x3D; abs(p2.y-p1.y);</span><br><span class=\"line\">        rectVector.push_back(new Rect(p1,width,height));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    this-&gt;Refresh();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Form::OnMouseUp(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void MainForm::OnPaint(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;统一处理所有的形状</span><br><span class=\"line\">\tfor(int i &#x3D; 0;i&lt;shapeVector.size();i++)&#123;</span><br><span class=\"line\">    \tshapeVector[i]-&gt;Draw(e.Graphics); &#x2F;&#x2F;多态调用，各负其责\t    </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    Form::OnPaint(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过加入一个新的需求来对比一下两种设计方法。</p>\n<p>比如要新加一个画图的功能。</p>\n<p>对于分解的方法：</p>\n<ul>\n<li>在shape文件中新添一个Circle类</li>\n<li>然后在MainForm里面加入一个vector存储所有的Circle对象，然后在OnMouseUp中添加一个加入Circle对象的判断，最后在OnPaint中加入一个循环遍历画出所有的Circle对象。</li>\n</ul>\n<p>对于抽象的方法：</p>\n<ul>\n<li>在shape文件中新添一个Circle类，继承Shape类，实现自己的Draw方法</li>\n<li>在MainForm，在OnMouseUp中添加一个加入Circle对象指针的判断(可以用工厂设计模式消除这种变化)。</li>\n</ul>\n<p>可以看见，对于一个新的需求的加入，抽象的方法改动的代码远远少于分解的方法，也就是扩展性、复用性的体现。</p>\n<h4 id=\"面向对象设计原则\"><a href=\"#面向对象设计原则\" class=\"headerlink\" title=\"面向对象设计原则\"></a>面向对象设计原则</h4><p>变化是复用的天敌。面向对象设计最大的优势在于：抵御变化！</p>\n<p>设计原则比模式更为重要，先码下来后面结合具体的设计模式再好好理解。</p>\n<ul>\n<li>依赖倒置原则（DIP）<ul>\n<li>高层模块(稳定)不应该依赖于底层模块(变化)，二者都应该依赖于抽象(稳定)</li>\n<li>抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象</li>\n</ul>\n</li>\n</ul>\n<p>对于上面的例子，第一种做法MainForm依赖于Line和Rect，MainForm就相当于高层模块，Line和Rect相当于低层模块。第二种做法MainForm依赖于Shape，Line和Rect也依赖Shape，这里的Shape就是抽象，从而实现隔离变化，这就符合了依赖倒置原则，简而言之，就是稳定的不能依赖不稳定的，要让不稳定的依赖稳定的。</p>\n<ul>\n<li>开放封闭原则（OCP）<ul>\n<li>对扩展开放，对更改封闭</li>\n<li>类模块应该是可扩展的，但是不可修改。</li>\n</ul>\n</li>\n</ul>\n<p>对于上面的例子，加入一个新的需求的时候，第一种做法改变源码的地方很多。在工程中，改变源码意味着需要重新编译，重新测试，重新部署，代价很高。第二种做法所做的变动很小，扩展性更好。</p>\n<ul>\n<li><p>单一职责原则（SRP）</p>\n<ul>\n<li>一个类应该仅有一个引起它变化的原因</li>\n<li>变化的方向隐含着类的责任</li>\n</ul>\n</li>\n<li><p>Liskov替换原则（LSP）</p>\n<ul>\n<li>子类必须能够替换它们的基类(IS-A)</li>\n<li>继承表达类型抽象</li>\n</ul>\n</li>\n<li><p>接口隔离原则（ISP）</p>\n<ul>\n<li>不应该强迫客户程序依赖它们不用的方法</li>\n<li>接口应该小而完备(不要把不必要的方法public)</li>\n</ul>\n</li>\n<li><p>优先使用对象组合，而不是类继承</p>\n<ul>\n<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li>\n<li>继承在某种程度上破坏了封装性，子类父类耦合度高</li>\n<li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低</li>\n</ul>\n</li>\n<li><p>封装变化点(封装更高层次的理解)</p>\n<ul>\n<li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li>\n</ul>\n</li>\n<li><p>针对接口编程，而不是针对实现编程</p>\n<ul>\n<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li>\n<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口</li>\n<li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案</li>\n</ul>\n</li>\n</ul>\n<p>在之前的例子中，第一种做法MainForm里面包含Line，Rect的数组，这就是依赖了具体类，不符合针对接口编程。第二种做法就是包含Shape指针的数组，就是接口，然后只使用对象所具有的接口。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>设计模式的学习一个漫长的过程，在不同的场景分析其特点准备运用设计模式是一个很困难的事情。在实际情况中，一般可以先满足需求，然后比对设计原则，分析代码的劣势，运用某些设计模式重构代码。</p>\n<p>软件设计的特征是“需求的频繁变化”，设计模式的要点就是寻找变化点，然后在变化点运用设计模式。</p>\n<h4 id=\"重构的关键技法\"><a href=\"#重构的关键技法\" class=\"headerlink\" title=\"重构的关键技法\"></a>重构的关键技法</h4><ul>\n<li>静态转动态</li>\n<li>早绑定转晚绑定</li>\n<li>继承转组合</li>\n<li>编译时依赖转运行时依赖</li>\n<li>紧耦合转松耦合</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近在看李建忠老师的设计模式的课程，做一下学习笔记,可以参考书籍《设计模式:可复用面向对象软件的基础》,这本书是四个人写的，所以也简称GOF设计模式。</p>\n<p>解决复杂问题主要的方式有两种：</p>\n<ul>\n<li>分解,分而治之。像C语言这种结构化的语言就是如此</li>\n<li>抽象。由于不能掌握全部的复杂对象，选择忽视它的非本质细节，而去锤泛化和理想化的对象模型</li>\n</ul>\n<p>在设计模式中和重要的一个东西就是抽象。</p>","more":"<h4 id=\"结构化VS面向对象\"><a href=\"#结构化VS面向对象\" class=\"headerlink\" title=\"结构化VS面向对象\"></a>结构化VS面向对象</h4><p>演示的任务：画图形</p>\n<p>分解的设计方法,以伪码的方式展示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;shape.h  封装一些特定的形状</span><br><span class=\"line\">class Point&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint x;</span><br><span class=\"line\">\tint y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Line&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPoint start;</span><br><span class=\"line\">\tPoint end;</span><br><span class=\"line\">\tLine(const Point&amp;start,const Point&amp;end)&#123;</span><br><span class=\"line\">        this-&gt;start &#x3D; start;</span><br><span class=\"line\">        this-&gt;end &#x3D; end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Rect&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPoint leftUp;</span><br><span class=\"line\">\tint width;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\">\tRect(const Point&amp; leftUp,int width,int height)&#123;</span><br><span class=\"line\">        this-&gt;leftUp &#x3D; leftUp;</span><br><span class=\"line\">        this-&gt;width &#x3D; width;</span><br><span class=\"line\">        this-&gt;height &#x3D; height;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;MainForm.h  窗口类 负责处理各种事件 </span><br><span class=\"line\">#include&quot;shape.h&quot;</span><br><span class=\"line\">class MainForm : public Form&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tPoint p1;</span><br><span class=\"line\">\tPoint p2;    &#x2F;&#x2F;鼠标画图的起始点和终止点</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvector&lt;Line&gt; linevector;</span><br><span class=\"line\">\tvector&lt;Rect&gt; rectVector;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tMainForm()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvirtual void OnMouseDown(const MouseEventArgs&amp; e);</span><br><span class=\"line\">\tvirtual void OnMouseUp(const MouseEventArgs&amp; e);</span><br><span class=\"line\">\tvirtual void OnPaint(const MouseEventArgs&amp; e);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void MainForm::OnMouseDown(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    p1.x &#x3D; e.x;</span><br><span class=\"line\">    p1.y &#x3D; e.y;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    Form::OnMouseDown(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void MainForm::OnMouseUp(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    p2.x &#x3D; e.x;</span><br><span class=\"line\">    p2.y &#x3D; e.y;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(rdoLine.Checked)&#123;</span><br><span class=\"line\">        Line line(p1,p2);</span><br><span class=\"line\">        lineVector.push_back(line);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(rdoRect.Checked)&#123;</span><br><span class=\"line\">        int width &#x3D; abs(p2.x-p1.x);</span><br><span class=\"line\">        int height &#x3D; abs(p2.y-p1.y);</span><br><span class=\"line\">        Rect rect(p1,width,height);</span><br><span class=\"line\">        rectVector.push_back(rect);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    this-&gt;Refresh();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Form::OnMouseUp(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void MainForm::OnPaint(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;针对直线</span><br><span class=\"line\">    for(int i &#x3D; 0;i&lt;lineVector.size();i++)&#123;</span><br><span class=\"line\">        e.Graphics.DrawLine(Pens.Red,</span><br><span class=\"line\">                            lineVector[i].start.x,</span><br><span class=\"line\">                            lineVector[i].start.y,</span><br><span class=\"line\">                            lineVector[i].end.x,</span><br><span class=\"line\">                            lineVector[i].end.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;针对矩形</span><br><span class=\"line\">    for(int i &#x3D; 0;i&lt;rectVector.size();i++)&#123;</span><br><span class=\"line\">        e.Graphics.DrawRectangle(Pens.Res,</span><br><span class=\"line\">                                 rectVector[i],leftUp,</span><br><span class=\"line\">                                 rectVector[i].width,</span><br><span class=\"line\">                                 rectVector[i].height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    Form::OnPaint(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抽象的设计方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;shape.h  </span><br><span class=\"line\">&#x2F;&#x2F;抽象出一个Shape的基类，让具体的形状类继承它</span><br><span class=\"line\">class Shape&#123;   &#x2F;&#x2F;抽象类</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void Draw(const Graphics&amp; g) &#x3D; 0;</span><br><span class=\"line\">\tvirtual ~Shape()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Point&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint x;</span><br><span class=\"line\">\tint y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Line:public Shape&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPoint start;</span><br><span class=\"line\">\tPoint end;</span><br><span class=\"line\">\t&#x2F;&#x2F;Line的构造函数  同上</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;实现自己的Draw,负责画自己</span><br><span class=\"line\">\tvirtual void Draw(const Graphics&amp; g)&#123;</span><br><span class=\"line\">\t\tg.DrawLine(Pens.Red,start.x,start.y,end.x,end.y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Rect&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPoint leftUp;</span><br><span class=\"line\">\tint width;</span><br><span class=\"line\">\tint height;</span><br><span class=\"line\">\t&#x2F;&#x2F;Rect的构造函数  同上</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;实现自己的Draw,负责画自己</span><br><span class=\"line\">\tvirtual void Draw(const Graphics&amp; g)&#123;</span><br><span class=\"line\">\t\tg.DrawLine(Pens.Red,leftUp，width,height);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">-----------------------------------------------------------------</span><br><span class=\"line\">#include&quot;shape.h&quot;</span><br><span class=\"line\">class MainForm : public Form&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tPoint p1;</span><br><span class=\"line\">\tPoint p2;    &#x2F;&#x2F;鼠标画图的起始点和终止点</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;针对所有形状</span><br><span class=\"line\">\tvector&lt;Shape*&gt; shapeVector;  存储的是指针 因为需要多态性</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tMainForm()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvirtual void OnMouseDown(const MouseEventArgs&amp; e);</span><br><span class=\"line\">\tvirtual void OnMouseUp(const MouseEventArgs&amp; e);</span><br><span class=\"line\">\tvirtual void OnPaint(const MouseEventArgs&amp; e);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void MainForm::OnMouseDown(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    p1.x &#x3D; e.x;</span><br><span class=\"line\">    p1.y &#x3D; e.y;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    Form::OnMouseDown(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void MainForm::OnMouseUp(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">    p2.x &#x3D; e.x;</span><br><span class=\"line\">    p2.y &#x3D; e.y;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(rdoLine.Checked)&#123;</span><br><span class=\"line\">    \t&#x2F;&#x2F;需要注意的是 因为容器里放的是指针 因此不能放一个栈对象</span><br><span class=\"line\">        lineVector.push_back(new Line(p1,p2));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(rdoRect.Checked)&#123;</span><br><span class=\"line\">        int width &#x3D; abs(p2.x-p1.x);</span><br><span class=\"line\">        int height &#x3D; abs(p2.y-p1.y);</span><br><span class=\"line\">        rectVector.push_back(new Rect(p1,width,height));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    this-&gt;Refresh();</span><br><span class=\"line\">    </span><br><span class=\"line\">    Form::OnMouseUp(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void MainForm::OnPaint(const MouseEventArgs&amp; e)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;统一处理所有的形状</span><br><span class=\"line\">\tfor(int i &#x3D; 0;i&lt;shapeVector.size();i++)&#123;</span><br><span class=\"line\">    \tshapeVector[i]-&gt;Draw(e.Graphics); &#x2F;&#x2F;多态调用，各负其责\t    </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    &#x2F;&#x2F;...</span><br><span class=\"line\">    Form::OnPaint(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过加入一个新的需求来对比一下两种设计方法。</p>\n<p>比如要新加一个画图的功能。</p>\n<p>对于分解的方法：</p>\n<ul>\n<li>在shape文件中新添一个Circle类</li>\n<li>然后在MainForm里面加入一个vector存储所有的Circle对象，然后在OnMouseUp中添加一个加入Circle对象的判断，最后在OnPaint中加入一个循环遍历画出所有的Circle对象。</li>\n</ul>\n<p>对于抽象的方法：</p>\n<ul>\n<li>在shape文件中新添一个Circle类，继承Shape类，实现自己的Draw方法</li>\n<li>在MainForm，在OnMouseUp中添加一个加入Circle对象指针的判断(可以用工厂设计模式消除这种变化)。</li>\n</ul>\n<p>可以看见，对于一个新的需求的加入，抽象的方法改动的代码远远少于分解的方法，也就是扩展性、复用性的体现。</p>\n<h4 id=\"面向对象设计原则\"><a href=\"#面向对象设计原则\" class=\"headerlink\" title=\"面向对象设计原则\"></a>面向对象设计原则</h4><p>变化是复用的天敌。面向对象设计最大的优势在于：抵御变化！</p>\n<p>设计原则比模式更为重要，先码下来后面结合具体的设计模式再好好理解。</p>\n<ul>\n<li>依赖倒置原则（DIP）<ul>\n<li>高层模块(稳定)不应该依赖于底层模块(变化)，二者都应该依赖于抽象(稳定)</li>\n<li>抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象</li>\n</ul>\n</li>\n</ul>\n<p>对于上面的例子，第一种做法MainForm依赖于Line和Rect，MainForm就相当于高层模块，Line和Rect相当于低层模块。第二种做法MainForm依赖于Shape，Line和Rect也依赖Shape，这里的Shape就是抽象，从而实现隔离变化，这就符合了依赖倒置原则，简而言之，就是稳定的不能依赖不稳定的，要让不稳定的依赖稳定的。</p>\n<ul>\n<li>开放封闭原则（OCP）<ul>\n<li>对扩展开放，对更改封闭</li>\n<li>类模块应该是可扩展的，但是不可修改。</li>\n</ul>\n</li>\n</ul>\n<p>对于上面的例子，加入一个新的需求的时候，第一种做法改变源码的地方很多。在工程中，改变源码意味着需要重新编译，重新测试，重新部署，代价很高。第二种做法所做的变动很小，扩展性更好。</p>\n<ul>\n<li><p>单一职责原则（SRP）</p>\n<ul>\n<li>一个类应该仅有一个引起它变化的原因</li>\n<li>变化的方向隐含着类的责任</li>\n</ul>\n</li>\n<li><p>Liskov替换原则（LSP）</p>\n<ul>\n<li>子类必须能够替换它们的基类(IS-A)</li>\n<li>继承表达类型抽象</li>\n</ul>\n</li>\n<li><p>接口隔离原则（ISP）</p>\n<ul>\n<li>不应该强迫客户程序依赖它们不用的方法</li>\n<li>接口应该小而完备(不要把不必要的方法public)</li>\n</ul>\n</li>\n<li><p>优先使用对象组合，而不是类继承</p>\n<ul>\n<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li>\n<li>继承在某种程度上破坏了封装性，子类父类耦合度高</li>\n<li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低</li>\n</ul>\n</li>\n<li><p>封装变化点(封装更高层次的理解)</p>\n<ul>\n<li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li>\n</ul>\n</li>\n<li><p>针对接口编程，而不是针对实现编程</p>\n<ul>\n<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口</li>\n<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口</li>\n<li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案</li>\n</ul>\n</li>\n</ul>\n<p>在之前的例子中，第一种做法MainForm里面包含Line，Rect的数组，这就是依赖了具体类，不符合针对接口编程。第二种做法就是包含Shape指针的数组，就是接口，然后只使用对象所具有的接口。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>设计模式的学习一个漫长的过程，在不同的场景分析其特点准备运用设计模式是一个很困难的事情。在实际情况中，一般可以先满足需求，然后比对设计原则，分析代码的劣势，运用某些设计模式重构代码。</p>\n<p>软件设计的特征是“需求的频繁变化”，设计模式的要点就是寻找变化点，然后在变化点运用设计模式。</p>\n<h4 id=\"重构的关键技法\"><a href=\"#重构的关键技法\" class=\"headerlink\" title=\"重构的关键技法\"></a>重构的关键技法</h4><ul>\n<li>静态转动态</li>\n<li>早绑定转晚绑定</li>\n<li>继承转组合</li>\n<li>编译时依赖转运行时依赖</li>\n<li>紧耦合转松耦合</li>\n</ul>"},{"title":"tcpdump","date":"2019-03-06T13:18:10.000Z","_content":"\n码上一些tcpdump的选项，方便自己查看。\n\n-n　使用IP地址表示主机，而不是主机名；使用数字表示端口号，而不是服务名称\n\n-i　  指定要监听的网卡接口。\"-i any\"表示抓取所有网卡接口上的数据包\n\n-v　 输出一个稍微详细的信息，例如，显示IP数据包中的TTL和TOS信息\n\n-t　  不打印时间戳\n\n-e　  显示以太网帧头部信息\n\n-c　   仅抓取指定数量的数据包\n\n-x　   以十六进制数显示数据包的内容，但不显示包中以太网帧的头部信息\n\n-X　   与-x类似，不过还打印每个十六进制字节对应的ASCII字符\n\n-XX　 与-X相同，不过还打印以太网帧的头部信息\n\n-s 　   设置抓包时的抓取长度。4.0版本之前默认68字节，4.0之后的版本默认65535\n\n-S　　以绝对值来显示TCP报文段的序号,而不是相对值\n\n-w　   将tcpdump的输出以特殊的格式定向到某个文件\n\n-r　    从文件读取数据包信息并显示之\n\n除了使用选项之外，tcpdump还支持用表达式来进一步过滤数据包。\n\n表达式操作数分为3种：类型、方向、协议\n\n- 类型，解释其后面紧跟着的参数的含义。支持的类型有host、net、port和portrange\n\n  比如要抓取整个1.2.3.0/255.255.255.0网络上的数据包，可以用\n\n  tcpdump net 1.2.3.0/24\n\n- 方向，src指定数据包的发送端，dst指定数据包的目的端\n\n  比如要抓取进入端口1234的数据包\n\n  tcpdump dst port 1234\n\n- 协议，指定目标协议，比如要抓取所有ICMP数据包\n\n  tcpdump icmp\n\n可以用逻辑操作符组织上面的操作数  \n\n支持  and(&&) 、or(||)、not(!)\n\n例如抓取来自主机1.2.3.4，目标端口是1234或者2048的数据包\n\ntcpdump 'src 1.2.3.4 and (dst port 1234 or 2048)'\n\n**需要注意的是：在使用括号进行分组的时候，需要用单引号将其括住或者用'\\'进行转义，避免被shell所解释**\n\n\n\n直接使用数据包中的部分协议字段的内容来过滤数据包\n\n例如，只抓取TCP同步报文段\n\ntcpdump 'tcp[13] & 2 != 0' 　　　　＃TCP头部的第14个字节的第二个位正是SYN\n\ntcpdump 'tcp[tcpflags] & tcp-syn != 0' ","source":"_posts/tcpdump.md","raw":"---\ntitle: tcpdump\ndate: 2019-03-06 21:18:10\ntags:\n- 网络\n- 常用工具\n-  Linux高性能服务器编程\n---\n\n码上一些tcpdump的选项，方便自己查看。\n\n-n　使用IP地址表示主机，而不是主机名；使用数字表示端口号，而不是服务名称\n\n-i　  指定要监听的网卡接口。\"-i any\"表示抓取所有网卡接口上的数据包\n\n-v　 输出一个稍微详细的信息，例如，显示IP数据包中的TTL和TOS信息\n\n-t　  不打印时间戳\n\n-e　  显示以太网帧头部信息\n\n-c　   仅抓取指定数量的数据包\n\n-x　   以十六进制数显示数据包的内容，但不显示包中以太网帧的头部信息\n\n-X　   与-x类似，不过还打印每个十六进制字节对应的ASCII字符\n\n-XX　 与-X相同，不过还打印以太网帧的头部信息\n\n-s 　   设置抓包时的抓取长度。4.0版本之前默认68字节，4.0之后的版本默认65535\n\n-S　　以绝对值来显示TCP报文段的序号,而不是相对值\n\n-w　   将tcpdump的输出以特殊的格式定向到某个文件\n\n-r　    从文件读取数据包信息并显示之\n\n除了使用选项之外，tcpdump还支持用表达式来进一步过滤数据包。\n\n表达式操作数分为3种：类型、方向、协议\n\n- 类型，解释其后面紧跟着的参数的含义。支持的类型有host、net、port和portrange\n\n  比如要抓取整个1.2.3.0/255.255.255.0网络上的数据包，可以用\n\n  tcpdump net 1.2.3.0/24\n\n- 方向，src指定数据包的发送端，dst指定数据包的目的端\n\n  比如要抓取进入端口1234的数据包\n\n  tcpdump dst port 1234\n\n- 协议，指定目标协议，比如要抓取所有ICMP数据包\n\n  tcpdump icmp\n\n可以用逻辑操作符组织上面的操作数  \n\n支持  and(&&) 、or(||)、not(!)\n\n例如抓取来自主机1.2.3.4，目标端口是1234或者2048的数据包\n\ntcpdump 'src 1.2.3.4 and (dst port 1234 or 2048)'\n\n**需要注意的是：在使用括号进行分组的时候，需要用单引号将其括住或者用'\\'进行转义，避免被shell所解释**\n\n\n\n直接使用数据包中的部分协议字段的内容来过滤数据包\n\n例如，只抓取TCP同步报文段\n\ntcpdump 'tcp[13] & 2 != 0' 　　　　＃TCP头部的第14个字节的第二个位正是SYN\n\ntcpdump 'tcp[tcpflags] & tcp-syn != 0' ","slug":"tcpdump","published":1,"updated":"2021-12-06T05:30:36.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7p001h96ca02u70zdn","content":"<p>码上一些tcpdump的选项，方便自己查看。</p>\n<p>-n　使用IP地址表示主机，而不是主机名；使用数字表示端口号，而不是服务名称</p>\n<p>-i　  指定要监听的网卡接口。”-i any”表示抓取所有网卡接口上的数据包</p>\n<p>-v　 输出一个稍微详细的信息，例如，显示IP数据包中的TTL和TOS信息</p>\n<p>-t　  不打印时间戳</p>\n<p>-e　  显示以太网帧头部信息</p>\n<p>-c　   仅抓取指定数量的数据包</p>\n<p>-x　   以十六进制数显示数据包的内容，但不显示包中以太网帧的头部信息</p>\n<p>-X　   与-x类似，不过还打印每个十六进制字节对应的ASCII字符</p>\n<p>-XX　 与-X相同，不过还打印以太网帧的头部信息</p>\n<p>-s 　   设置抓包时的抓取长度。4.0版本之前默认68字节，4.0之后的版本默认65535</p>\n<p>-S　　以绝对值来显示TCP报文段的序号,而不是相对值</p>\n<p>-w　   将tcpdump的输出以特殊的格式定向到某个文件</p>\n<p>-r　    从文件读取数据包信息并显示之</p>\n<p>除了使用选项之外，tcpdump还支持用表达式来进一步过滤数据包。</p>\n<p>表达式操作数分为3种：类型、方向、协议</p>\n<ul>\n<li><p>类型，解释其后面紧跟着的参数的含义。支持的类型有host、net、port和portrange</p>\n<p>比如要抓取整个1.2.3.0/255.255.255.0网络上的数据包，可以用</p>\n<p>tcpdump net 1.2.3.0/24</p>\n</li>\n<li><p>方向，src指定数据包的发送端，dst指定数据包的目的端</p>\n<p>比如要抓取进入端口1234的数据包</p>\n<p>tcpdump dst port 1234</p>\n</li>\n<li><p>协议，指定目标协议，比如要抓取所有ICMP数据包</p>\n<p>tcpdump icmp</p>\n</li>\n</ul>\n<p>可以用逻辑操作符组织上面的操作数  </p>\n<p>支持  and(&amp;&amp;) 、or(||)、not(!)</p>\n<p>例如抓取来自主机1.2.3.4，目标端口是1234或者2048的数据包</p>\n<p>tcpdump ‘src 1.2.3.4 and (dst port 1234 or 2048)’</p>\n<p><strong>需要注意的是：在使用括号进行分组的时候，需要用单引号将其括住或者用’&#39;进行转义，避免被shell所解释</strong></p>\n<p>直接使用数据包中的部分协议字段的内容来过滤数据包</p>\n<p>例如，只抓取TCP同步报文段</p>\n<p>tcpdump ‘tcp[13] &amp; 2 != 0’ 　　　　＃TCP头部的第14个字节的第二个位正是SYN</p>\n<p>tcpdump ‘tcp[tcpflags] &amp; tcp-syn != 0’ </p>\n","site":{"data":{}},"excerpt":"","more":"<p>码上一些tcpdump的选项，方便自己查看。</p>\n<p>-n　使用IP地址表示主机，而不是主机名；使用数字表示端口号，而不是服务名称</p>\n<p>-i　  指定要监听的网卡接口。”-i any”表示抓取所有网卡接口上的数据包</p>\n<p>-v　 输出一个稍微详细的信息，例如，显示IP数据包中的TTL和TOS信息</p>\n<p>-t　  不打印时间戳</p>\n<p>-e　  显示以太网帧头部信息</p>\n<p>-c　   仅抓取指定数量的数据包</p>\n<p>-x　   以十六进制数显示数据包的内容，但不显示包中以太网帧的头部信息</p>\n<p>-X　   与-x类似，不过还打印每个十六进制字节对应的ASCII字符</p>\n<p>-XX　 与-X相同，不过还打印以太网帧的头部信息</p>\n<p>-s 　   设置抓包时的抓取长度。4.0版本之前默认68字节，4.0之后的版本默认65535</p>\n<p>-S　　以绝对值来显示TCP报文段的序号,而不是相对值</p>\n<p>-w　   将tcpdump的输出以特殊的格式定向到某个文件</p>\n<p>-r　    从文件读取数据包信息并显示之</p>\n<p>除了使用选项之外，tcpdump还支持用表达式来进一步过滤数据包。</p>\n<p>表达式操作数分为3种：类型、方向、协议</p>\n<ul>\n<li><p>类型，解释其后面紧跟着的参数的含义。支持的类型有host、net、port和portrange</p>\n<p>比如要抓取整个1.2.3.0/255.255.255.0网络上的数据包，可以用</p>\n<p>tcpdump net 1.2.3.0/24</p>\n</li>\n<li><p>方向，src指定数据包的发送端，dst指定数据包的目的端</p>\n<p>比如要抓取进入端口1234的数据包</p>\n<p>tcpdump dst port 1234</p>\n</li>\n<li><p>协议，指定目标协议，比如要抓取所有ICMP数据包</p>\n<p>tcpdump icmp</p>\n</li>\n</ul>\n<p>可以用逻辑操作符组织上面的操作数  </p>\n<p>支持  and(&amp;&amp;) 、or(||)、not(!)</p>\n<p>例如抓取来自主机1.2.3.4，目标端口是1234或者2048的数据包</p>\n<p>tcpdump ‘src 1.2.3.4 and (dst port 1234 or 2048)’</p>\n<p><strong>需要注意的是：在使用括号进行分组的时候，需要用单引号将其括住或者用’&#39;进行转义，避免被shell所解释</strong></p>\n<p>直接使用数据包中的部分协议字段的内容来过滤数据包</p>\n<p>例如，只抓取TCP同步报文段</p>\n<p>tcpdump ‘tcp[13] &amp; 2 != 0’ 　　　　＃TCP头部的第14个字节的第二个位正是SYN</p>\n<p>tcpdump ‘tcp[tcpflags] &amp; tcp-syn != 0’ </p>\n"},{"title":"优秀博客整理","date":"2019-03-23T11:38:38.000Z","_content":"\n整理一些优秀的博文，方便以后复习\n\n## C++\n\n[多种继承方式的对象模型](https://www.cnblogs.com/raichen/p/5744300.html)\n\n\n\n## C++11\n\n[explicit](https://www.cnblogs.com/diligenceday/p/5781408.html)\n\n\n\n## 网络\n\n[backlog参数理解](https://www.jianshu.com/p/7fde92785056)\n\n[半连接队列和全连接队列](https://www.cnblogs.com/Orgliny/p/5780796.html)\n\n## 算法\n\n[位操作](https://blog.csdn.net/morewindows/article/details/7354571)\n\n## 软件安装\n\n[ubuntu16.04安装mysql](http://www.cnblogs.com/Kobe10/p/6494621.html)\n\n[linux解决解决/usr/bin/ld: cannot find -lxxx](https://www.jianshu.com/p/ccaf688f54c0)\n\n[Windows下vs2012安装boost库](https://blog.csdn.net/dumuweiyang/article/details/80826250)\n\n小插曲:一开始安装的是boost_1_70_0，日志提示应该是工具集不匹配的问题，又乖乖按照博客中的boost_1_67_0进行安装。\n\n能够成功安装，但是无法使用，又配合下面的博客成功完成boost的使用。\n\n[boost库安装的问题解决](https://blog.csdn.net/qq_36038987/article/details/80842205)\n\n[Windows下vs2012安装OpenCV2.4.13](https://blog.csdn.net/dcrmg/article/details/51809614)\n\n虽然安装的OpenCV版本比较旧，但是这也是一次初体验\n\n遇到的问题：\n\n- 一开始编译能通过但是找不到库，重启了一下机器就ok了，因为系统环境变量需要重启才能生效\n- imread读取图片失败\n  - 注意链接库版本：debug的库为xxxd.dll，release的库为xxx.dll\n  - 更坑爹的是，都正确了还是不行，编译能过，但是一直有warning:由通用字符名称“\\u202A”表示的字符不能在当前代码页(936)中表示出来，就一直没在意，但是一直运行不出来。查了一下才发现是路径复制过来的问题。\n- imshow图片显示不出来：imshow之后要调用waitKey或者cvWaitKey\n\n[ubuntu16.04安装OpenCV](https://docs.opencv.org/master/d7/d9f/tutorial_linux_install.html)\n\n- 不行的话就加个sudo提权\n- pkg-config --modversion opencv 版本查看\n- [测试用例](https://docs.opencv.org/master/db/df5/tutorial_linux_gcc_cmake.html)\n\n[ubuntu16.04 vscode 配置C++环境](https://www.cnblogs.com/lidabo/p/5888997.html)\n\n\n\nhttps://blog.csdn.net/fengbingchun/article/details/60780232\n\nhttps://blog.csdn.net/tt_ren/article/details/53227900\n\nhttps://blog.csdn.net/feierban/article/details/80283727","source":"_posts/优秀博客整理.md","raw":"---\ntitle: 优秀博客整理\ndate: 2019-03-23 19:38:38\ntags:\n- 随笔\n---\n\n整理一些优秀的博文，方便以后复习\n\n## C++\n\n[多种继承方式的对象模型](https://www.cnblogs.com/raichen/p/5744300.html)\n\n\n\n## C++11\n\n[explicit](https://www.cnblogs.com/diligenceday/p/5781408.html)\n\n\n\n## 网络\n\n[backlog参数理解](https://www.jianshu.com/p/7fde92785056)\n\n[半连接队列和全连接队列](https://www.cnblogs.com/Orgliny/p/5780796.html)\n\n## 算法\n\n[位操作](https://blog.csdn.net/morewindows/article/details/7354571)\n\n## 软件安装\n\n[ubuntu16.04安装mysql](http://www.cnblogs.com/Kobe10/p/6494621.html)\n\n[linux解决解决/usr/bin/ld: cannot find -lxxx](https://www.jianshu.com/p/ccaf688f54c0)\n\n[Windows下vs2012安装boost库](https://blog.csdn.net/dumuweiyang/article/details/80826250)\n\n小插曲:一开始安装的是boost_1_70_0，日志提示应该是工具集不匹配的问题，又乖乖按照博客中的boost_1_67_0进行安装。\n\n能够成功安装，但是无法使用，又配合下面的博客成功完成boost的使用。\n\n[boost库安装的问题解决](https://blog.csdn.net/qq_36038987/article/details/80842205)\n\n[Windows下vs2012安装OpenCV2.4.13](https://blog.csdn.net/dcrmg/article/details/51809614)\n\n虽然安装的OpenCV版本比较旧，但是这也是一次初体验\n\n遇到的问题：\n\n- 一开始编译能通过但是找不到库，重启了一下机器就ok了，因为系统环境变量需要重启才能生效\n- imread读取图片失败\n  - 注意链接库版本：debug的库为xxxd.dll，release的库为xxx.dll\n  - 更坑爹的是，都正确了还是不行，编译能过，但是一直有warning:由通用字符名称“\\u202A”表示的字符不能在当前代码页(936)中表示出来，就一直没在意，但是一直运行不出来。查了一下才发现是路径复制过来的问题。\n- imshow图片显示不出来：imshow之后要调用waitKey或者cvWaitKey\n\n[ubuntu16.04安装OpenCV](https://docs.opencv.org/master/d7/d9f/tutorial_linux_install.html)\n\n- 不行的话就加个sudo提权\n- pkg-config --modversion opencv 版本查看\n- [测试用例](https://docs.opencv.org/master/db/df5/tutorial_linux_gcc_cmake.html)\n\n[ubuntu16.04 vscode 配置C++环境](https://www.cnblogs.com/lidabo/p/5888997.html)\n\n\n\nhttps://blog.csdn.net/fengbingchun/article/details/60780232\n\nhttps://blog.csdn.net/tt_ren/article/details/53227900\n\nhttps://blog.csdn.net/feierban/article/details/80283727","slug":"优秀博客整理","published":1,"updated":"2021-12-06T05:30:36.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7p001j96ca7m6v2d1v","content":"<p>整理一些优秀的博文，方便以后复习</p>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><p><a href=\"https://www.cnblogs.com/raichen/p/5744300.html\" target=\"_blank\" rel=\"noopener\">多种继承方式的对象模型</a></p>\n<h2 id=\"C-11\"><a href=\"#C-11\" class=\"headerlink\" title=\"C++11\"></a>C++11</h2><p><a href=\"https://www.cnblogs.com/diligenceday/p/5781408.html\" target=\"_blank\" rel=\"noopener\">explicit</a></p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p><a href=\"https://www.jianshu.com/p/7fde92785056\" target=\"_blank\" rel=\"noopener\">backlog参数理解</a></p>\n<p><a href=\"https://www.cnblogs.com/Orgliny/p/5780796.html\" target=\"_blank\" rel=\"noopener\">半连接队列和全连接队列</a></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p><a href=\"https://blog.csdn.net/morewindows/article/details/7354571\" target=\"_blank\" rel=\"noopener\">位操作</a></p>\n<h2 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h2><p><a href=\"http://www.cnblogs.com/Kobe10/p/6494621.html\" target=\"_blank\" rel=\"noopener\">ubuntu16.04安装mysql</a></p>\n<p><a href=\"https://www.jianshu.com/p/ccaf688f54c0\" target=\"_blank\" rel=\"noopener\">linux解决解决/usr/bin/ld: cannot find -lxxx</a></p>\n<p><a href=\"https://blog.csdn.net/dumuweiyang/article/details/80826250\" target=\"_blank\" rel=\"noopener\">Windows下vs2012安装boost库</a></p>\n<p>小插曲:一开始安装的是boost_1_70_0，日志提示应该是工具集不匹配的问题，又乖乖按照博客中的boost_1_67_0进行安装。</p>\n<p>能够成功安装，但是无法使用，又配合下面的博客成功完成boost的使用。</p>\n<p><a href=\"https://blog.csdn.net/qq_36038987/article/details/80842205\" target=\"_blank\" rel=\"noopener\">boost库安装的问题解决</a></p>\n<p><a href=\"https://blog.csdn.net/dcrmg/article/details/51809614\" target=\"_blank\" rel=\"noopener\">Windows下vs2012安装OpenCV2.4.13</a></p>\n<p>虽然安装的OpenCV版本比较旧，但是这也是一次初体验</p>\n<p>遇到的问题：</p>\n<ul>\n<li>一开始编译能通过但是找不到库，重启了一下机器就ok了，因为系统环境变量需要重启才能生效</li>\n<li>imread读取图片失败<ul>\n<li>注意链接库版本：debug的库为xxxd.dll，release的库为xxx.dll</li>\n<li>更坑爹的是，都正确了还是不行，编译能过，但是一直有warning:由通用字符名称“\\u202A”表示的字符不能在当前代码页(936)中表示出来，就一直没在意，但是一直运行不出来。查了一下才发现是路径复制过来的问题。</li>\n</ul>\n</li>\n<li>imshow图片显示不出来：imshow之后要调用waitKey或者cvWaitKey</li>\n</ul>\n<p><a href=\"https://docs.opencv.org/master/d7/d9f/tutorial_linux_install.html\" target=\"_blank\" rel=\"noopener\">ubuntu16.04安装OpenCV</a></p>\n<ul>\n<li>不行的话就加个sudo提权</li>\n<li>pkg-config –modversion opencv 版本查看</li>\n<li><a href=\"https://docs.opencv.org/master/db/df5/tutorial_linux_gcc_cmake.html\" target=\"_blank\" rel=\"noopener\">测试用例</a></li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/lidabo/p/5888997.html\" target=\"_blank\" rel=\"noopener\">ubuntu16.04 vscode 配置C++环境</a></p>\n<p><a href=\"https://blog.csdn.net/fengbingchun/article/details/60780232\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fengbingchun/article/details/60780232</a></p>\n<p><a href=\"https://blog.csdn.net/tt_ren/article/details/53227900\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tt_ren/article/details/53227900</a></p>\n<p><a href=\"https://blog.csdn.net/feierban/article/details/80283727\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/feierban/article/details/80283727</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>整理一些优秀的博文，方便以后复习</p>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><p><a href=\"https://www.cnblogs.com/raichen/p/5744300.html\" target=\"_blank\" rel=\"noopener\">多种继承方式的对象模型</a></p>\n<h2 id=\"C-11\"><a href=\"#C-11\" class=\"headerlink\" title=\"C++11\"></a>C++11</h2><p><a href=\"https://www.cnblogs.com/diligenceday/p/5781408.html\" target=\"_blank\" rel=\"noopener\">explicit</a></p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p><a href=\"https://www.jianshu.com/p/7fde92785056\" target=\"_blank\" rel=\"noopener\">backlog参数理解</a></p>\n<p><a href=\"https://www.cnblogs.com/Orgliny/p/5780796.html\" target=\"_blank\" rel=\"noopener\">半连接队列和全连接队列</a></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p><a href=\"https://blog.csdn.net/morewindows/article/details/7354571\" target=\"_blank\" rel=\"noopener\">位操作</a></p>\n<h2 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h2><p><a href=\"http://www.cnblogs.com/Kobe10/p/6494621.html\" target=\"_blank\" rel=\"noopener\">ubuntu16.04安装mysql</a></p>\n<p><a href=\"https://www.jianshu.com/p/ccaf688f54c0\" target=\"_blank\" rel=\"noopener\">linux解决解决/usr/bin/ld: cannot find -lxxx</a></p>\n<p><a href=\"https://blog.csdn.net/dumuweiyang/article/details/80826250\" target=\"_blank\" rel=\"noopener\">Windows下vs2012安装boost库</a></p>\n<p>小插曲:一开始安装的是boost_1_70_0，日志提示应该是工具集不匹配的问题，又乖乖按照博客中的boost_1_67_0进行安装。</p>\n<p>能够成功安装，但是无法使用，又配合下面的博客成功完成boost的使用。</p>\n<p><a href=\"https://blog.csdn.net/qq_36038987/article/details/80842205\" target=\"_blank\" rel=\"noopener\">boost库安装的问题解决</a></p>\n<p><a href=\"https://blog.csdn.net/dcrmg/article/details/51809614\" target=\"_blank\" rel=\"noopener\">Windows下vs2012安装OpenCV2.4.13</a></p>\n<p>虽然安装的OpenCV版本比较旧，但是这也是一次初体验</p>\n<p>遇到的问题：</p>\n<ul>\n<li>一开始编译能通过但是找不到库，重启了一下机器就ok了，因为系统环境变量需要重启才能生效</li>\n<li>imread读取图片失败<ul>\n<li>注意链接库版本：debug的库为xxxd.dll，release的库为xxx.dll</li>\n<li>更坑爹的是，都正确了还是不行，编译能过，但是一直有warning:由通用字符名称“\\u202A”表示的字符不能在当前代码页(936)中表示出来，就一直没在意，但是一直运行不出来。查了一下才发现是路径复制过来的问题。</li>\n</ul>\n</li>\n<li>imshow图片显示不出来：imshow之后要调用waitKey或者cvWaitKey</li>\n</ul>\n<p><a href=\"https://docs.opencv.org/master/d7/d9f/tutorial_linux_install.html\" target=\"_blank\" rel=\"noopener\">ubuntu16.04安装OpenCV</a></p>\n<ul>\n<li>不行的话就加个sudo提权</li>\n<li>pkg-config –modversion opencv 版本查看</li>\n<li><a href=\"https://docs.opencv.org/master/db/df5/tutorial_linux_gcc_cmake.html\" target=\"_blank\" rel=\"noopener\">测试用例</a></li>\n</ul>\n<p><a href=\"https://www.cnblogs.com/lidabo/p/5888997.html\" target=\"_blank\" rel=\"noopener\">ubuntu16.04 vscode 配置C++环境</a></p>\n<p><a href=\"https://blog.csdn.net/fengbingchun/article/details/60780232\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fengbingchun/article/details/60780232</a></p>\n<p><a href=\"https://blog.csdn.net/tt_ren/article/details/53227900\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tt_ren/article/details/53227900</a></p>\n<p><a href=\"https://blog.csdn.net/feierban/article/details/80283727\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/feierban/article/details/80283727</a></p>\n"},{"title":"写给21岁的自己","date":"2018-10-27T13:22:16.000Z","_content":"\n## 现状\n\n​        今天哈尔滨下了第一场雪，我才恍惚间发现，这已经是我上大学的第三年了。仍然记得来上大学第一年，是在我生日的那天下的第一场雪，这两年不变的是寒冷，变的是心境。\n\n## 告别那个她\n\n​         前几天生日的时候和大哥聊了一晚上，也释怀了很多。分手了也快两个月了，虽然表现得若无其事的样子，宿友和同学也并不知晓，但还是会在深夜难过，会偷偷看她的朋友圈和微博。但前几天有人问怎么最近没看见你和你女朋友视频，我尴尬地笑了笑，说了句分手了。其实喜欢一个人的时候，最害怕自己变得无趣。每天只耳语两三句的日子已经有一阵了，我曾经也想到过会有这样的结局。但更愿意相信这种状态是短暂的，异地状态在毕业就能解除，凭着对彼此的喜欢能支撑着下去。虽然最后分手不仅仅是因为彼此的交流变少了，但这是一个主要原因。究其原因，在于我自己。刚分手的那几天，每天都翻着以前的聊天记录，想着当初为什么喜欢说那么多废话，那么愿意和她分享生活中的小事，上课迟到了要说，走路滑倒了也要说，但久而久之，越来越觉得没有必要说了。我是个很容易受感情影响的人，很难将情感和生活分离开来。我狠下心来删掉了联络方式，即便如此我还是切不断过去。\n\n分手时她说的话我一直都保存在备忘录中，每天晚上都拿出来看一下，问一问自己为什么。如今我已经从感情中走了出来，但还有很长的时间去和过去告别。我不知道我什么时候有勇气去删掉手机相册里关于她的照片，什么时候有勇气去丢弃她送的种种礼物，什么时候真的不在意她生活的点点滴滴。努力去遗忘，努力尝试新的开始，很喜欢那天大哥说的一句话:分手也是另一种抵达。过去的一段经历，会让你更清楚地知道你喜欢什么的人，自己在恋爱关系中需要改进的地方，以及一段属于两个人的回忆。不说了，好好学习去了，人丑单身还不学习，将来我的儿子可怎么找小姐姐。\n\n## 我还有他们\n\n 上了大学之后，和爸妈见面的机会越来越少，可以说的话也越来越少。从小到大，虽然家里不是很富裕，但是爸妈总是能满足我的要求，有很多时候我想要这想要那，但都藏在心里了。因为我知道，他们做多已经够多了，以后想要的东西得靠你自己去争取。因此，这一年，就算从小妈妈跟我说读书是为了你自己，但我想这一年为了他们而学，尽早地实现财务自由，为他们逐渐老去的背影提供可靠的保障。\n\n## 关于我\n\n两年前，我是带着一份不甘心来到这里的，时时刻刻想说这里不属于我，虽然的确用GPA证明了自己，但是始终找不到自己的方向，因此我开始接触软件，也学习硬件。在比较中慢慢找寻，逐步放弃，我发现可能编程是适合我的那一个。虽然现在我已经熟悉了很多，但 远远没达到我心目中的高度。最近一直在听一首歌《像我这样的人》，感触很多，像我这样平凡的人又不甘平凡的人，世界上很多，不用力活一回， 你又怎么会成为那个闪闪发光的人呢？\n\n记录一段话，以此自省\n\n> 害怕平凡，却无意间被人潮左右，害怕被左右，却无奈像羔羊前涌。不停追逐，猛然间才发现依然不过是万千平凡中的一个。自信却因为现实不得不自卑。什么都懂，却又不想放弃固守的那一份单纯。觉得自己不一样，却真的找不出和他人的异同。\n\n## 憧憬\n\n既然已经决定直接秋招，非科班出身又没有优势，就给自己提几点要求。\n\n- 增强理论知识，多看书籍\n  - 接下来要完成的书单（完成之后再来滑掉）\n  - Effective C++\n  - More Effective C++\n  - STL源码解析\n  - C++设计模式\n  - Windows核心编程\n  - TCP/IP详解\n  - Linux网络编程\n  - Linux环境高级编程\n  - 算法4\n  - 编程之美\n\n- 好好利用Github，锻炼写博客的能力\n- 再写一个项目，回顾一下之前写过的\n- 坚持LeetCode、牛客刷题，提升一下手写代码的能力\n- 多涉猎各个领域的书籍，文字表达能力有多差心里有点数\n- 锻炼身体！！！！减肥减肥减肥\n\n","source":"_posts/写给21岁的自己.md","raw":"---\ntitle: 写给21岁的自己\ndate: 2018-10-27 21:22:16\ntags: 随笔\n---\n\n## 现状\n\n​        今天哈尔滨下了第一场雪，我才恍惚间发现，这已经是我上大学的第三年了。仍然记得来上大学第一年，是在我生日的那天下的第一场雪，这两年不变的是寒冷，变的是心境。\n\n## 告别那个她\n\n​         前几天生日的时候和大哥聊了一晚上，也释怀了很多。分手了也快两个月了，虽然表现得若无其事的样子，宿友和同学也并不知晓，但还是会在深夜难过，会偷偷看她的朋友圈和微博。但前几天有人问怎么最近没看见你和你女朋友视频，我尴尬地笑了笑，说了句分手了。其实喜欢一个人的时候，最害怕自己变得无趣。每天只耳语两三句的日子已经有一阵了，我曾经也想到过会有这样的结局。但更愿意相信这种状态是短暂的，异地状态在毕业就能解除，凭着对彼此的喜欢能支撑着下去。虽然最后分手不仅仅是因为彼此的交流变少了，但这是一个主要原因。究其原因，在于我自己。刚分手的那几天，每天都翻着以前的聊天记录，想着当初为什么喜欢说那么多废话，那么愿意和她分享生活中的小事，上课迟到了要说，走路滑倒了也要说，但久而久之，越来越觉得没有必要说了。我是个很容易受感情影响的人，很难将情感和生活分离开来。我狠下心来删掉了联络方式，即便如此我还是切不断过去。\n\n分手时她说的话我一直都保存在备忘录中，每天晚上都拿出来看一下，问一问自己为什么。如今我已经从感情中走了出来，但还有很长的时间去和过去告别。我不知道我什么时候有勇气去删掉手机相册里关于她的照片，什么时候有勇气去丢弃她送的种种礼物，什么时候真的不在意她生活的点点滴滴。努力去遗忘，努力尝试新的开始，很喜欢那天大哥说的一句话:分手也是另一种抵达。过去的一段经历，会让你更清楚地知道你喜欢什么的人，自己在恋爱关系中需要改进的地方，以及一段属于两个人的回忆。不说了，好好学习去了，人丑单身还不学习，将来我的儿子可怎么找小姐姐。\n\n## 我还有他们\n\n 上了大学之后，和爸妈见面的机会越来越少，可以说的话也越来越少。从小到大，虽然家里不是很富裕，但是爸妈总是能满足我的要求，有很多时候我想要这想要那，但都藏在心里了。因为我知道，他们做多已经够多了，以后想要的东西得靠你自己去争取。因此，这一年，就算从小妈妈跟我说读书是为了你自己，但我想这一年为了他们而学，尽早地实现财务自由，为他们逐渐老去的背影提供可靠的保障。\n\n## 关于我\n\n两年前，我是带着一份不甘心来到这里的，时时刻刻想说这里不属于我，虽然的确用GPA证明了自己，但是始终找不到自己的方向，因此我开始接触软件，也学习硬件。在比较中慢慢找寻，逐步放弃，我发现可能编程是适合我的那一个。虽然现在我已经熟悉了很多，但 远远没达到我心目中的高度。最近一直在听一首歌《像我这样的人》，感触很多，像我这样平凡的人又不甘平凡的人，世界上很多，不用力活一回， 你又怎么会成为那个闪闪发光的人呢？\n\n记录一段话，以此自省\n\n> 害怕平凡，却无意间被人潮左右，害怕被左右，却无奈像羔羊前涌。不停追逐，猛然间才发现依然不过是万千平凡中的一个。自信却因为现实不得不自卑。什么都懂，却又不想放弃固守的那一份单纯。觉得自己不一样，却真的找不出和他人的异同。\n\n## 憧憬\n\n既然已经决定直接秋招，非科班出身又没有优势，就给自己提几点要求。\n\n- 增强理论知识，多看书籍\n  - 接下来要完成的书单（完成之后再来滑掉）\n  - Effective C++\n  - More Effective C++\n  - STL源码解析\n  - C++设计模式\n  - Windows核心编程\n  - TCP/IP详解\n  - Linux网络编程\n  - Linux环境高级编程\n  - 算法4\n  - 编程之美\n\n- 好好利用Github，锻炼写博客的能力\n- 再写一个项目，回顾一下之前写过的\n- 坚持LeetCode、牛客刷题，提升一下手写代码的能力\n- 多涉猎各个领域的书籍，文字表达能力有多差心里有点数\n- 锻炼身体！！！！减肥减肥减肥\n\n","slug":"写给21岁的自己","published":1,"updated":"2021-12-06T05:30:36.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7q001m96ca0jquf469","content":"<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><p>​        今天哈尔滨下了第一场雪，我才恍惚间发现，这已经是我上大学的第三年了。仍然记得来上大学第一年，是在我生日的那天下的第一场雪，这两年不变的是寒冷，变的是心境。</p>\n<h2 id=\"告别那个她\"><a href=\"#告别那个她\" class=\"headerlink\" title=\"告别那个她\"></a>告别那个她</h2><p>​         前几天生日的时候和大哥聊了一晚上，也释怀了很多。分手了也快两个月了，虽然表现得若无其事的样子，宿友和同学也并不知晓，但还是会在深夜难过，会偷偷看她的朋友圈和微博。但前几天有人问怎么最近没看见你和你女朋友视频，我尴尬地笑了笑，说了句分手了。其实喜欢一个人的时候，最害怕自己变得无趣。每天只耳语两三句的日子已经有一阵了，我曾经也想到过会有这样的结局。但更愿意相信这种状态是短暂的，异地状态在毕业就能解除，凭着对彼此的喜欢能支撑着下去。虽然最后分手不仅仅是因为彼此的交流变少了，但这是一个主要原因。究其原因，在于我自己。刚分手的那几天，每天都翻着以前的聊天记录，想着当初为什么喜欢说那么多废话，那么愿意和她分享生活中的小事，上课迟到了要说，走路滑倒了也要说，但久而久之，越来越觉得没有必要说了。我是个很容易受感情影响的人，很难将情感和生活分离开来。我狠下心来删掉了联络方式，即便如此我还是切不断过去。</p>\n<p>分手时她说的话我一直都保存在备忘录中，每天晚上都拿出来看一下，问一问自己为什么。如今我已经从感情中走了出来，但还有很长的时间去和过去告别。我不知道我什么时候有勇气去删掉手机相册里关于她的照片，什么时候有勇气去丢弃她送的种种礼物，什么时候真的不在意她生活的点点滴滴。努力去遗忘，努力尝试新的开始，很喜欢那天大哥说的一句话:分手也是另一种抵达。过去的一段经历，会让你更清楚地知道你喜欢什么的人，自己在恋爱关系中需要改进的地方，以及一段属于两个人的回忆。不说了，好好学习去了，人丑单身还不学习，将来我的儿子可怎么找小姐姐。</p>\n<h2 id=\"我还有他们\"><a href=\"#我还有他们\" class=\"headerlink\" title=\"我还有他们\"></a>我还有他们</h2><p> 上了大学之后，和爸妈见面的机会越来越少，可以说的话也越来越少。从小到大，虽然家里不是很富裕，但是爸妈总是能满足我的要求，有很多时候我想要这想要那，但都藏在心里了。因为我知道，他们做多已经够多了，以后想要的东西得靠你自己去争取。因此，这一年，就算从小妈妈跟我说读书是为了你自己，但我想这一年为了他们而学，尽早地实现财务自由，为他们逐渐老去的背影提供可靠的保障。</p>\n<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>两年前，我是带着一份不甘心来到这里的，时时刻刻想说这里不属于我，虽然的确用GPA证明了自己，但是始终找不到自己的方向，因此我开始接触软件，也学习硬件。在比较中慢慢找寻，逐步放弃，我发现可能编程是适合我的那一个。虽然现在我已经熟悉了很多，但 远远没达到我心目中的高度。最近一直在听一首歌《像我这样的人》，感触很多，像我这样平凡的人又不甘平凡的人，世界上很多，不用力活一回， 你又怎么会成为那个闪闪发光的人呢？</p>\n<p>记录一段话，以此自省</p>\n<blockquote>\n<p>害怕平凡，却无意间被人潮左右，害怕被左右，却无奈像羔羊前涌。不停追逐，猛然间才发现依然不过是万千平凡中的一个。自信却因为现实不得不自卑。什么都懂，却又不想放弃固守的那一份单纯。觉得自己不一样，却真的找不出和他人的异同。</p>\n</blockquote>\n<h2 id=\"憧憬\"><a href=\"#憧憬\" class=\"headerlink\" title=\"憧憬\"></a>憧憬</h2><p>既然已经决定直接秋招，非科班出身又没有优势，就给自己提几点要求。</p>\n<ul>\n<li><p>增强理论知识，多看书籍</p>\n<ul>\n<li>接下来要完成的书单（完成之后再来滑掉）</li>\n<li>Effective C++</li>\n<li>More Effective C++</li>\n<li>STL源码解析</li>\n<li>C++设计模式</li>\n<li>Windows核心编程</li>\n<li>TCP/IP详解</li>\n<li>Linux网络编程</li>\n<li>Linux环境高级编程</li>\n<li>算法4</li>\n<li>编程之美</li>\n</ul>\n</li>\n<li><p>好好利用Github，锻炼写博客的能力</p>\n</li>\n<li><p>再写一个项目，回顾一下之前写过的</p>\n</li>\n<li><p>坚持LeetCode、牛客刷题，提升一下手写代码的能力</p>\n</li>\n<li><p>多涉猎各个领域的书籍，文字表达能力有多差心里有点数</p>\n</li>\n<li><p>锻炼身体！！！！减肥减肥减肥</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><p>​        今天哈尔滨下了第一场雪，我才恍惚间发现，这已经是我上大学的第三年了。仍然记得来上大学第一年，是在我生日的那天下的第一场雪，这两年不变的是寒冷，变的是心境。</p>\n<h2 id=\"告别那个她\"><a href=\"#告别那个她\" class=\"headerlink\" title=\"告别那个她\"></a>告别那个她</h2><p>​         前几天生日的时候和大哥聊了一晚上，也释怀了很多。分手了也快两个月了，虽然表现得若无其事的样子，宿友和同学也并不知晓，但还是会在深夜难过，会偷偷看她的朋友圈和微博。但前几天有人问怎么最近没看见你和你女朋友视频，我尴尬地笑了笑，说了句分手了。其实喜欢一个人的时候，最害怕自己变得无趣。每天只耳语两三句的日子已经有一阵了，我曾经也想到过会有这样的结局。但更愿意相信这种状态是短暂的，异地状态在毕业就能解除，凭着对彼此的喜欢能支撑着下去。虽然最后分手不仅仅是因为彼此的交流变少了，但这是一个主要原因。究其原因，在于我自己。刚分手的那几天，每天都翻着以前的聊天记录，想着当初为什么喜欢说那么多废话，那么愿意和她分享生活中的小事，上课迟到了要说，走路滑倒了也要说，但久而久之，越来越觉得没有必要说了。我是个很容易受感情影响的人，很难将情感和生活分离开来。我狠下心来删掉了联络方式，即便如此我还是切不断过去。</p>\n<p>分手时她说的话我一直都保存在备忘录中，每天晚上都拿出来看一下，问一问自己为什么。如今我已经从感情中走了出来，但还有很长的时间去和过去告别。我不知道我什么时候有勇气去删掉手机相册里关于她的照片，什么时候有勇气去丢弃她送的种种礼物，什么时候真的不在意她生活的点点滴滴。努力去遗忘，努力尝试新的开始，很喜欢那天大哥说的一句话:分手也是另一种抵达。过去的一段经历，会让你更清楚地知道你喜欢什么的人，自己在恋爱关系中需要改进的地方，以及一段属于两个人的回忆。不说了，好好学习去了，人丑单身还不学习，将来我的儿子可怎么找小姐姐。</p>\n<h2 id=\"我还有他们\"><a href=\"#我还有他们\" class=\"headerlink\" title=\"我还有他们\"></a>我还有他们</h2><p> 上了大学之后，和爸妈见面的机会越来越少，可以说的话也越来越少。从小到大，虽然家里不是很富裕，但是爸妈总是能满足我的要求，有很多时候我想要这想要那，但都藏在心里了。因为我知道，他们做多已经够多了，以后想要的东西得靠你自己去争取。因此，这一年，就算从小妈妈跟我说读书是为了你自己，但我想这一年为了他们而学，尽早地实现财务自由，为他们逐渐老去的背影提供可靠的保障。</p>\n<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>两年前，我是带着一份不甘心来到这里的，时时刻刻想说这里不属于我，虽然的确用GPA证明了自己，但是始终找不到自己的方向，因此我开始接触软件，也学习硬件。在比较中慢慢找寻，逐步放弃，我发现可能编程是适合我的那一个。虽然现在我已经熟悉了很多，但 远远没达到我心目中的高度。最近一直在听一首歌《像我这样的人》，感触很多，像我这样平凡的人又不甘平凡的人，世界上很多，不用力活一回， 你又怎么会成为那个闪闪发光的人呢？</p>\n<p>记录一段话，以此自省</p>\n<blockquote>\n<p>害怕平凡，却无意间被人潮左右，害怕被左右，却无奈像羔羊前涌。不停追逐，猛然间才发现依然不过是万千平凡中的一个。自信却因为现实不得不自卑。什么都懂，却又不想放弃固守的那一份单纯。觉得自己不一样，却真的找不出和他人的异同。</p>\n</blockquote>\n<h2 id=\"憧憬\"><a href=\"#憧憬\" class=\"headerlink\" title=\"憧憬\"></a>憧憬</h2><p>既然已经决定直接秋招，非科班出身又没有优势，就给自己提几点要求。</p>\n<ul>\n<li><p>增强理论知识，多看书籍</p>\n<ul>\n<li>接下来要完成的书单（完成之后再来滑掉）</li>\n<li>Effective C++</li>\n<li>More Effective C++</li>\n<li>STL源码解析</li>\n<li>C++设计模式</li>\n<li>Windows核心编程</li>\n<li>TCP/IP详解</li>\n<li>Linux网络编程</li>\n<li>Linux环境高级编程</li>\n<li>算法4</li>\n<li>编程之美</li>\n</ul>\n</li>\n<li><p>好好利用Github，锻炼写博客的能力</p>\n</li>\n<li><p>再写一个项目，回顾一下之前写过的</p>\n</li>\n<li><p>坚持LeetCode、牛客刷题，提升一下手写代码的能力</p>\n</li>\n<li><p>多涉猎各个领域的书籍，文字表达能力有多差心里有点数</p>\n</li>\n<li><p>锻炼身体！！！！减肥减肥减肥</p>\n</li>\n</ul>\n"},{"title":"拥塞控制","date":"2018-11-17T15:22:28.000Z","_content":"\n## 引言\n\n 计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做拥塞。\n\n拥塞控制就是防止过多的数据注入到网络中，避免路由器或数据链路过载。(网络中的数据是经过路由器进行转发)\n\n拥塞控制是一个全局性的过程，面对的是整个网络，不用于端到端的流量控制。\n\n拥塞控制的作用就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。\n\n<!-- more -->\n\n## 慢启动和拥塞避免\n\n发送端维护一个拥塞窗口(cwnd)，大小取决于网络的拥塞程度动态地变化。\n\n慢启动:TCP模块一开始发送数据时并不知道网络的实际情况，先探测一下网络的拥塞情况。\n\n下面的实例以报文数量做演示，实际上是以字节为单位。\n\n![慢开始](/pic/慢开始.png)\n\n注意:慢启动阶段接收端没确认一次，拥塞窗口大小就加1\n\n1.第一次发送端发送M1，接收端确认了\n2.第二次由于接收端确认了M1，因此拥塞窗口加1，发送M2和M3\n3.第三次由于接收端确认了M2和M3，拥塞窗口加2，变成4，发送M4-M7\n\n由此可见，慢启动阶段传输轮次每加一，拥塞窗口数就加倍，呈乘法增长。\n\n但是为了防止拥塞窗口增长过大引起网络拥塞，因此需要一个慢启动的门限值(ssthresh)\n一旦超过这个门限值，就该用拥塞避免算法。\n拥塞避免:让拥塞窗口缓慢增长，即每经过一个往返时间RTT(一轮)，拥塞窗口只加1，呈加法增长。\n\n无论是在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢启动门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢启动算法。\n\n![慢开始拥塞避免](/pic/慢开始和拥塞避免.png)\n\n## 快重传和快恢复\n\n快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n\n![快重传](/pic/快重传.png)\n\n快重传还配合着快恢复。\n\n快重传一旦触发，意味着出现丢包，但考虑到还能收到几个重复地确认包，因此不是网络拥塞造成的，所以不执行慢启动，而是执行快恢复。\n\n快恢复:1.当发送方连续收到三个重复确认时，就执行“乘法减小”算法，ssthresh变成当时拥塞窗口的一半\n　　　 2.将窗口设置为ssthresh的大小，然后执行拥塞避免算法。\n\n![快恢复](/pic/快恢复.png)\n\n\n\n## 扩展\n\n在Linux下，拥塞控制算法有多种实现，比如reno算法、vegas算法、cubic算法等，基本都实现了上述四个部分。\n\n/proc/sys/net/ipv4/tcp_congestion_control文件中指示了机器当前使用的拥塞控制算法。\n\n\n\n\n\n\n\n","source":"_posts/拥塞控制.md","raw":"---\ntitle: 拥塞控制\ndate: 2018-11-17 23:22:28\ntags: \n- TCP\n- 网络\n---\n\n## 引言\n\n 计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做拥塞。\n\n拥塞控制就是防止过多的数据注入到网络中，避免路由器或数据链路过载。(网络中的数据是经过路由器进行转发)\n\n拥塞控制是一个全局性的过程，面对的是整个网络，不用于端到端的流量控制。\n\n拥塞控制的作用就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。\n\n<!-- more -->\n\n## 慢启动和拥塞避免\n\n发送端维护一个拥塞窗口(cwnd)，大小取决于网络的拥塞程度动态地变化。\n\n慢启动:TCP模块一开始发送数据时并不知道网络的实际情况，先探测一下网络的拥塞情况。\n\n下面的实例以报文数量做演示，实际上是以字节为单位。\n\n![慢开始](/pic/慢开始.png)\n\n注意:慢启动阶段接收端没确认一次，拥塞窗口大小就加1\n\n1.第一次发送端发送M1，接收端确认了\n2.第二次由于接收端确认了M1，因此拥塞窗口加1，发送M2和M3\n3.第三次由于接收端确认了M2和M3，拥塞窗口加2，变成4，发送M4-M7\n\n由此可见，慢启动阶段传输轮次每加一，拥塞窗口数就加倍，呈乘法增长。\n\n但是为了防止拥塞窗口增长过大引起网络拥塞，因此需要一个慢启动的门限值(ssthresh)\n一旦超过这个门限值，就该用拥塞避免算法。\n拥塞避免:让拥塞窗口缓慢增长，即每经过一个往返时间RTT(一轮)，拥塞窗口只加1，呈加法增长。\n\n无论是在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢启动门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢启动算法。\n\n![慢开始拥塞避免](/pic/慢开始和拥塞避免.png)\n\n## 快重传和快恢复\n\n快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n\n![快重传](/pic/快重传.png)\n\n快重传还配合着快恢复。\n\n快重传一旦触发，意味着出现丢包，但考虑到还能收到几个重复地确认包，因此不是网络拥塞造成的，所以不执行慢启动，而是执行快恢复。\n\n快恢复:1.当发送方连续收到三个重复确认时，就执行“乘法减小”算法，ssthresh变成当时拥塞窗口的一半\n　　　 2.将窗口设置为ssthresh的大小，然后执行拥塞避免算法。\n\n![快恢复](/pic/快恢复.png)\n\n\n\n## 扩展\n\n在Linux下，拥塞控制算法有多种实现，比如reno算法、vegas算法、cubic算法等，基本都实现了上述四个部分。\n\n/proc/sys/net/ipv4/tcp_congestion_control文件中指示了机器当前使用的拥塞控制算法。\n\n\n\n\n\n\n\n","slug":"拥塞控制","published":1,"updated":"2021-12-06T05:30:36.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7r001o96ca8495fm13","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p> 计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做拥塞。</p>\n<p>拥塞控制就是防止过多的数据注入到网络中，避免路由器或数据链路过载。(网络中的数据是经过路由器进行转发)</p>\n<p>拥塞控制是一个全局性的过程，面对的是整个网络，不用于端到端的流量控制。</p>\n<p>拥塞控制的作用就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"慢启动和拥塞避免\"><a href=\"#慢启动和拥塞避免\" class=\"headerlink\" title=\"慢启动和拥塞避免\"></a>慢启动和拥塞避免</h2><p>发送端维护一个拥塞窗口(cwnd)，大小取决于网络的拥塞程度动态地变化。</p>\n<p>慢启动:TCP模块一开始发送数据时并不知道网络的实际情况，先探测一下网络的拥塞情况。</p>\n<p>下面的实例以报文数量做演示，实际上是以字节为单位。</p>\n<p><img src=\"/pic/%E6%85%A2%E5%BC%80%E5%A7%8B.png\" alt=\"慢开始\"></p>\n<p>注意:慢启动阶段接收端没确认一次，拥塞窗口大小就加1</p>\n<p>1.第一次发送端发送M1，接收端确认了<br>2.第二次由于接收端确认了M1，因此拥塞窗口加1，发送M2和M3<br>3.第三次由于接收端确认了M2和M3，拥塞窗口加2，变成4，发送M4-M7</p>\n<p>由此可见，慢启动阶段传输轮次每加一，拥塞窗口数就加倍，呈乘法增长。</p>\n<p>但是为了防止拥塞窗口增长过大引起网络拥塞，因此需要一个慢启动的门限值(ssthresh)<br>一旦超过这个门限值，就该用拥塞避免算法。<br>拥塞避免:让拥塞窗口缓慢增长，即每经过一个往返时间RTT(一轮)，拥塞窗口只加1，呈加法增长。</p>\n<p>无论是在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢启动门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢启动算法。</p>\n<p><img src=\"/pic/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png\" alt=\"慢开始拥塞避免\"></p>\n<h2 id=\"快重传和快恢复\"><a href=\"#快重传和快恢复\" class=\"headerlink\" title=\"快重传和快恢复\"></a>快重传和快恢复</h2><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>\n<p><img src=\"/pic/%E5%BF%AB%E9%87%8D%E4%BC%A0.png\" alt=\"快重传\"></p>\n<p>快重传还配合着快恢复。</p>\n<p>快重传一旦触发，意味着出现丢包，但考虑到还能收到几个重复地确认包，因此不是网络拥塞造成的，所以不执行慢启动，而是执行快恢复。</p>\n<p>快恢复:1.当发送方连续收到三个重复确认时，就执行“乘法减小”算法，ssthresh变成当时拥塞窗口的一半<br>　　　 2.将窗口设置为ssthresh的大小，然后执行拥塞避免算法。</p>\n<p><img src=\"/pic/%E5%BF%AB%E6%81%A2%E5%A4%8D.png\" alt=\"快恢复\"></p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>在Linux下，拥塞控制算法有多种实现，比如reno算法、vegas算法、cubic算法等，基本都实现了上述四个部分。</p>\n<p>/proc/sys/net/ipv4/tcp_congestion_control文件中指示了机器当前使用的拥塞控制算法。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p> 计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做拥塞。</p>\n<p>拥塞控制就是防止过多的数据注入到网络中，避免路由器或数据链路过载。(网络中的数据是经过路由器进行转发)</p>\n<p>拥塞控制是一个全局性的过程，面对的是整个网络，不用于端到端的流量控制。</p>\n<p>拥塞控制的作用就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。</p>","more":"<h2 id=\"慢启动和拥塞避免\"><a href=\"#慢启动和拥塞避免\" class=\"headerlink\" title=\"慢启动和拥塞避免\"></a>慢启动和拥塞避免</h2><p>发送端维护一个拥塞窗口(cwnd)，大小取决于网络的拥塞程度动态地变化。</p>\n<p>慢启动:TCP模块一开始发送数据时并不知道网络的实际情况，先探测一下网络的拥塞情况。</p>\n<p>下面的实例以报文数量做演示，实际上是以字节为单位。</p>\n<p><img src=\"/pic/%E6%85%A2%E5%BC%80%E5%A7%8B.png\" alt=\"慢开始\"></p>\n<p>注意:慢启动阶段接收端没确认一次，拥塞窗口大小就加1</p>\n<p>1.第一次发送端发送M1，接收端确认了<br>2.第二次由于接收端确认了M1，因此拥塞窗口加1，发送M2和M3<br>3.第三次由于接收端确认了M2和M3，拥塞窗口加2，变成4，发送M4-M7</p>\n<p>由此可见，慢启动阶段传输轮次每加一，拥塞窗口数就加倍，呈乘法增长。</p>\n<p>但是为了防止拥塞窗口增长过大引起网络拥塞，因此需要一个慢启动的门限值(ssthresh)<br>一旦超过这个门限值，就该用拥塞避免算法。<br>拥塞避免:让拥塞窗口缓慢增长，即每经过一个往返时间RTT(一轮)，拥塞窗口只加1，呈加法增长。</p>\n<p>无论是在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢启动门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢启动算法。</p>\n<p><img src=\"/pic/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png\" alt=\"慢开始拥塞避免\"></p>\n<h2 id=\"快重传和快恢复\"><a href=\"#快重传和快恢复\" class=\"headerlink\" title=\"快重传和快恢复\"></a>快重传和快恢复</h2><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>\n<p><img src=\"/pic/%E5%BF%AB%E9%87%8D%E4%BC%A0.png\" alt=\"快重传\"></p>\n<p>快重传还配合着快恢复。</p>\n<p>快重传一旦触发，意味着出现丢包，但考虑到还能收到几个重复地确认包，因此不是网络拥塞造成的，所以不执行慢启动，而是执行快恢复。</p>\n<p>快恢复:1.当发送方连续收到三个重复确认时，就执行“乘法减小”算法，ssthresh变成当时拥塞窗口的一半<br>　　　 2.将窗口设置为ssthresh的大小，然后执行拥塞避免算法。</p>\n<p><img src=\"/pic/%E5%BF%AB%E6%81%A2%E5%A4%8D.png\" alt=\"快恢复\"></p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>在Linux下，拥塞控制算法有多种实现，比如reno算法、vegas算法、cubic算法等，基本都实现了上述四个部分。</p>\n<p>/proc/sys/net/ipv4/tcp_congestion_control文件中指示了机器当前使用的拥塞控制算法。</p>"},{"title":"构造函数","date":"2018-11-02T04:52:10.000Z","_content":"\n## 构造函数介绍\n\n构造函数：类通过一个或几个特殊的成员函数来控制其成员对象的初始化过程。\n\n特点：1. 没有返回类型  2. 支持重载  3. 不能被声明成const(这一点还不是很理解 先码上 C++Primer p235) 4.无法被子类继承\n\n既然构造函数也是函数，那么什么时候调用构造函数？\n\n答案：对象被创建的时候。\n\n构造函数执行顺序: ①传参  ②给类数据成员开辟空间   ③执行冒号语法给数据成员初始化  ④执行构造函数括号里面的内容\n<!-- more -->\n\n\n如果不指定构造函数，编译器会默认生成一个构造函数，拷贝构造函数(浅拷贝)，析构函数,重载=操作符函数。\n\n当我们不需要编译器生成的这么函数时，就需要自己显式地声明出来。通过利用这点我们就可以限制对象的产生，例如，我们将默认构造函数，拷贝构造函数声明为私有，就可以防止外界来产生这个对象，这点主要是在单例模式中使用。\n\n如果我们需要默认的构造函数可以用    类名()=default;  //C++11新特性\n\n## 初始化成员对象的方式\n\n1. 构造函数里赋值\n2. 初始化列表\n3. 类内直接初始化(C++11新特性）\n\n**需要注意的是：const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化(编译器不支持的话就只能选用前者)**\n\n例如:\n\n```c++\nclass A{\n    int x;\n    A(int y){x = y;}\n};\nclass B{\n    A a;\n    const int b;\n    int &c;\n    static int si;\n    static const int sci;\n    static const int sci2 = 100;\n    static const double  = 99.9 //error \n    //在vs2012中只有静态常量整型才能在类中初始化\n    B():a(100),b(10),c(c.a){}\n}; \nint B::si = 1;\nconst int B::sci = 2;\n\n```\n\n由此可见，初始化列表和构造函数赋值完成的是同样的工作，但是有的工作构造函数做不了，因此最好使用初始化列表，整理一下理由。\n\n1. const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化\n2. 效率更高，这涉及初始化和赋值关于底层效率的问题。如果在类的构造函数中赋值，在成员初始化时会调用一次默认的构造函数，在函数体中赋值又调用一次。而利用初始化列表仅调用一次。\n\n## 成员变量初始化顺序\n\n用初始化列表进行初始化，是按照变量声明的顺序进行初始化\n\n```\nclass T{\n  int x;\n  int y;\n  T(int val):y(val),x(y+1){}  \n};   \n//输出x=-858993459,y=10 \n```\n\n可见x是一个未定义的值，这是因为编译器先初始了x，因为x先定义，此时y还没有被初始化为10。由此可见变量初始化的顺序跟变量在内存中的顺序有关。\n\n解决方案：1.保持声明和初始化顺序一致 2.使用构造函数赋值\n\n**需要注意的点：static成员变量必须在类外初始化**\n\n为什么？\n\n因为在类外定义和初始化是保证static成员变量只被定义一次的好方法，static变量的生命期与类对象是异步的，这也是可以用作用域访问静态成员变量的原因。如果在类内初始化，让静态成员变量依赖于类对象，就无所谓静态两字了。\n\n继承关系的初始化顺序：\n\n1. 基类的静态成员\n2. 派生类的静态成员\n3. 基类的成员变量\n4. 派生类的成员变量\n\n当派生类中不含对象成员时:\n\n构造执行顺序: 基类->派生类(构造函数无法被继承，为了继承父类中的成员变量，要先调用父类的构造)\n\n析构执行顺序：派生类->基类\n\n当派生类中含有对象成员时：\n构造执行顺序:基类->对象成员构造->派生类(类成员初始化总在构造函数执行之前)\n\n析构执行顺序:派生类->对象成员析构->基类\n\n## 扩展\n\n关于构造函数，C++11新特性还有一个委托构造函数，大致想法就是使用别的构造函数来实现自己。(C++ primer 261)\n\n","source":"_posts/构造函数.md","raw":"---\ntitle: 构造函数\ndate: 2018-11-02 12:52:10\ntags: C++\n---\n\n## 构造函数介绍\n\n构造函数：类通过一个或几个特殊的成员函数来控制其成员对象的初始化过程。\n\n特点：1. 没有返回类型  2. 支持重载  3. 不能被声明成const(这一点还不是很理解 先码上 C++Primer p235) 4.无法被子类继承\n\n既然构造函数也是函数，那么什么时候调用构造函数？\n\n答案：对象被创建的时候。\n\n构造函数执行顺序: ①传参  ②给类数据成员开辟空间   ③执行冒号语法给数据成员初始化  ④执行构造函数括号里面的内容\n<!-- more -->\n\n\n如果不指定构造函数，编译器会默认生成一个构造函数，拷贝构造函数(浅拷贝)，析构函数,重载=操作符函数。\n\n当我们不需要编译器生成的这么函数时，就需要自己显式地声明出来。通过利用这点我们就可以限制对象的产生，例如，我们将默认构造函数，拷贝构造函数声明为私有，就可以防止外界来产生这个对象，这点主要是在单例模式中使用。\n\n如果我们需要默认的构造函数可以用    类名()=default;  //C++11新特性\n\n## 初始化成员对象的方式\n\n1. 构造函数里赋值\n2. 初始化列表\n3. 类内直接初始化(C++11新特性）\n\n**需要注意的是：const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化(编译器不支持的话就只能选用前者)**\n\n例如:\n\n```c++\nclass A{\n    int x;\n    A(int y){x = y;}\n};\nclass B{\n    A a;\n    const int b;\n    int &c;\n    static int si;\n    static const int sci;\n    static const int sci2 = 100;\n    static const double  = 99.9 //error \n    //在vs2012中只有静态常量整型才能在类中初始化\n    B():a(100),b(10),c(c.a){}\n}; \nint B::si = 1;\nconst int B::sci = 2;\n\n```\n\n由此可见，初始化列表和构造函数赋值完成的是同样的工作，但是有的工作构造函数做不了，因此最好使用初始化列表，整理一下理由。\n\n1. const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化\n2. 效率更高，这涉及初始化和赋值关于底层效率的问题。如果在类的构造函数中赋值，在成员初始化时会调用一次默认的构造函数，在函数体中赋值又调用一次。而利用初始化列表仅调用一次。\n\n## 成员变量初始化顺序\n\n用初始化列表进行初始化，是按照变量声明的顺序进行初始化\n\n```\nclass T{\n  int x;\n  int y;\n  T(int val):y(val),x(y+1){}  \n};   \n//输出x=-858993459,y=10 \n```\n\n可见x是一个未定义的值，这是因为编译器先初始了x，因为x先定义，此时y还没有被初始化为10。由此可见变量初始化的顺序跟变量在内存中的顺序有关。\n\n解决方案：1.保持声明和初始化顺序一致 2.使用构造函数赋值\n\n**需要注意的点：static成员变量必须在类外初始化**\n\n为什么？\n\n因为在类外定义和初始化是保证static成员变量只被定义一次的好方法，static变量的生命期与类对象是异步的，这也是可以用作用域访问静态成员变量的原因。如果在类内初始化，让静态成员变量依赖于类对象，就无所谓静态两字了。\n\n继承关系的初始化顺序：\n\n1. 基类的静态成员\n2. 派生类的静态成员\n3. 基类的成员变量\n4. 派生类的成员变量\n\n当派生类中不含对象成员时:\n\n构造执行顺序: 基类->派生类(构造函数无法被继承，为了继承父类中的成员变量，要先调用父类的构造)\n\n析构执行顺序：派生类->基类\n\n当派生类中含有对象成员时：\n构造执行顺序:基类->对象成员构造->派生类(类成员初始化总在构造函数执行之前)\n\n析构执行顺序:派生类->对象成员析构->基类\n\n## 扩展\n\n关于构造函数，C++11新特性还有一个委托构造函数，大致想法就是使用别的构造函数来实现自己。(C++ primer 261)\n\n","slug":"构造函数","published":1,"updated":"2021-12-06T05:30:36.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7r001r96ca3qiy7it1","content":"<h2 id=\"构造函数介绍\"><a href=\"#构造函数介绍\" class=\"headerlink\" title=\"构造函数介绍\"></a>构造函数介绍</h2><p>构造函数：类通过一个或几个特殊的成员函数来控制其成员对象的初始化过程。</p>\n<p>特点：1. 没有返回类型  2. 支持重载  3. 不能被声明成const(这一点还不是很理解 先码上 C++Primer p235) 4.无法被子类继承</p>\n<p>既然构造函数也是函数，那么什么时候调用构造函数？</p>\n<p>答案：对象被创建的时候。</p>\n<p>构造函数执行顺序: ①传参  ②给类数据成员开辟空间   ③执行冒号语法给数据成员初始化  ④执行构造函数括号里面的内容</p>\n<a id=\"more\"></a>\n\n\n<p>如果不指定构造函数，编译器会默认生成一个构造函数，拷贝构造函数(浅拷贝)，析构函数,重载=操作符函数。</p>\n<p>当我们不需要编译器生成的这么函数时，就需要自己显式地声明出来。通过利用这点我们就可以限制对象的产生，例如，我们将默认构造函数，拷贝构造函数声明为私有，就可以防止外界来产生这个对象，这点主要是在单例模式中使用。</p>\n<p>如果我们需要默认的构造函数可以用    类名()=default;  //C++11新特性</p>\n<h2 id=\"初始化成员对象的方式\"><a href=\"#初始化成员对象的方式\" class=\"headerlink\" title=\"初始化成员对象的方式\"></a>初始化成员对象的方式</h2><ol>\n<li>构造函数里赋值</li>\n<li>初始化列表</li>\n<li>类内直接初始化(C++11新特性）</li>\n</ol>\n<p><strong>需要注意的是：const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化(编译器不支持的话就只能选用前者)</strong></p>\n<p>例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    A(<span class=\"keyword\">int</span> y)&#123;x = y;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;c;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> si;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sci;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sci2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">double</span>  = <span class=\"number\">99.9</span> <span class=\"comment\">//error </span></span><br><span class=\"line\">    <span class=\"comment\">//在vs2012中只有静态常量整型才能在类中初始化</span></span><br><span class=\"line\">    B():a(<span class=\"number\">100</span>),b(<span class=\"number\">10</span>),c(c.a)&#123;&#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">int</span> B::si = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> B::sci = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>由此可见，初始化列表和构造函数赋值完成的是同样的工作，但是有的工作构造函数做不了，因此最好使用初始化列表，整理一下理由。</p>\n<ol>\n<li>const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化</li>\n<li>效率更高，这涉及初始化和赋值关于底层效率的问题。如果在类的构造函数中赋值，在成员初始化时会调用一次默认的构造函数，在函数体中赋值又调用一次。而利用初始化列表仅调用一次。</li>\n</ol>\n<h2 id=\"成员变量初始化顺序\"><a href=\"#成员变量初始化顺序\" class=\"headerlink\" title=\"成员变量初始化顺序\"></a>成员变量初始化顺序</h2><p>用初始化列表进行初始化，是按照变量声明的顺序进行初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class T&#123;</span><br><span class=\"line\">  int x;</span><br><span class=\"line\">  int y;</span><br><span class=\"line\">  T(int val):y(val),x(y+1)&#123;&#125;  </span><br><span class=\"line\">&#125;;   </span><br><span class=\"line\">&#x2F;&#x2F;输出x&#x3D;-858993459,y&#x3D;10</span><br></pre></td></tr></table></figure>\n\n<p>可见x是一个未定义的值，这是因为编译器先初始了x，因为x先定义，此时y还没有被初始化为10。由此可见变量初始化的顺序跟变量在内存中的顺序有关。</p>\n<p>解决方案：1.保持声明和初始化顺序一致 2.使用构造函数赋值</p>\n<p><strong>需要注意的点：static成员变量必须在类外初始化</strong></p>\n<p>为什么？</p>\n<p>因为在类外定义和初始化是保证static成员变量只被定义一次的好方法，static变量的生命期与类对象是异步的，这也是可以用作用域访问静态成员变量的原因。如果在类内初始化，让静态成员变量依赖于类对象，就无所谓静态两字了。</p>\n<p>继承关系的初始化顺序：</p>\n<ol>\n<li>基类的静态成员</li>\n<li>派生类的静态成员</li>\n<li>基类的成员变量</li>\n<li>派生类的成员变量</li>\n</ol>\n<p>当派生类中不含对象成员时:</p>\n<p>构造执行顺序: 基类-&gt;派生类(构造函数无法被继承，为了继承父类中的成员变量，要先调用父类的构造)</p>\n<p>析构执行顺序：派生类-&gt;基类</p>\n<p>当派生类中含有对象成员时：<br>构造执行顺序:基类-&gt;对象成员构造-&gt;派生类(类成员初始化总在构造函数执行之前)</p>\n<p>析构执行顺序:派生类-&gt;对象成员析构-&gt;基类</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>关于构造函数，C++11新特性还有一个委托构造函数，大致想法就是使用别的构造函数来实现自己。(C++ primer 261)</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"构造函数介绍\"><a href=\"#构造函数介绍\" class=\"headerlink\" title=\"构造函数介绍\"></a>构造函数介绍</h2><p>构造函数：类通过一个或几个特殊的成员函数来控制其成员对象的初始化过程。</p>\n<p>特点：1. 没有返回类型  2. 支持重载  3. 不能被声明成const(这一点还不是很理解 先码上 C++Primer p235) 4.无法被子类继承</p>\n<p>既然构造函数也是函数，那么什么时候调用构造函数？</p>\n<p>答案：对象被创建的时候。</p>\n<p>构造函数执行顺序: ①传参  ②给类数据成员开辟空间   ③执行冒号语法给数据成员初始化  ④执行构造函数括号里面的内容</p>","more":"<p>如果不指定构造函数，编译器会默认生成一个构造函数，拷贝构造函数(浅拷贝)，析构函数,重载=操作符函数。</p>\n<p>当我们不需要编译器生成的这么函数时，就需要自己显式地声明出来。通过利用这点我们就可以限制对象的产生，例如，我们将默认构造函数，拷贝构造函数声明为私有，就可以防止外界来产生这个对象，这点主要是在单例模式中使用。</p>\n<p>如果我们需要默认的构造函数可以用    类名()=default;  //C++11新特性</p>\n<h2 id=\"初始化成员对象的方式\"><a href=\"#初始化成员对象的方式\" class=\"headerlink\" title=\"初始化成员对象的方式\"></a>初始化成员对象的方式</h2><ol>\n<li>构造函数里赋值</li>\n<li>初始化列表</li>\n<li>类内直接初始化(C++11新特性）</li>\n</ol>\n<p><strong>需要注意的是：const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化(编译器不支持的话就只能选用前者)</strong></p>\n<p>例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    A(<span class=\"keyword\">int</span> y)&#123;x = y;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> &amp;c;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> si;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sci;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sci2 = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">double</span>  = <span class=\"number\">99.9</span> <span class=\"comment\">//error </span></span><br><span class=\"line\">    <span class=\"comment\">//在vs2012中只有静态常量整型才能在类中初始化</span></span><br><span class=\"line\">    B():a(<span class=\"number\">100</span>),b(<span class=\"number\">10</span>),c(c.a)&#123;&#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">int</span> B::si = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> B::sci = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>由此可见，初始化列表和构造函数赋值完成的是同样的工作，但是有的工作构造函数做不了，因此最好使用初始化列表，整理一下理由。</p>\n<ol>\n<li>const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化</li>\n<li>效率更高，这涉及初始化和赋值关于底层效率的问题。如果在类的构造函数中赋值，在成员初始化时会调用一次默认的构造函数，在函数体中赋值又调用一次。而利用初始化列表仅调用一次。</li>\n</ol>\n<h2 id=\"成员变量初始化顺序\"><a href=\"#成员变量初始化顺序\" class=\"headerlink\" title=\"成员变量初始化顺序\"></a>成员变量初始化顺序</h2><p>用初始化列表进行初始化，是按照变量声明的顺序进行初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class T&#123;</span><br><span class=\"line\">  int x;</span><br><span class=\"line\">  int y;</span><br><span class=\"line\">  T(int val):y(val),x(y+1)&#123;&#125;  </span><br><span class=\"line\">&#125;;   </span><br><span class=\"line\">&#x2F;&#x2F;输出x&#x3D;-858993459,y&#x3D;10</span><br></pre></td></tr></table></figure>\n\n<p>可见x是一个未定义的值，这是因为编译器先初始了x，因为x先定义，此时y还没有被初始化为10。由此可见变量初始化的顺序跟变量在内存中的顺序有关。</p>\n<p>解决方案：1.保持声明和初始化顺序一致 2.使用构造函数赋值</p>\n<p><strong>需要注意的点：static成员变量必须在类外初始化</strong></p>\n<p>为什么？</p>\n<p>因为在类外定义和初始化是保证static成员变量只被定义一次的好方法，static变量的生命期与类对象是异步的，这也是可以用作用域访问静态成员变量的原因。如果在类内初始化，让静态成员变量依赖于类对象，就无所谓静态两字了。</p>\n<p>继承关系的初始化顺序：</p>\n<ol>\n<li>基类的静态成员</li>\n<li>派生类的静态成员</li>\n<li>基类的成员变量</li>\n<li>派生类的成员变量</li>\n</ol>\n<p>当派生类中不含对象成员时:</p>\n<p>构造执行顺序: 基类-&gt;派生类(构造函数无法被继承，为了继承父类中的成员变量，要先调用父类的构造)</p>\n<p>析构执行顺序：派生类-&gt;基类</p>\n<p>当派生类中含有对象成员时：<br>构造执行顺序:基类-&gt;对象成员构造-&gt;派生类(类成员初始化总在构造函数执行之前)</p>\n<p>析构执行顺序:派生类-&gt;对象成员析构-&gt;基类</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>关于构造函数，C++11新特性还有一个委托构造函数，大致想法就是使用别的构造函数来实现自己。(C++ primer 261)</p>"},{"title":"服务器内核参数配置","date":"2019-04-20T03:59:58.000Z","_content":"\nLinux平台一个优秀的特性就是内核微调，即可以通过修改文件的方式来调整内核参数。记录一些与服务器性能相关的部分内核参数。\n\n几乎所有的内核模块，包括内核核心模块和驱动程序,都在/proc/sys文件系统中提供了某些配置文件以供用户调整模块的属性和行为。通常一个配置文件对应一个内核参数，文件名就是参数的名字，文件的内容就是参数的值。\n\n可以通过 sysctl -a来查看所有的内核参数。\n\n<!--more-->\n\n## 最大文件描述符数\n\nLinux对应用程序能打开的最大文件描述符数量有两个层次的限制：用户级限制和系统级限制。\n\n用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数\n\n系统级限制是指所有用户总共能打开的文件描述符数\n\n\n\nulimit -n  是常用的查看用户级文件描述符限制的方法  默认一般为1024\n\nulimit -SHn max-file-number(自己设定数值)    将用户级文件描述符限制设为max-file-number'\n\n加-H就是硬，加-S就是软，默认显示的是软限制\n\n如果运行ulimit命令修改的时候没有加上这两个选项的话，就是两个参数一起改变。\n\n但是上面的这种设置是临时的，只在当前的session有效\n\n\n\n如果要永久修改用户级文件描述符数限制，可以在/etc/security/limits.conf文件加入两项，然后重启生效：\n\n```\n* soft nofile max-file-number(自己设置数值  32768)\n* hard nofile max-file-number(自己设置数值 65536)\n```\n\n配置文件最前面的是指domain，设置为星号代表全局，另外也可以针对不同的用户做出不同的限制。\n\n注意：这个当中的硬限制是实际的限制，而软限制，是warning限制，只会做出warning\n\n\n\n如果要修改系统级文件描述符限制，可以使用如下命令：\n\nsysctl -w fs.file-max=max-file-number(自己设置数值)  注意后面不能有空格，但是该命令也是临时更改系统限制\n\n系统总限制是在这里,/proc/sys/fs/file-max,可以通过cat查看目前的值\n\n\n\n如果要永久更改系统级文件描述符限制，则需要在/etc/sysctl.conf文件中添加如下一项：\n\nfs.file-max=max-file-number(自己设置数值)\n\n然后通过执行sysctl -p命令使更改生效\n\n\n\n/proc/sys/fs/file-nr，可以看到整个系统目前使用的文件句柄数量。\n\n查找文件句柄问题的时候，还有一个很实用的程序lsof(list open file)。\n\n可以很方便看到某个进程开了那些句柄，也可以看到某个文件/目录被什么进程占用了。\n\n## /proc/sys/fs目录下的部分文件\n\n/proc/sys/fs目录下的内核参数都与文件系统有关。对于服务器程序，比较重要的是\n\n- /proc/sys/fs/file-max，系统级文件描述符数限制，修改方式上面介绍过，一般修改/proc/sys/file-max后，应用程序需要把/proc/sys/fs/inode-max设置为新/proc/sys/fs/file-max值的3~4倍，否则可能导致i节点数不够\n\n- /proc/sys/fs/epoll/max_user_watches,一个用户能够往epoll内核事件表中注册的事件总量。它是指该用户打开的所有epoll实例总共能监听的事件数目，而不是单个epoll实例能监听的事件数目。往epoll内核事件表中注册一个事件，在32位系统上大概消耗90字节的内核空间，在64位系统上消耗160字节的内核空间。所以，这个内核参数限制了epoll使用的内核内存总量。(我的ubuntu16.04默认值为308299)\n\n## /proc/sys/net目录下的部分文件\n\n内核中网络模块的相关参数都位于/proc/sys/net目录下，其中和TCP/IP协议相关的参数主要位于下面三个子目录：core、ipv4和ipv6。\n\n- /proc/sys/net/core/somaxconn。指定listen监听队列中，能够建立完整连接从而进入ESTABLISHED状态的socket最大数目。(我的ubuntu16.04默认值为128)\n- /proc/sys/net/ipv4/tcp_max_syn_backlog。指定listen监听队列中，能够转移到ESTABLISHED状态或者SYN_RCVD状态的socket的最大数目，也就是处于半连接状态的socket的上限值。这是由于自Linux内核2.2之后，listen的backlog参数只表示处于完全连接状态的socket的上限\n\n- /proc/sys/net/ipv4/tcp_wmem,包含3个值，分别指定一个socket的TCP写缓冲区的最小值、默认值和最大值\n\n  (我的ubuntu16.04下为4096 16384 4194304)\n\n- /proc/sys/net/ipv4/tcp_rmem,包含3个值，分别指定一个socket的TCP读缓冲区的最小值、默认值和最大值\n\n  可以修改这个参数来改变接收通告窗口的大小(我的ubuntu16.04下为4096 87380 6015840)\n\n- /proc/sys/net/ipv4/tcp_syncookies,指定是否打开TCP同步标签(syncookie)，同步标签通过启动cookie来防止一个监听socket因为不停地接收来自同一个地址的连接请求(同步报文段)，而导致listen监听队列溢出(SYN flood)\n\n除了通过直接修改文件的方式来修改这些系统参数外，也可以使用sysctl命令来修改它们。\n\n但是上面这两种修改方式都是临时的，永久的修改方式是在/etc/sysctl,conf文件中加入相应网络参数及其数值\n\n并执行sysctl -p使之生效。","source":"_posts/服务器内核参数配置.md","raw":"---\ntitle: 服务器内核参数配置\ndate: 2019-04-20 11:59:58\ntags:\n- Linux高性能服务器编程\n---\n\nLinux平台一个优秀的特性就是内核微调，即可以通过修改文件的方式来调整内核参数。记录一些与服务器性能相关的部分内核参数。\n\n几乎所有的内核模块，包括内核核心模块和驱动程序,都在/proc/sys文件系统中提供了某些配置文件以供用户调整模块的属性和行为。通常一个配置文件对应一个内核参数，文件名就是参数的名字，文件的内容就是参数的值。\n\n可以通过 sysctl -a来查看所有的内核参数。\n\n<!--more-->\n\n## 最大文件描述符数\n\nLinux对应用程序能打开的最大文件描述符数量有两个层次的限制：用户级限制和系统级限制。\n\n用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数\n\n系统级限制是指所有用户总共能打开的文件描述符数\n\n\n\nulimit -n  是常用的查看用户级文件描述符限制的方法  默认一般为1024\n\nulimit -SHn max-file-number(自己设定数值)    将用户级文件描述符限制设为max-file-number'\n\n加-H就是硬，加-S就是软，默认显示的是软限制\n\n如果运行ulimit命令修改的时候没有加上这两个选项的话，就是两个参数一起改变。\n\n但是上面的这种设置是临时的，只在当前的session有效\n\n\n\n如果要永久修改用户级文件描述符数限制，可以在/etc/security/limits.conf文件加入两项，然后重启生效：\n\n```\n* soft nofile max-file-number(自己设置数值  32768)\n* hard nofile max-file-number(自己设置数值 65536)\n```\n\n配置文件最前面的是指domain，设置为星号代表全局，另外也可以针对不同的用户做出不同的限制。\n\n注意：这个当中的硬限制是实际的限制，而软限制，是warning限制，只会做出warning\n\n\n\n如果要修改系统级文件描述符限制，可以使用如下命令：\n\nsysctl -w fs.file-max=max-file-number(自己设置数值)  注意后面不能有空格，但是该命令也是临时更改系统限制\n\n系统总限制是在这里,/proc/sys/fs/file-max,可以通过cat查看目前的值\n\n\n\n如果要永久更改系统级文件描述符限制，则需要在/etc/sysctl.conf文件中添加如下一项：\n\nfs.file-max=max-file-number(自己设置数值)\n\n然后通过执行sysctl -p命令使更改生效\n\n\n\n/proc/sys/fs/file-nr，可以看到整个系统目前使用的文件句柄数量。\n\n查找文件句柄问题的时候，还有一个很实用的程序lsof(list open file)。\n\n可以很方便看到某个进程开了那些句柄，也可以看到某个文件/目录被什么进程占用了。\n\n## /proc/sys/fs目录下的部分文件\n\n/proc/sys/fs目录下的内核参数都与文件系统有关。对于服务器程序，比较重要的是\n\n- /proc/sys/fs/file-max，系统级文件描述符数限制，修改方式上面介绍过，一般修改/proc/sys/file-max后，应用程序需要把/proc/sys/fs/inode-max设置为新/proc/sys/fs/file-max值的3~4倍，否则可能导致i节点数不够\n\n- /proc/sys/fs/epoll/max_user_watches,一个用户能够往epoll内核事件表中注册的事件总量。它是指该用户打开的所有epoll实例总共能监听的事件数目，而不是单个epoll实例能监听的事件数目。往epoll内核事件表中注册一个事件，在32位系统上大概消耗90字节的内核空间，在64位系统上消耗160字节的内核空间。所以，这个内核参数限制了epoll使用的内核内存总量。(我的ubuntu16.04默认值为308299)\n\n## /proc/sys/net目录下的部分文件\n\n内核中网络模块的相关参数都位于/proc/sys/net目录下，其中和TCP/IP协议相关的参数主要位于下面三个子目录：core、ipv4和ipv6。\n\n- /proc/sys/net/core/somaxconn。指定listen监听队列中，能够建立完整连接从而进入ESTABLISHED状态的socket最大数目。(我的ubuntu16.04默认值为128)\n- /proc/sys/net/ipv4/tcp_max_syn_backlog。指定listen监听队列中，能够转移到ESTABLISHED状态或者SYN_RCVD状态的socket的最大数目，也就是处于半连接状态的socket的上限值。这是由于自Linux内核2.2之后，listen的backlog参数只表示处于完全连接状态的socket的上限\n\n- /proc/sys/net/ipv4/tcp_wmem,包含3个值，分别指定一个socket的TCP写缓冲区的最小值、默认值和最大值\n\n  (我的ubuntu16.04下为4096 16384 4194304)\n\n- /proc/sys/net/ipv4/tcp_rmem,包含3个值，分别指定一个socket的TCP读缓冲区的最小值、默认值和最大值\n\n  可以修改这个参数来改变接收通告窗口的大小(我的ubuntu16.04下为4096 87380 6015840)\n\n- /proc/sys/net/ipv4/tcp_syncookies,指定是否打开TCP同步标签(syncookie)，同步标签通过启动cookie来防止一个监听socket因为不停地接收来自同一个地址的连接请求(同步报文段)，而导致listen监听队列溢出(SYN flood)\n\n除了通过直接修改文件的方式来修改这些系统参数外，也可以使用sysctl命令来修改它们。\n\n但是上面这两种修改方式都是临时的，永久的修改方式是在/etc/sysctl,conf文件中加入相应网络参数及其数值\n\n并执行sysctl -p使之生效。","slug":"服务器内核参数配置","published":1,"updated":"2021-12-06T05:30:36.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7s001t96ca6w5ocg80","content":"<p>Linux平台一个优秀的特性就是内核微调，即可以通过修改文件的方式来调整内核参数。记录一些与服务器性能相关的部分内核参数。</p>\n<p>几乎所有的内核模块，包括内核核心模块和驱动程序,都在/proc/sys文件系统中提供了某些配置文件以供用户调整模块的属性和行为。通常一个配置文件对应一个内核参数，文件名就是参数的名字，文件的内容就是参数的值。</p>\n<p>可以通过 sysctl -a来查看所有的内核参数。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"最大文件描述符数\"><a href=\"#最大文件描述符数\" class=\"headerlink\" title=\"最大文件描述符数\"></a>最大文件描述符数</h2><p>Linux对应用程序能打开的最大文件描述符数量有两个层次的限制：用户级限制和系统级限制。</p>\n<p>用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数</p>\n<p>系统级限制是指所有用户总共能打开的文件描述符数</p>\n<p>ulimit -n  是常用的查看用户级文件描述符限制的方法  默认一般为1024</p>\n<p>ulimit -SHn max-file-number(自己设定数值)    将用户级文件描述符限制设为max-file-number’</p>\n<p>加-H就是硬，加-S就是软，默认显示的是软限制</p>\n<p>如果运行ulimit命令修改的时候没有加上这两个选项的话，就是两个参数一起改变。</p>\n<p>但是上面的这种设置是临时的，只在当前的session有效</p>\n<p>如果要永久修改用户级文件描述符数限制，可以在/etc/security/limits.conf文件加入两项，然后重启生效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* soft nofile max-file-number(自己设置数值  32768)</span><br><span class=\"line\">* hard nofile max-file-number(自己设置数值 65536)</span><br></pre></td></tr></table></figure>\n\n<p>配置文件最前面的是指domain，设置为星号代表全局，另外也可以针对不同的用户做出不同的限制。</p>\n<p>注意：这个当中的硬限制是实际的限制，而软限制，是warning限制，只会做出warning</p>\n<p>如果要修改系统级文件描述符限制，可以使用如下命令：</p>\n<p>sysctl -w fs.file-max=max-file-number(自己设置数值)  注意后面不能有空格，但是该命令也是临时更改系统限制</p>\n<p>系统总限制是在这里,/proc/sys/fs/file-max,可以通过cat查看目前的值</p>\n<p>如果要永久更改系统级文件描述符限制，则需要在/etc/sysctl.conf文件中添加如下一项：</p>\n<p>fs.file-max=max-file-number(自己设置数值)</p>\n<p>然后通过执行sysctl -p命令使更改生效</p>\n<p>/proc/sys/fs/file-nr，可以看到整个系统目前使用的文件句柄数量。</p>\n<p>查找文件句柄问题的时候，还有一个很实用的程序lsof(list open file)。</p>\n<p>可以很方便看到某个进程开了那些句柄，也可以看到某个文件/目录被什么进程占用了。</p>\n<h2 id=\"proc-sys-fs目录下的部分文件\"><a href=\"#proc-sys-fs目录下的部分文件\" class=\"headerlink\" title=\"/proc/sys/fs目录下的部分文件\"></a>/proc/sys/fs目录下的部分文件</h2><p>/proc/sys/fs目录下的内核参数都与文件系统有关。对于服务器程序，比较重要的是</p>\n<ul>\n<li><p>/proc/sys/fs/file-max，系统级文件描述符数限制，修改方式上面介绍过，一般修改/proc/sys/file-max后，应用程序需要把/proc/sys/fs/inode-max设置为新/proc/sys/fs/file-max值的3~4倍，否则可能导致i节点数不够</p>\n</li>\n<li><p>/proc/sys/fs/epoll/max_user_watches,一个用户能够往epoll内核事件表中注册的事件总量。它是指该用户打开的所有epoll实例总共能监听的事件数目，而不是单个epoll实例能监听的事件数目。往epoll内核事件表中注册一个事件，在32位系统上大概消耗90字节的内核空间，在64位系统上消耗160字节的内核空间。所以，这个内核参数限制了epoll使用的内核内存总量。(我的ubuntu16.04默认值为308299)</p>\n</li>\n</ul>\n<h2 id=\"proc-sys-net目录下的部分文件\"><a href=\"#proc-sys-net目录下的部分文件\" class=\"headerlink\" title=\"/proc/sys/net目录下的部分文件\"></a>/proc/sys/net目录下的部分文件</h2><p>内核中网络模块的相关参数都位于/proc/sys/net目录下，其中和TCP/IP协议相关的参数主要位于下面三个子目录：core、ipv4和ipv6。</p>\n<ul>\n<li><p>/proc/sys/net/core/somaxconn。指定listen监听队列中，能够建立完整连接从而进入ESTABLISHED状态的socket最大数目。(我的ubuntu16.04默认值为128)</p>\n</li>\n<li><p>/proc/sys/net/ipv4/tcp_max_syn_backlog。指定listen监听队列中，能够转移到ESTABLISHED状态或者SYN_RCVD状态的socket的最大数目，也就是处于半连接状态的socket的上限值。这是由于自Linux内核2.2之后，listen的backlog参数只表示处于完全连接状态的socket的上限</p>\n</li>\n<li><p>/proc/sys/net/ipv4/tcp_wmem,包含3个值，分别指定一个socket的TCP写缓冲区的最小值、默认值和最大值</p>\n<p>(我的ubuntu16.04下为4096 16384 4194304)</p>\n</li>\n<li><p>/proc/sys/net/ipv4/tcp_rmem,包含3个值，分别指定一个socket的TCP读缓冲区的最小值、默认值和最大值</p>\n<p>可以修改这个参数来改变接收通告窗口的大小(我的ubuntu16.04下为4096 87380 6015840)</p>\n</li>\n<li><p>/proc/sys/net/ipv4/tcp_syncookies,指定是否打开TCP同步标签(syncookie)，同步标签通过启动cookie来防止一个监听socket因为不停地接收来自同一个地址的连接请求(同步报文段)，而导致listen监听队列溢出(SYN flood)</p>\n</li>\n</ul>\n<p>除了通过直接修改文件的方式来修改这些系统参数外，也可以使用sysctl命令来修改它们。</p>\n<p>但是上面这两种修改方式都是临时的，永久的修改方式是在/etc/sysctl,conf文件中加入相应网络参数及其数值</p>\n<p>并执行sysctl -p使之生效。</p>\n","site":{"data":{}},"excerpt":"<p>Linux平台一个优秀的特性就是内核微调，即可以通过修改文件的方式来调整内核参数。记录一些与服务器性能相关的部分内核参数。</p>\n<p>几乎所有的内核模块，包括内核核心模块和驱动程序,都在/proc/sys文件系统中提供了某些配置文件以供用户调整模块的属性和行为。通常一个配置文件对应一个内核参数，文件名就是参数的名字，文件的内容就是参数的值。</p>\n<p>可以通过 sysctl -a来查看所有的内核参数。</p>","more":"<h2 id=\"最大文件描述符数\"><a href=\"#最大文件描述符数\" class=\"headerlink\" title=\"最大文件描述符数\"></a>最大文件描述符数</h2><p>Linux对应用程序能打开的最大文件描述符数量有两个层次的限制：用户级限制和系统级限制。</p>\n<p>用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数</p>\n<p>系统级限制是指所有用户总共能打开的文件描述符数</p>\n<p>ulimit -n  是常用的查看用户级文件描述符限制的方法  默认一般为1024</p>\n<p>ulimit -SHn max-file-number(自己设定数值)    将用户级文件描述符限制设为max-file-number’</p>\n<p>加-H就是硬，加-S就是软，默认显示的是软限制</p>\n<p>如果运行ulimit命令修改的时候没有加上这两个选项的话，就是两个参数一起改变。</p>\n<p>但是上面的这种设置是临时的，只在当前的session有效</p>\n<p>如果要永久修改用户级文件描述符数限制，可以在/etc/security/limits.conf文件加入两项，然后重启生效：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* soft nofile max-file-number(自己设置数值  32768)</span><br><span class=\"line\">* hard nofile max-file-number(自己设置数值 65536)</span><br></pre></td></tr></table></figure>\n\n<p>配置文件最前面的是指domain，设置为星号代表全局，另外也可以针对不同的用户做出不同的限制。</p>\n<p>注意：这个当中的硬限制是实际的限制，而软限制，是warning限制，只会做出warning</p>\n<p>如果要修改系统级文件描述符限制，可以使用如下命令：</p>\n<p>sysctl -w fs.file-max=max-file-number(自己设置数值)  注意后面不能有空格，但是该命令也是临时更改系统限制</p>\n<p>系统总限制是在这里,/proc/sys/fs/file-max,可以通过cat查看目前的值</p>\n<p>如果要永久更改系统级文件描述符限制，则需要在/etc/sysctl.conf文件中添加如下一项：</p>\n<p>fs.file-max=max-file-number(自己设置数值)</p>\n<p>然后通过执行sysctl -p命令使更改生效</p>\n<p>/proc/sys/fs/file-nr，可以看到整个系统目前使用的文件句柄数量。</p>\n<p>查找文件句柄问题的时候，还有一个很实用的程序lsof(list open file)。</p>\n<p>可以很方便看到某个进程开了那些句柄，也可以看到某个文件/目录被什么进程占用了。</p>\n<h2 id=\"proc-sys-fs目录下的部分文件\"><a href=\"#proc-sys-fs目录下的部分文件\" class=\"headerlink\" title=\"/proc/sys/fs目录下的部分文件\"></a>/proc/sys/fs目录下的部分文件</h2><p>/proc/sys/fs目录下的内核参数都与文件系统有关。对于服务器程序，比较重要的是</p>\n<ul>\n<li><p>/proc/sys/fs/file-max，系统级文件描述符数限制，修改方式上面介绍过，一般修改/proc/sys/file-max后，应用程序需要把/proc/sys/fs/inode-max设置为新/proc/sys/fs/file-max值的3~4倍，否则可能导致i节点数不够</p>\n</li>\n<li><p>/proc/sys/fs/epoll/max_user_watches,一个用户能够往epoll内核事件表中注册的事件总量。它是指该用户打开的所有epoll实例总共能监听的事件数目，而不是单个epoll实例能监听的事件数目。往epoll内核事件表中注册一个事件，在32位系统上大概消耗90字节的内核空间，在64位系统上消耗160字节的内核空间。所以，这个内核参数限制了epoll使用的内核内存总量。(我的ubuntu16.04默认值为308299)</p>\n</li>\n</ul>\n<h2 id=\"proc-sys-net目录下的部分文件\"><a href=\"#proc-sys-net目录下的部分文件\" class=\"headerlink\" title=\"/proc/sys/net目录下的部分文件\"></a>/proc/sys/net目录下的部分文件</h2><p>内核中网络模块的相关参数都位于/proc/sys/net目录下，其中和TCP/IP协议相关的参数主要位于下面三个子目录：core、ipv4和ipv6。</p>\n<ul>\n<li><p>/proc/sys/net/core/somaxconn。指定listen监听队列中，能够建立完整连接从而进入ESTABLISHED状态的socket最大数目。(我的ubuntu16.04默认值为128)</p>\n</li>\n<li><p>/proc/sys/net/ipv4/tcp_max_syn_backlog。指定listen监听队列中，能够转移到ESTABLISHED状态或者SYN_RCVD状态的socket的最大数目，也就是处于半连接状态的socket的上限值。这是由于自Linux内核2.2之后，listen的backlog参数只表示处于完全连接状态的socket的上限</p>\n</li>\n<li><p>/proc/sys/net/ipv4/tcp_wmem,包含3个值，分别指定一个socket的TCP写缓冲区的最小值、默认值和最大值</p>\n<p>(我的ubuntu16.04下为4096 16384 4194304)</p>\n</li>\n<li><p>/proc/sys/net/ipv4/tcp_rmem,包含3个值，分别指定一个socket的TCP读缓冲区的最小值、默认值和最大值</p>\n<p>可以修改这个参数来改变接收通告窗口的大小(我的ubuntu16.04下为4096 87380 6015840)</p>\n</li>\n<li><p>/proc/sys/net/ipv4/tcp_syncookies,指定是否打开TCP同步标签(syncookie)，同步标签通过启动cookie来防止一个监听socket因为不停地接收来自同一个地址的连接请求(同步报文段)，而导致listen监听队列溢出(SYN flood)</p>\n</li>\n</ul>\n<p>除了通过直接修改文件的方式来修改这些系统参数外，也可以使用sysctl命令来修改它们。</p>\n<p>但是上面这两种修改方式都是临时的，永久的修改方式是在/etc/sysctl,conf文件中加入相应网络参数及其数值</p>\n<p>并执行sysctl -p使之生效。</p>"},{"title":"模板方法","date":"2019-04-26T09:59:10.000Z","_content":"\n#### “组件协作”模式\n\n现代软件专业分工之后的第一个结果就是“框架和应用程序的划分”，“组件协作”模式通过晚绑定，实现框架和应用程序之间的松耦合，是两者之间协作时常用的模式。\n\n典型模式有：\n\n- Template Method\n- Strategy\n- Observer\n\n<!--more-->\n\n#### Template Method\n\n模式定义：\n\n定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(重写)该算法的某些特定步骤。\n\n应用场景：\n\n在软件构建过程中，对于某一项任务，它常常有稳定的整体结构，但各个子步骤却有很多改变的需求(某一特定的业务逻辑在不同的对象中有不同的细节实现)。\n\n实例演示：\n\n没有应用设计模式的做法\n\n```\nclass Library{   //程序库开发人员\npublic:\n\tvoid step1(){\n        //...\n\t}\n\tvoid step3(){\n        //...\n\t}\n\tvoid step5(){\n        //...\n\t}\n};\n\nclass Application{  //应用程序开发人员\npublic:\n\tbool step2(){\n        //...\n\t}\n\tvoid step4(){\n        //...\n\t}\n};\n\nint main(){\n    Library lib;\n    Application app;\n    \n    //整体框架 流程\n    lib.step1();\n    if(app.step2())\n    \tlib.step3();\n    for(int i = 0;i<4;i++)\n    \tapp.step4();\n    \n    lib.step5();\n    \n    return 0;\n}\n```\n\n应用模板方法的做法\n\n```\nclass Library{   //程序库开发人员\npublic:\n\tvoid Run(){  //稳定 template method\n    \tstep1();\n    \tif(step2()) //支持变化==>虚函数的多态调用\n    \t\tstep3();\n    \tfor(int i = 0;i<4;i++)\n    \t\tstep4(); //支持变化==>虚函数的多态调用\n \t\tstep5();  \n\t}\n\tvirtual ~Library(){}\nprotected:\n\tvoid step1(){//稳定\n        //...\n\t}\n\tvoid step3(){//稳定\n        //...\n\t}\n\tvoid step5(){//稳定\n        //...\n\t}\n\tvirtual bool step2() = 0; //变化\n\tvirtual void step4() = 0; //变化\n};\n\nclass Application:public Library{  //应用程序开发人员\npublic:\n\tvirtual bool step2(){\n        //...子类重写实现\n\t}\n\tvirtual void step4(){\n        //...子类重写实现\n\t}\n};\n\nint main(){\n\tLibrary* plib = new Application;\n\tplib->Run();\n   \t\n   \tdelete plib;\n\n    return 0;\n}\n```\n\n对于做法一的流程(结构化设计流程)：\n\n![](/pic/模板方法1.png)\n\n对于做法二的流程：\n\n![](/pic/模板方法2.png)\n\n本质的变化：\n\n![](/pic/模板方法3.png)\n\n对于Library来说，肯定是早出现的，而Application出现的晚，对于一个早的东西调用一个晚的东西就是晚绑定。\n\n#### 模式类图\n\n![](/pic/模板方法类图.png)\n\n这里的TemplateMethod就是上面的Run\n\nPrimitiveOperation1就是step2\n\nPrimitiveOperation2就是step4\n\n省略了step1,step3,step5\n\n#### 模式总结\n\n- 用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构\n- 除了可以灵活应对子步骤的变化外，\"不要调用我，让我来调用你\"的反向控制结构是Template Method的典型应用\n- 在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现，但一般推荐将它们设置为protected方法","source":"_posts/模板方法.md","raw":"---\ntitle: 模板方法\ndate: 2019-04-26 17:59:10\ntags:\n- 设计模式\n---\n\n#### “组件协作”模式\n\n现代软件专业分工之后的第一个结果就是“框架和应用程序的划分”，“组件协作”模式通过晚绑定，实现框架和应用程序之间的松耦合，是两者之间协作时常用的模式。\n\n典型模式有：\n\n- Template Method\n- Strategy\n- Observer\n\n<!--more-->\n\n#### Template Method\n\n模式定义：\n\n定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(重写)该算法的某些特定步骤。\n\n应用场景：\n\n在软件构建过程中，对于某一项任务，它常常有稳定的整体结构，但各个子步骤却有很多改变的需求(某一特定的业务逻辑在不同的对象中有不同的细节实现)。\n\n实例演示：\n\n没有应用设计模式的做法\n\n```\nclass Library{   //程序库开发人员\npublic:\n\tvoid step1(){\n        //...\n\t}\n\tvoid step3(){\n        //...\n\t}\n\tvoid step5(){\n        //...\n\t}\n};\n\nclass Application{  //应用程序开发人员\npublic:\n\tbool step2(){\n        //...\n\t}\n\tvoid step4(){\n        //...\n\t}\n};\n\nint main(){\n    Library lib;\n    Application app;\n    \n    //整体框架 流程\n    lib.step1();\n    if(app.step2())\n    \tlib.step3();\n    for(int i = 0;i<4;i++)\n    \tapp.step4();\n    \n    lib.step5();\n    \n    return 0;\n}\n```\n\n应用模板方法的做法\n\n```\nclass Library{   //程序库开发人员\npublic:\n\tvoid Run(){  //稳定 template method\n    \tstep1();\n    \tif(step2()) //支持变化==>虚函数的多态调用\n    \t\tstep3();\n    \tfor(int i = 0;i<4;i++)\n    \t\tstep4(); //支持变化==>虚函数的多态调用\n \t\tstep5();  \n\t}\n\tvirtual ~Library(){}\nprotected:\n\tvoid step1(){//稳定\n        //...\n\t}\n\tvoid step3(){//稳定\n        //...\n\t}\n\tvoid step5(){//稳定\n        //...\n\t}\n\tvirtual bool step2() = 0; //变化\n\tvirtual void step4() = 0; //变化\n};\n\nclass Application:public Library{  //应用程序开发人员\npublic:\n\tvirtual bool step2(){\n        //...子类重写实现\n\t}\n\tvirtual void step4(){\n        //...子类重写实现\n\t}\n};\n\nint main(){\n\tLibrary* plib = new Application;\n\tplib->Run();\n   \t\n   \tdelete plib;\n\n    return 0;\n}\n```\n\n对于做法一的流程(结构化设计流程)：\n\n![](/pic/模板方法1.png)\n\n对于做法二的流程：\n\n![](/pic/模板方法2.png)\n\n本质的变化：\n\n![](/pic/模板方法3.png)\n\n对于Library来说，肯定是早出现的，而Application出现的晚，对于一个早的东西调用一个晚的东西就是晚绑定。\n\n#### 模式类图\n\n![](/pic/模板方法类图.png)\n\n这里的TemplateMethod就是上面的Run\n\nPrimitiveOperation1就是step2\n\nPrimitiveOperation2就是step4\n\n省略了step1,step3,step5\n\n#### 模式总结\n\n- 用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构\n- 除了可以灵活应对子步骤的变化外，\"不要调用我，让我来调用你\"的反向控制结构是Template Method的典型应用\n- 在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现，但一般推荐将它们设置为protected方法","slug":"模板方法","published":1,"updated":"2021-12-06T05:30:36.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7s001w96ca14meftok","content":"<h4 id=\"“组件协作”模式\"><a href=\"#“组件协作”模式\" class=\"headerlink\" title=\"“组件协作”模式\"></a>“组件协作”模式</h4><p>现代软件专业分工之后的第一个结果就是“框架和应用程序的划分”，“组件协作”模式通过晚绑定，实现框架和应用程序之间的松耦合，是两者之间协作时常用的模式。</p>\n<p>典型模式有：</p>\n<ul>\n<li>Template Method</li>\n<li>Strategy</li>\n<li>Observer</li>\n</ul>\n<a id=\"more\"></a>\n\n<h4 id=\"Template-Method\"><a href=\"#Template-Method\" class=\"headerlink\" title=\"Template Method\"></a>Template Method</h4><p>模式定义：</p>\n<p>定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(重写)该算法的某些特定步骤。</p>\n<p>应用场景：</p>\n<p>在软件构建过程中，对于某一项任务，它常常有稳定的整体结构，但各个子步骤却有很多改变的需求(某一特定的业务逻辑在不同的对象中有不同的细节实现)。</p>\n<p>实例演示：</p>\n<p>没有应用设计模式的做法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Library&#123;   &#x2F;&#x2F;程序库开发人员</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid step1()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step3()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step5()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Application&#123;  &#x2F;&#x2F;应用程序开发人员</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tbool step2()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step4()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Library lib;</span><br><span class=\"line\">    Application app;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;整体框架 流程</span><br><span class=\"line\">    lib.step1();</span><br><span class=\"line\">    if(app.step2())</span><br><span class=\"line\">    \tlib.step3();</span><br><span class=\"line\">    for(int i &#x3D; 0;i&lt;4;i++)</span><br><span class=\"line\">    \tapp.step4();</span><br><span class=\"line\">    </span><br><span class=\"line\">    lib.step5();</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>应用模板方法的做法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Library&#123;   &#x2F;&#x2F;程序库开发人员</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid Run()&#123;  &#x2F;&#x2F;稳定 template method</span><br><span class=\"line\">    \tstep1();</span><br><span class=\"line\">    \tif(step2()) &#x2F;&#x2F;支持变化&#x3D;&#x3D;&gt;虚函数的多态调用</span><br><span class=\"line\">    \t\tstep3();</span><br><span class=\"line\">    \tfor(int i &#x3D; 0;i&lt;4;i++)</span><br><span class=\"line\">    \t\tstep4(); &#x2F;&#x2F;支持变化&#x3D;&#x3D;&gt;虚函数的多态调用</span><br><span class=\"line\"> \t\tstep5();  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual ~Library()&#123;&#125;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid step1()&#123;&#x2F;&#x2F;稳定</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step3()&#123;&#x2F;&#x2F;稳定</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step5()&#123;&#x2F;&#x2F;稳定</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual bool step2() &#x3D; 0; &#x2F;&#x2F;变化</span><br><span class=\"line\">\tvirtual void step4() &#x3D; 0; &#x2F;&#x2F;变化</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Application:public Library&#123;  &#x2F;&#x2F;应用程序开发人员</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual bool step2()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...子类重写实现</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual void step4()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...子类重写实现</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">\tLibrary* plib &#x3D; new Application;</span><br><span class=\"line\">\tplib-&gt;Run();</span><br><span class=\"line\">   \t</span><br><span class=\"line\">   \tdelete plib;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于做法一的流程(结构化设计流程)：</p>\n<p><img src=\"/pic/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%951.png\" alt=\"\"></p>\n<p>对于做法二的流程：</p>\n<p><img src=\"/pic/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%952.png\" alt=\"\"></p>\n<p>本质的变化：</p>\n<p><img src=\"/pic/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%953.png\" alt=\"\"></p>\n<p>对于Library来说，肯定是早出现的，而Application出现的晚，对于一个早的东西调用一个晚的东西就是晚绑定。</p>\n<h4 id=\"模式类图\"><a href=\"#模式类图\" class=\"headerlink\" title=\"模式类图\"></a>模式类图</h4><p><img src=\"/pic/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9B%BE.png\" alt=\"\"></p>\n<p>这里的TemplateMethod就是上面的Run</p>\n<p>PrimitiveOperation1就是step2</p>\n<p>PrimitiveOperation2就是step4</p>\n<p>省略了step1,step3,step5</p>\n<h4 id=\"模式总结\"><a href=\"#模式总结\" class=\"headerlink\" title=\"模式总结\"></a>模式总结</h4><ul>\n<li>用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构</li>\n<li>除了可以灵活应对子步骤的变化外，”不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用</li>\n<li>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现，但一般推荐将它们设置为protected方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"“组件协作”模式\"><a href=\"#“组件协作”模式\" class=\"headerlink\" title=\"“组件协作”模式\"></a>“组件协作”模式</h4><p>现代软件专业分工之后的第一个结果就是“框架和应用程序的划分”，“组件协作”模式通过晚绑定，实现框架和应用程序之间的松耦合，是两者之间协作时常用的模式。</p>\n<p>典型模式有：</p>\n<ul>\n<li>Template Method</li>\n<li>Strategy</li>\n<li>Observer</li>\n</ul>","more":"<h4 id=\"Template-Method\"><a href=\"#Template-Method\" class=\"headerlink\" title=\"Template Method\"></a>Template Method</h4><p>模式定义：</p>\n<p>定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(重写)该算法的某些特定步骤。</p>\n<p>应用场景：</p>\n<p>在软件构建过程中，对于某一项任务，它常常有稳定的整体结构，但各个子步骤却有很多改变的需求(某一特定的业务逻辑在不同的对象中有不同的细节实现)。</p>\n<p>实例演示：</p>\n<p>没有应用设计模式的做法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Library&#123;   &#x2F;&#x2F;程序库开发人员</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid step1()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step3()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step5()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Application&#123;  &#x2F;&#x2F;应用程序开发人员</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tbool step2()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step4()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    Library lib;</span><br><span class=\"line\">    Application app;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;整体框架 流程</span><br><span class=\"line\">    lib.step1();</span><br><span class=\"line\">    if(app.step2())</span><br><span class=\"line\">    \tlib.step3();</span><br><span class=\"line\">    for(int i &#x3D; 0;i&lt;4;i++)</span><br><span class=\"line\">    \tapp.step4();</span><br><span class=\"line\">    </span><br><span class=\"line\">    lib.step5();</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>应用模板方法的做法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Library&#123;   &#x2F;&#x2F;程序库开发人员</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid Run()&#123;  &#x2F;&#x2F;稳定 template method</span><br><span class=\"line\">    \tstep1();</span><br><span class=\"line\">    \tif(step2()) &#x2F;&#x2F;支持变化&#x3D;&#x3D;&gt;虚函数的多态调用</span><br><span class=\"line\">    \t\tstep3();</span><br><span class=\"line\">    \tfor(int i &#x3D; 0;i&lt;4;i++)</span><br><span class=\"line\">    \t\tstep4(); &#x2F;&#x2F;支持变化&#x3D;&#x3D;&gt;虚函数的多态调用</span><br><span class=\"line\"> \t\tstep5();  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual ~Library()&#123;&#125;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tvoid step1()&#123;&#x2F;&#x2F;稳定</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step3()&#123;&#x2F;&#x2F;稳定</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid step5()&#123;&#x2F;&#x2F;稳定</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual bool step2() &#x3D; 0; &#x2F;&#x2F;变化</span><br><span class=\"line\">\tvirtual void step4() &#x3D; 0; &#x2F;&#x2F;变化</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Application:public Library&#123;  &#x2F;&#x2F;应用程序开发人员</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual bool step2()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...子类重写实现</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual void step4()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...子类重写实现</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">\tLibrary* plib &#x3D; new Application;</span><br><span class=\"line\">\tplib-&gt;Run();</span><br><span class=\"line\">   \t</span><br><span class=\"line\">   \tdelete plib;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于做法一的流程(结构化设计流程)：</p>\n<p><img src=\"/pic/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%951.png\" alt=\"\"></p>\n<p>对于做法二的流程：</p>\n<p><img src=\"/pic/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%952.png\" alt=\"\"></p>\n<p>本质的变化：</p>\n<p><img src=\"/pic/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%953.png\" alt=\"\"></p>\n<p>对于Library来说，肯定是早出现的，而Application出现的晚，对于一个早的东西调用一个晚的东西就是晚绑定。</p>\n<h4 id=\"模式类图\"><a href=\"#模式类图\" class=\"headerlink\" title=\"模式类图\"></a>模式类图</h4><p><img src=\"/pic/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9B%BE.png\" alt=\"\"></p>\n<p>这里的TemplateMethod就是上面的Run</p>\n<p>PrimitiveOperation1就是step2</p>\n<p>PrimitiveOperation2就是step4</p>\n<p>省略了step1,step3,step5</p>\n<h4 id=\"模式总结\"><a href=\"#模式总结\" class=\"headerlink\" title=\"模式总结\"></a>模式总结</h4><ul>\n<li>用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构</li>\n<li>除了可以灵活应对子步骤的变化外，”不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用</li>\n<li>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现，但一般推荐将它们设置为protected方法</li>\n</ul>"},{"title":"禁止拷贝构造和赋值","date":"2019-04-23T12:23:02.000Z","_content":"\n在某些特定的场合，对于某些类我们不希望类对象产生副本，也就是不能调用拷贝构造和赋值运算符。\n\n例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。\n\n在研究muduo库Mutex文件的发现继承了一个noncopyable类，就能达成上面的作用。\n\n查了一下，发现这是《Effective C++》中的条款6：若不想使用编译器自动生成的函数，就该明确拒绝。\n\n<!--more-->\n\n首先我们需要知道，如果定义一个空类，编译器会自动帮我们声明：\n\n- default无参构造函数\n- 析构函数\n- 拷贝构造函数\n- 赋值操作符重载函数\n\n并且这些函数都是public且inline的，只有当这些函数被调用的时候，它们才被编译器创建出来。\n\n因此，如果不在类中定义拷贝构造函数和赋值运算符，我们尝试调用它们的时候，编译器会帮我们声明，不能达到我们想要的目的。\n\n## 把要禁止的函数声明为private\n\n问题的关键是，编译器声明的函数都是public的，要阻止这些函数被创建，需要自行声明它们为private。但是这种做法不是绝对安全，因为类成员函数和友元函数还是可以调用private函数，因此可以不去实现它们。\n\n小技巧：把要禁止的函数声明为private，并且故意不去实现它们。当别处调用这个函数的时候，就会得到一个链接期的错误(无法解析的外部符号XXXX)。\n\n```\nclass Test{\nprivate:\n\tTest(const Test&);\n    Test& operater=(const Test&);    //只有声明\npublic:\n\t...\n};\n```\n\n## 专门声明一个阻止拷贝动作的类\n\n这样做的好处在于将连接期的错误移至编译期，因为越早侦测出错误越好。\n\n```\nclass Uncopyable{\nprotected:\n\tUncopyable(){}                         //允许derived对象构造和析构\n\t~Uncopyable(){}\nprivate:\n\tUncopyable(const Uncopyable&);          //但是阻止copying\n\tUncopyable& operator=(const Uncopyable&);\n};\n\nclass Test:private Uncopyable{   //private不加  默认private\n    ...\n}\n```\n\n无论是类外部、类成员函数还是友元函数进行对象拷贝操作，编译期都会试着生成一个拷贝构造函数和一个赋值操作符，但是由于继承，这两个函数会尝试调用其基类的对应兄弟，可是基类中这两个函数是private，因此调用会被编译期拒绝。\n\n## C++11的做法(C++ Primer p449)\n\n```\nclass noncopyable{\nprotected:\n\tnoncopyable() = default;                       //允许derived对象构造和析构\n\t~noncopyable() = default;\npublic:\n\tnoncopyable(const Uncopyable&) = delete;          //但是阻止copying\n\tnoncopyable& operator=(const Uncopyable&) = delete;\n};\nclass Test:private noncopyable{   //private不加  默认private\n    ...\n}\n```\n\n","source":"_posts/禁止拷贝构造和赋值.md","raw":"---\ntitle: 禁止拷贝构造和赋值\ndate: 2019-04-23 20:23:02\ntags:\n- C++\n- Effective C++\n---\n\n在某些特定的场合，对于某些类我们不希望类对象产生副本，也就是不能调用拷贝构造和赋值运算符。\n\n例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。\n\n在研究muduo库Mutex文件的发现继承了一个noncopyable类，就能达成上面的作用。\n\n查了一下，发现这是《Effective C++》中的条款6：若不想使用编译器自动生成的函数，就该明确拒绝。\n\n<!--more-->\n\n首先我们需要知道，如果定义一个空类，编译器会自动帮我们声明：\n\n- default无参构造函数\n- 析构函数\n- 拷贝构造函数\n- 赋值操作符重载函数\n\n并且这些函数都是public且inline的，只有当这些函数被调用的时候，它们才被编译器创建出来。\n\n因此，如果不在类中定义拷贝构造函数和赋值运算符，我们尝试调用它们的时候，编译器会帮我们声明，不能达到我们想要的目的。\n\n## 把要禁止的函数声明为private\n\n问题的关键是，编译器声明的函数都是public的，要阻止这些函数被创建，需要自行声明它们为private。但是这种做法不是绝对安全，因为类成员函数和友元函数还是可以调用private函数，因此可以不去实现它们。\n\n小技巧：把要禁止的函数声明为private，并且故意不去实现它们。当别处调用这个函数的时候，就会得到一个链接期的错误(无法解析的外部符号XXXX)。\n\n```\nclass Test{\nprivate:\n\tTest(const Test&);\n    Test& operater=(const Test&);    //只有声明\npublic:\n\t...\n};\n```\n\n## 专门声明一个阻止拷贝动作的类\n\n这样做的好处在于将连接期的错误移至编译期，因为越早侦测出错误越好。\n\n```\nclass Uncopyable{\nprotected:\n\tUncopyable(){}                         //允许derived对象构造和析构\n\t~Uncopyable(){}\nprivate:\n\tUncopyable(const Uncopyable&);          //但是阻止copying\n\tUncopyable& operator=(const Uncopyable&);\n};\n\nclass Test:private Uncopyable{   //private不加  默认private\n    ...\n}\n```\n\n无论是类外部、类成员函数还是友元函数进行对象拷贝操作，编译期都会试着生成一个拷贝构造函数和一个赋值操作符，但是由于继承，这两个函数会尝试调用其基类的对应兄弟，可是基类中这两个函数是private，因此调用会被编译期拒绝。\n\n## C++11的做法(C++ Primer p449)\n\n```\nclass noncopyable{\nprotected:\n\tnoncopyable() = default;                       //允许derived对象构造和析构\n\t~noncopyable() = default;\npublic:\n\tnoncopyable(const Uncopyable&) = delete;          //但是阻止copying\n\tnoncopyable& operator=(const Uncopyable&) = delete;\n};\nclass Test:private noncopyable{   //private不加  默认private\n    ...\n}\n```\n\n","slug":"禁止拷贝构造和赋值","published":1,"updated":"2021-12-06T05:30:36.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7t001y96ca6ezbgxi6","content":"<p>在某些特定的场合，对于某些类我们不希望类对象产生副本，也就是不能调用拷贝构造和赋值运算符。</p>\n<p>例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。</p>\n<p>在研究muduo库Mutex文件的发现继承了一个noncopyable类，就能达成上面的作用。</p>\n<p>查了一下，发现这是《Effective C++》中的条款6：若不想使用编译器自动生成的函数，就该明确拒绝。</p>\n<a id=\"more\"></a>\n\n<p>首先我们需要知道，如果定义一个空类，编译器会自动帮我们声明：</p>\n<ul>\n<li>default无参构造函数</li>\n<li>析构函数</li>\n<li>拷贝构造函数</li>\n<li>赋值操作符重载函数</li>\n</ul>\n<p>并且这些函数都是public且inline的，只有当这些函数被调用的时候，它们才被编译器创建出来。</p>\n<p>因此，如果不在类中定义拷贝构造函数和赋值运算符，我们尝试调用它们的时候，编译器会帮我们声明，不能达到我们想要的目的。</p>\n<h2 id=\"把要禁止的函数声明为private\"><a href=\"#把要禁止的函数声明为private\" class=\"headerlink\" title=\"把要禁止的函数声明为private\"></a>把要禁止的函数声明为private</h2><p>问题的关键是，编译器声明的函数都是public的，要阻止这些函数被创建，需要自行声明它们为private。但是这种做法不是绝对安全，因为类成员函数和友元函数还是可以调用private函数，因此可以不去实现它们。</p>\n<p>小技巧：把要禁止的函数声明为private，并且故意不去实现它们。当别处调用这个函数的时候，就会得到一个链接期的错误(无法解析的外部符号XXXX)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tTest(const Test&amp;);</span><br><span class=\"line\">    Test&amp; operater&#x3D;(const Test&amp;);    &#x2F;&#x2F;只有声明</span><br><span class=\"line\">public:</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"专门声明一个阻止拷贝动作的类\"><a href=\"#专门声明一个阻止拷贝动作的类\" class=\"headerlink\" title=\"专门声明一个阻止拷贝动作的类\"></a>专门声明一个阻止拷贝动作的类</h2><p>这样做的好处在于将连接期的错误移至编译期，因为越早侦测出错误越好。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Uncopyable&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tUncopyable()&#123;&#125;                         &#x2F;&#x2F;允许derived对象构造和析构</span><br><span class=\"line\">\t~Uncopyable()&#123;&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tUncopyable(const Uncopyable&amp;);          &#x2F;&#x2F;但是阻止copying</span><br><span class=\"line\">\tUncopyable&amp; operator&#x3D;(const Uncopyable&amp;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Test:private Uncopyable&#123;   &#x2F;&#x2F;private不加  默认private</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无论是类外部、类成员函数还是友元函数进行对象拷贝操作，编译期都会试着生成一个拷贝构造函数和一个赋值操作符，但是由于继承，这两个函数会尝试调用其基类的对应兄弟，可是基类中这两个函数是private，因此调用会被编译期拒绝。</p>\n<h2 id=\"C-11的做法-C-Primer-p449\"><a href=\"#C-11的做法-C-Primer-p449\" class=\"headerlink\" title=\"C++11的做法(C++ Primer p449)\"></a>C++11的做法(C++ Primer p449)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class noncopyable&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tnoncopyable() &#x3D; default;                       &#x2F;&#x2F;允许derived对象构造和析构</span><br><span class=\"line\">\t~noncopyable() &#x3D; default;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tnoncopyable(const Uncopyable&amp;) &#x3D; delete;          &#x2F;&#x2F;但是阻止copying</span><br><span class=\"line\">\tnoncopyable&amp; operator&#x3D;(const Uncopyable&amp;) &#x3D; delete;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Test:private noncopyable&#123;   &#x2F;&#x2F;private不加  默认private</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>在某些特定的场合，对于某些类我们不希望类对象产生副本，也就是不能调用拷贝构造和赋值运算符。</p>\n<p>例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。</p>\n<p>在研究muduo库Mutex文件的发现继承了一个noncopyable类，就能达成上面的作用。</p>\n<p>查了一下，发现这是《Effective C++》中的条款6：若不想使用编译器自动生成的函数，就该明确拒绝。</p>","more":"<p>首先我们需要知道，如果定义一个空类，编译器会自动帮我们声明：</p>\n<ul>\n<li>default无参构造函数</li>\n<li>析构函数</li>\n<li>拷贝构造函数</li>\n<li>赋值操作符重载函数</li>\n</ul>\n<p>并且这些函数都是public且inline的，只有当这些函数被调用的时候，它们才被编译器创建出来。</p>\n<p>因此，如果不在类中定义拷贝构造函数和赋值运算符，我们尝试调用它们的时候，编译器会帮我们声明，不能达到我们想要的目的。</p>\n<h2 id=\"把要禁止的函数声明为private\"><a href=\"#把要禁止的函数声明为private\" class=\"headerlink\" title=\"把要禁止的函数声明为private\"></a>把要禁止的函数声明为private</h2><p>问题的关键是，编译器声明的函数都是public的，要阻止这些函数被创建，需要自行声明它们为private。但是这种做法不是绝对安全，因为类成员函数和友元函数还是可以调用private函数，因此可以不去实现它们。</p>\n<p>小技巧：把要禁止的函数声明为private，并且故意不去实现它们。当别处调用这个函数的时候，就会得到一个链接期的错误(无法解析的外部符号XXXX)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tTest(const Test&amp;);</span><br><span class=\"line\">    Test&amp; operater&#x3D;(const Test&amp;);    &#x2F;&#x2F;只有声明</span><br><span class=\"line\">public:</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"专门声明一个阻止拷贝动作的类\"><a href=\"#专门声明一个阻止拷贝动作的类\" class=\"headerlink\" title=\"专门声明一个阻止拷贝动作的类\"></a>专门声明一个阻止拷贝动作的类</h2><p>这样做的好处在于将连接期的错误移至编译期，因为越早侦测出错误越好。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Uncopyable&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tUncopyable()&#123;&#125;                         &#x2F;&#x2F;允许derived对象构造和析构</span><br><span class=\"line\">\t~Uncopyable()&#123;&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tUncopyable(const Uncopyable&amp;);          &#x2F;&#x2F;但是阻止copying</span><br><span class=\"line\">\tUncopyable&amp; operator&#x3D;(const Uncopyable&amp;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Test:private Uncopyable&#123;   &#x2F;&#x2F;private不加  默认private</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无论是类外部、类成员函数还是友元函数进行对象拷贝操作，编译期都会试着生成一个拷贝构造函数和一个赋值操作符，但是由于继承，这两个函数会尝试调用其基类的对应兄弟，可是基类中这两个函数是private，因此调用会被编译期拒绝。</p>\n<h2 id=\"C-11的做法-C-Primer-p449\"><a href=\"#C-11的做法-C-Primer-p449\" class=\"headerlink\" title=\"C++11的做法(C++ Primer p449)\"></a>C++11的做法(C++ Primer p449)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class noncopyable&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tnoncopyable() &#x3D; default;                       &#x2F;&#x2F;允许derived对象构造和析构</span><br><span class=\"line\">\t~noncopyable() &#x3D; default;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tnoncopyable(const Uncopyable&amp;) &#x3D; delete;          &#x2F;&#x2F;但是阻止copying</span><br><span class=\"line\">\tnoncopyable&amp; operator&#x3D;(const Uncopyable&amp;) &#x3D; delete;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Test:private noncopyable&#123;   &#x2F;&#x2F;private不加  默认private</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"汉诺塔问题","date":"2018-10-04T07:48:42.000Z","_content":"\n## 问题描述\n有a,b,c三根柱子，如今柱子a上面有64个盘子(盘子大小从上到下按大小排列)\n目的:将柱子a上面的盘子全部移动到柱子c上面，列出方法和次数\n规则: 1. 每次只能移动一个盘子     2. 小盘子只能放在大盘子之上\n\n这是一道很经典的题目，问题描述也很简单，用递归做起来也比较简单，但不是很好理解\n\n![](/pic/汉诺塔.png)\n\n## 分析\n算法一直是我的软肋，尤其是涉及递归的更加不好理解(为何如此之菜，哎)\n一上来碰到这种问题肯定没什么思路，机智如我就开始找规律嘛\n64个太多,那就从1个开始吧。\n1个 a->c 1次\n2个 a->b a->c b->c 3次\n3个 a->c a->b c->b a->c b->a b->c a->c  7次\n这时候根据我多年找规律的经验就可以大胆地猜测 总的次数是2^n-1\n那64个的话应该是2^64-1(**天文数字 根本不可能完成的任务**)\n虽然猜出了次数(毫无理论依据,逃)，但是还是不知道移动的次序。\n\n## 问题分解\n从第一步开始想大概率是毫无头绪的，因为你有无数种选择。那么倒推着\n想。首先假设已经成功将a柱上面的63个盘子移到了b柱，此时只要将a柱\n最后一个盘子移动到c柱，这是确定的。\n这时候问题就变成了，如何将b柱上63个盘子移动到c。这和之前的问题一模\n一样，只不过数据规模变小了，并且是从a变到了b。因此可以采用一个的思\n考方法，先将b上面的62个盘子移到a，再将最下面的盘子移到c，以此类推\n就有了解决问题的一个循环的流程。\n## 递归\n以上的流程就是一个递归的过程。我所理解的递归就是有不断地用更小规模的\n数据去求上层数据，当然必须有一个终止的时刻返回。\n\n## 代码展示\n```\ndef fun(n,a,b,c):  #n代表数据规模  a,b,c是三个柱子  从a->c\n    if n == 1:\n        print(a,'->',c)\n    else:\n        fun(n-1,a,c,b)  #第一步把n-1个数据从a->b\n        print(a,'->',c) #第二步把第n个数组从a->c\n        fun(n-1,b,a,c)  #这时候问题规模下降1 变成n-1个数从b->c的问题\n```\n\n## 拓展\n我们知道绝大多数的递归都能用循环来写，这里有一种循环方式实现的方法，代码过长\n这里就不贴出来了，[链接](http://tieba.baidu.com/f?kz=1255166419)\n\n## 总结\n其实就是想发篇博客练一下warkdown语法的，但是被各种空格，对齐方式所折磨。\n算法很捉急，这算是个开头吧。\n\n\n\n\n\n","source":"_posts/汉诺塔问题.md","raw":"---\ntitle: 汉诺塔问题\ndate: 2018-10-04 15:48:42\ntags: \"算法\" \n---\n\n## 问题描述\n有a,b,c三根柱子，如今柱子a上面有64个盘子(盘子大小从上到下按大小排列)\n目的:将柱子a上面的盘子全部移动到柱子c上面，列出方法和次数\n规则: 1. 每次只能移动一个盘子     2. 小盘子只能放在大盘子之上\n\n这是一道很经典的题目，问题描述也很简单，用递归做起来也比较简单，但不是很好理解\n\n![](/pic/汉诺塔.png)\n\n## 分析\n算法一直是我的软肋，尤其是涉及递归的更加不好理解(为何如此之菜，哎)\n一上来碰到这种问题肯定没什么思路，机智如我就开始找规律嘛\n64个太多,那就从1个开始吧。\n1个 a->c 1次\n2个 a->b a->c b->c 3次\n3个 a->c a->b c->b a->c b->a b->c a->c  7次\n这时候根据我多年找规律的经验就可以大胆地猜测 总的次数是2^n-1\n那64个的话应该是2^64-1(**天文数字 根本不可能完成的任务**)\n虽然猜出了次数(毫无理论依据,逃)，但是还是不知道移动的次序。\n\n## 问题分解\n从第一步开始想大概率是毫无头绪的，因为你有无数种选择。那么倒推着\n想。首先假设已经成功将a柱上面的63个盘子移到了b柱，此时只要将a柱\n最后一个盘子移动到c柱，这是确定的。\n这时候问题就变成了，如何将b柱上63个盘子移动到c。这和之前的问题一模\n一样，只不过数据规模变小了，并且是从a变到了b。因此可以采用一个的思\n考方法，先将b上面的62个盘子移到a，再将最下面的盘子移到c，以此类推\n就有了解决问题的一个循环的流程。\n## 递归\n以上的流程就是一个递归的过程。我所理解的递归就是有不断地用更小规模的\n数据去求上层数据，当然必须有一个终止的时刻返回。\n\n## 代码展示\n```\ndef fun(n,a,b,c):  #n代表数据规模  a,b,c是三个柱子  从a->c\n    if n == 1:\n        print(a,'->',c)\n    else:\n        fun(n-1,a,c,b)  #第一步把n-1个数据从a->b\n        print(a,'->',c) #第二步把第n个数组从a->c\n        fun(n-1,b,a,c)  #这时候问题规模下降1 变成n-1个数从b->c的问题\n```\n\n## 拓展\n我们知道绝大多数的递归都能用循环来写，这里有一种循环方式实现的方法，代码过长\n这里就不贴出来了，[链接](http://tieba.baidu.com/f?kz=1255166419)\n\n## 总结\n其实就是想发篇博客练一下warkdown语法的，但是被各种空格，对齐方式所折磨。\n算法很捉急，这算是个开头吧。\n\n\n\n\n\n","slug":"汉诺塔问题","published":1,"updated":"2021-12-06T05:30:36.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7u002196caartb6xq2","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>有a,b,c三根柱子，如今柱子a上面有64个盘子(盘子大小从上到下按大小排列)<br>目的:将柱子a上面的盘子全部移动到柱子c上面，列出方法和次数<br>规则: 1. 每次只能移动一个盘子     2. 小盘子只能放在大盘子之上</p>\n<p>这是一道很经典的题目，问题描述也很简单，用递归做起来也比较简单，但不是很好理解</p>\n<p><img src=\"/pic/%E6%B1%89%E8%AF%BA%E5%A1%94.png\" alt=\"\"></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>算法一直是我的软肋，尤其是涉及递归的更加不好理解(为何如此之菜，哎)<br>一上来碰到这种问题肯定没什么思路，机智如我就开始找规律嘛<br>64个太多,那就从1个开始吧。<br>1个 a-&gt;c 1次<br>2个 a-&gt;b a-&gt;c b-&gt;c 3次<br>3个 a-&gt;c a-&gt;b c-&gt;b a-&gt;c b-&gt;a b-&gt;c a-&gt;c  7次<br>这时候根据我多年找规律的经验就可以大胆地猜测 总的次数是2^n-1<br>那64个的话应该是2^64-1(<strong>天文数字 根本不可能完成的任务</strong>)<br>虽然猜出了次数(毫无理论依据,逃)，但是还是不知道移动的次序。</p>\n<h2 id=\"问题分解\"><a href=\"#问题分解\" class=\"headerlink\" title=\"问题分解\"></a>问题分解</h2><p>从第一步开始想大概率是毫无头绪的，因为你有无数种选择。那么倒推着<br>想。首先假设已经成功将a柱上面的63个盘子移到了b柱，此时只要将a柱<br>最后一个盘子移动到c柱，这是确定的。<br>这时候问题就变成了，如何将b柱上63个盘子移动到c。这和之前的问题一模<br>一样，只不过数据规模变小了，并且是从a变到了b。因此可以采用一个的思<br>考方法，先将b上面的62个盘子移到a，再将最下面的盘子移到c，以此类推<br>就有了解决问题的一个循环的流程。</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>以上的流程就是一个递归的过程。我所理解的递归就是有不断地用更小规模的<br>数据去求上层数据，当然必须有一个终止的时刻返回。</p>\n<h2 id=\"代码展示\"><a href=\"#代码展示\" class=\"headerlink\" title=\"代码展示\"></a>代码展示</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fun(n,a,b,c):  #n代表数据规模  a,b,c是三个柱子  从a-&gt;c</span><br><span class=\"line\">    if n &#x3D;&#x3D; 1:</span><br><span class=\"line\">        print(a,&#39;-&gt;&#39;,c)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        fun(n-1,a,c,b)  #第一步把n-1个数据从a-&gt;b</span><br><span class=\"line\">        print(a,&#39;-&gt;&#39;,c) #第二步把第n个数组从a-&gt;c</span><br><span class=\"line\">        fun(n-1,b,a,c)  #这时候问题规模下降1 变成n-1个数从b-&gt;c的问题</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>我们知道绝大多数的递归都能用循环来写，这里有一种循环方式实现的方法，代码过长<br>这里就不贴出来了，<a href=\"http://tieba.baidu.com/f?kz=1255166419\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实就是想发篇博客练一下warkdown语法的，但是被各种空格，对齐方式所折磨。<br>算法很捉急，这算是个开头吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>有a,b,c三根柱子，如今柱子a上面有64个盘子(盘子大小从上到下按大小排列)<br>目的:将柱子a上面的盘子全部移动到柱子c上面，列出方法和次数<br>规则: 1. 每次只能移动一个盘子     2. 小盘子只能放在大盘子之上</p>\n<p>这是一道很经典的题目，问题描述也很简单，用递归做起来也比较简单，但不是很好理解</p>\n<p><img src=\"/pic/%E6%B1%89%E8%AF%BA%E5%A1%94.png\" alt=\"\"></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>算法一直是我的软肋，尤其是涉及递归的更加不好理解(为何如此之菜，哎)<br>一上来碰到这种问题肯定没什么思路，机智如我就开始找规律嘛<br>64个太多,那就从1个开始吧。<br>1个 a-&gt;c 1次<br>2个 a-&gt;b a-&gt;c b-&gt;c 3次<br>3个 a-&gt;c a-&gt;b c-&gt;b a-&gt;c b-&gt;a b-&gt;c a-&gt;c  7次<br>这时候根据我多年找规律的经验就可以大胆地猜测 总的次数是2^n-1<br>那64个的话应该是2^64-1(<strong>天文数字 根本不可能完成的任务</strong>)<br>虽然猜出了次数(毫无理论依据,逃)，但是还是不知道移动的次序。</p>\n<h2 id=\"问题分解\"><a href=\"#问题分解\" class=\"headerlink\" title=\"问题分解\"></a>问题分解</h2><p>从第一步开始想大概率是毫无头绪的，因为你有无数种选择。那么倒推着<br>想。首先假设已经成功将a柱上面的63个盘子移到了b柱，此时只要将a柱<br>最后一个盘子移动到c柱，这是确定的。<br>这时候问题就变成了，如何将b柱上63个盘子移动到c。这和之前的问题一模<br>一样，只不过数据规模变小了，并且是从a变到了b。因此可以采用一个的思<br>考方法，先将b上面的62个盘子移到a，再将最下面的盘子移到c，以此类推<br>就有了解决问题的一个循环的流程。</p>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>以上的流程就是一个递归的过程。我所理解的递归就是有不断地用更小规模的<br>数据去求上层数据，当然必须有一个终止的时刻返回。</p>\n<h2 id=\"代码展示\"><a href=\"#代码展示\" class=\"headerlink\" title=\"代码展示\"></a>代码展示</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fun(n,a,b,c):  #n代表数据规模  a,b,c是三个柱子  从a-&gt;c</span><br><span class=\"line\">    if n &#x3D;&#x3D; 1:</span><br><span class=\"line\">        print(a,&#39;-&gt;&#39;,c)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        fun(n-1,a,c,b)  #第一步把n-1个数据从a-&gt;b</span><br><span class=\"line\">        print(a,&#39;-&gt;&#39;,c) #第二步把第n个数组从a-&gt;c</span><br><span class=\"line\">        fun(n-1,b,a,c)  #这时候问题规模下降1 变成n-1个数从b-&gt;c的问题</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>我们知道绝大多数的递归都能用循环来写，这里有一种循环方式实现的方法，代码过长<br>这里就不贴出来了，<a href=\"http://tieba.baidu.com/f?kz=1255166419\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实就是想发篇博客练一下warkdown语法的，但是被各种空格，对齐方式所折磨。<br>算法很捉急，这算是个开头吧。</p>\n"},{"title":"知识点整理","date":"2018-11-01T04:14:07.000Z","_content":"\n整理一下C++后端需要掌握的知识点，以备自己复习和整理。\n\n## C语言\n\n数据类型和类型转换\n类型修饰符(static const  extern)\n标准I/O 文件I/O\n运算符优先级\ndefine和typedef(注意区别 以及使用上的注意点)\n\n<!--more-->\n\n数组(二维数组 指针数组  数组的指针  下标访问原理)   数组名(sizeof &)\n指针(二级指针  指针常量 常量指针)\n动态申请内存(malloc  free)\n字符串(各种库函数 strlen strcat strcpy strcmp  strncpy strncmp atoi itoa...)\n结构体(对齐方式)\n枚举、联合\n内存分区(堆区 栈区 静态数据区(全局/静态变量(分成初始化和未初始化的) 、 文字常量区(字符串常量)) 代码段 命令行参数)\n多文件编译(编译的过程、头文件包含去重)\n\n## C++\n命名空间\n标准I/O 文件I/O(注意和C效率上的区别)\n动态申请内存(new delete  注意和C的区别)\n封装(类  访问修饰符  友元)\nthis指针\n构造、析构、重载操作符、拷贝构造\n引用(注意和指针的区别)、const(注意和C的区别)\n类和类之间的关系(四种平行关系)\n继承(继承修饰符、单继承、多继承)\n虚函数、多态、函数重载、重写、内联\nSTL六大组件(内容很多)\n模板(泛型编程)\nC++11和C++17新特性\n异常处理\n\n## OS\n线程(特点、使用场合、内部结构、状态转换)\n线程之间通信(全局变量、发送消息)\n线程同步\nwindows(临界区、事件、互斥量、信号量...)\nlinux(临界区(互斥锁)、条件变量、读写锁、信号量...)\n线程同步典型问题:生产者—消费者模型、哲学家就餐模型、读者写者\n死锁(定义、产生原因、条件、避免算法(银行家算法))\n进程(特点、内存分布、与线程的区别)\n进程间通信(IPC)\nwindows(文件映射、共享内存(前一种的特例)、匿名管道、命名管道、邮件槽、剪贴板、网络....)\nlinux(匿名管道、有名管道、消息、内存共享映射、消息队列、信号量、网络...)\n多线程模型、线程池、进程池、内存池\ncpu调度算法(一般是分时复用)\n内存管理(连续和非连续)\n分页、段、段页式、页面置换算法、调用约定\n\n## 网络\nip分类和子网划分、子网掩码\n库(动态库和静态库   区别、适用场合)\nOSI七层模型、TCP/IP四层模型(每层的作用 )\nUDP(报文结构、数据报、特点、适用场合)\nTCP(报文结构、数据流、特点、使用场合、滑动窗口、流量控制、超时重发)\n三次握手四次挥手(为什么  每次都干了什么)、心跳保活机制\nHTTP(特点、请求方式、返回码、爬虫)、抓包工具\n服务器基础  C/S模型  B/S模型\nI/O模型\nwindows(select、消息机制、时间通知、完成端口)\nlinux(select、poll、epoll)\n多线程模型服务器(nginx)、多进程模型服务器(Apache)\n\n## 数据库(知识点还不是很了解、带补)\n关系型数据库Mysql(增删改查 索引 事务 )\n数据库引擎、数据库优化\nMysql底层实现(好像是红黑树)\n关系型数据库Mongdb(增删改查 )\n\n## 数据结构和算法\n数组、链表、栈、队列、矩阵\n二叉树(前序 中序 后序遍历   Morris遍历)、序列化和反序列化\n哈夫曼编码\nAVL树、红黑树、B树、B+树、B-树\n图(有向、无向、有权、无权)\n图的深度优先和广度优先遍历、拓扑排序、最小生成树问题、单源最短路径问题\n堆结构\n哈希表、一致性哈希结构、并查集结构与应用\n布隆过滤器和bitmap算法(大量数据去重)\n排序算法(分析其时间空间复杂度)\n二分查找、字符串查找算法(KMP、Manacher...)\n贪心、动态规划(0-1背包问题)\n\n## linux(待补)\n虚拟机的使用\nvim使用、Shell脚本/python脚本、Makefile编写、gdb调试\n基本命令(ls,cd....)\n文件系统(inode)、信号、进程、线程、网络\n\n\n\n## 其他必备知识\ngit、github、markdown写作习惯\n正则表达式\nwin32、MFC、Qt\n\n\n\n","source":"_posts/知识点整理.md","raw":"---\ntitle: 知识点整理\ndate: 2018-11-01 12:14:07\ntags: \"随笔\"\n---\n\n整理一下C++后端需要掌握的知识点，以备自己复习和整理。\n\n## C语言\n\n数据类型和类型转换\n类型修饰符(static const  extern)\n标准I/O 文件I/O\n运算符优先级\ndefine和typedef(注意区别 以及使用上的注意点)\n\n<!--more-->\n\n数组(二维数组 指针数组  数组的指针  下标访问原理)   数组名(sizeof &)\n指针(二级指针  指针常量 常量指针)\n动态申请内存(malloc  free)\n字符串(各种库函数 strlen strcat strcpy strcmp  strncpy strncmp atoi itoa...)\n结构体(对齐方式)\n枚举、联合\n内存分区(堆区 栈区 静态数据区(全局/静态变量(分成初始化和未初始化的) 、 文字常量区(字符串常量)) 代码段 命令行参数)\n多文件编译(编译的过程、头文件包含去重)\n\n## C++\n命名空间\n标准I/O 文件I/O(注意和C效率上的区别)\n动态申请内存(new delete  注意和C的区别)\n封装(类  访问修饰符  友元)\nthis指针\n构造、析构、重载操作符、拷贝构造\n引用(注意和指针的区别)、const(注意和C的区别)\n类和类之间的关系(四种平行关系)\n继承(继承修饰符、单继承、多继承)\n虚函数、多态、函数重载、重写、内联\nSTL六大组件(内容很多)\n模板(泛型编程)\nC++11和C++17新特性\n异常处理\n\n## OS\n线程(特点、使用场合、内部结构、状态转换)\n线程之间通信(全局变量、发送消息)\n线程同步\nwindows(临界区、事件、互斥量、信号量...)\nlinux(临界区(互斥锁)、条件变量、读写锁、信号量...)\n线程同步典型问题:生产者—消费者模型、哲学家就餐模型、读者写者\n死锁(定义、产生原因、条件、避免算法(银行家算法))\n进程(特点、内存分布、与线程的区别)\n进程间通信(IPC)\nwindows(文件映射、共享内存(前一种的特例)、匿名管道、命名管道、邮件槽、剪贴板、网络....)\nlinux(匿名管道、有名管道、消息、内存共享映射、消息队列、信号量、网络...)\n多线程模型、线程池、进程池、内存池\ncpu调度算法(一般是分时复用)\n内存管理(连续和非连续)\n分页、段、段页式、页面置换算法、调用约定\n\n## 网络\nip分类和子网划分、子网掩码\n库(动态库和静态库   区别、适用场合)\nOSI七层模型、TCP/IP四层模型(每层的作用 )\nUDP(报文结构、数据报、特点、适用场合)\nTCP(报文结构、数据流、特点、使用场合、滑动窗口、流量控制、超时重发)\n三次握手四次挥手(为什么  每次都干了什么)、心跳保活机制\nHTTP(特点、请求方式、返回码、爬虫)、抓包工具\n服务器基础  C/S模型  B/S模型\nI/O模型\nwindows(select、消息机制、时间通知、完成端口)\nlinux(select、poll、epoll)\n多线程模型服务器(nginx)、多进程模型服务器(Apache)\n\n## 数据库(知识点还不是很了解、带补)\n关系型数据库Mysql(增删改查 索引 事务 )\n数据库引擎、数据库优化\nMysql底层实现(好像是红黑树)\n关系型数据库Mongdb(增删改查 )\n\n## 数据结构和算法\n数组、链表、栈、队列、矩阵\n二叉树(前序 中序 后序遍历   Morris遍历)、序列化和反序列化\n哈夫曼编码\nAVL树、红黑树、B树、B+树、B-树\n图(有向、无向、有权、无权)\n图的深度优先和广度优先遍历、拓扑排序、最小生成树问题、单源最短路径问题\n堆结构\n哈希表、一致性哈希结构、并查集结构与应用\n布隆过滤器和bitmap算法(大量数据去重)\n排序算法(分析其时间空间复杂度)\n二分查找、字符串查找算法(KMP、Manacher...)\n贪心、动态规划(0-1背包问题)\n\n## linux(待补)\n虚拟机的使用\nvim使用、Shell脚本/python脚本、Makefile编写、gdb调试\n基本命令(ls,cd....)\n文件系统(inode)、信号、进程、线程、网络\n\n\n\n## 其他必备知识\ngit、github、markdown写作习惯\n正则表达式\nwin32、MFC、Qt\n\n\n\n","slug":"知识点整理","published":1,"updated":"2021-12-06T05:30:36.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7u002396cag3k2hscw","content":"<p>整理一下C++后端需要掌握的知识点，以备自己复习和整理。</p>\n<h2 id=\"C语言\"><a href=\"#C语言\" class=\"headerlink\" title=\"C语言\"></a>C语言</h2><p>数据类型和类型转换<br>类型修饰符(static const  extern)<br>标准I/O 文件I/O<br>运算符优先级<br>define和typedef(注意区别 以及使用上的注意点)</p>\n<a id=\"more\"></a>\n\n<p>数组(二维数组 指针数组  数组的指针  下标访问原理)   数组名(sizeof &amp;)<br>指针(二级指针  指针常量 常量指针)<br>动态申请内存(malloc  free)<br>字符串(各种库函数 strlen strcat strcpy strcmp  strncpy strncmp atoi itoa…)<br>结构体(对齐方式)<br>枚举、联合<br>内存分区(堆区 栈区 静态数据区(全局/静态变量(分成初始化和未初始化的) 、 文字常量区(字符串常量)) 代码段 命令行参数)<br>多文件编译(编译的过程、头文件包含去重)</p>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><p>命名空间<br>标准I/O 文件I/O(注意和C效率上的区别)<br>动态申请内存(new delete  注意和C的区别)<br>封装(类  访问修饰符  友元)<br>this指针<br>构造、析构、重载操作符、拷贝构造<br>引用(注意和指针的区别)、const(注意和C的区别)<br>类和类之间的关系(四种平行关系)<br>继承(继承修饰符、单继承、多继承)<br>虚函数、多态、函数重载、重写、内联<br>STL六大组件(内容很多)<br>模板(泛型编程)<br>C++11和C++17新特性<br>异常处理</p>\n<h2 id=\"OS\"><a href=\"#OS\" class=\"headerlink\" title=\"OS\"></a>OS</h2><p>线程(特点、使用场合、内部结构、状态转换)<br>线程之间通信(全局变量、发送消息)<br>线程同步<br>windows(临界区、事件、互斥量、信号量…)<br>linux(临界区(互斥锁)、条件变量、读写锁、信号量…)<br>线程同步典型问题:生产者—消费者模型、哲学家就餐模型、读者写者<br>死锁(定义、产生原因、条件、避免算法(银行家算法))<br>进程(特点、内存分布、与线程的区别)<br>进程间通信(IPC)<br>windows(文件映射、共享内存(前一种的特例)、匿名管道、命名管道、邮件槽、剪贴板、网络….)<br>linux(匿名管道、有名管道、消息、内存共享映射、消息队列、信号量、网络…)<br>多线程模型、线程池、进程池、内存池<br>cpu调度算法(一般是分时复用)<br>内存管理(连续和非连续)<br>分页、段、段页式、页面置换算法、调用约定</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>ip分类和子网划分、子网掩码<br>库(动态库和静态库   区别、适用场合)<br>OSI七层模型、TCP/IP四层模型(每层的作用 )<br>UDP(报文结构、数据报、特点、适用场合)<br>TCP(报文结构、数据流、特点、使用场合、滑动窗口、流量控制、超时重发)<br>三次握手四次挥手(为什么  每次都干了什么)、心跳保活机制<br>HTTP(特点、请求方式、返回码、爬虫)、抓包工具<br>服务器基础  C/S模型  B/S模型<br>I/O模型<br>windows(select、消息机制、时间通知、完成端口)<br>linux(select、poll、epoll)<br>多线程模型服务器(nginx)、多进程模型服务器(Apache)</p>\n<h2 id=\"数据库-知识点还不是很了解、带补\"><a href=\"#数据库-知识点还不是很了解、带补\" class=\"headerlink\" title=\"数据库(知识点还不是很了解、带补)\"></a>数据库(知识点还不是很了解、带补)</h2><p>关系型数据库Mysql(增删改查 索引 事务 )<br>数据库引擎、数据库优化<br>Mysql底层实现(好像是红黑树)<br>关系型数据库Mongdb(增删改查 )</p>\n<h2 id=\"数据结构和算法\"><a href=\"#数据结构和算法\" class=\"headerlink\" title=\"数据结构和算法\"></a>数据结构和算法</h2><p>数组、链表、栈、队列、矩阵<br>二叉树(前序 中序 后序遍历   Morris遍历)、序列化和反序列化<br>哈夫曼编码<br>AVL树、红黑树、B树、B+树、B-树<br>图(有向、无向、有权、无权)<br>图的深度优先和广度优先遍历、拓扑排序、最小生成树问题、单源最短路径问题<br>堆结构<br>哈希表、一致性哈希结构、并查集结构与应用<br>布隆过滤器和bitmap算法(大量数据去重)<br>排序算法(分析其时间空间复杂度)<br>二分查找、字符串查找算法(KMP、Manacher…)<br>贪心、动态规划(0-1背包问题)</p>\n<h2 id=\"linux-待补\"><a href=\"#linux-待补\" class=\"headerlink\" title=\"linux(待补)\"></a>linux(待补)</h2><p>虚拟机的使用<br>vim使用、Shell脚本/python脚本、Makefile编写、gdb调试<br>基本命令(ls,cd….)<br>文件系统(inode)、信号、进程、线程、网络</p>\n<h2 id=\"其他必备知识\"><a href=\"#其他必备知识\" class=\"headerlink\" title=\"其他必备知识\"></a>其他必备知识</h2><p>git、github、markdown写作习惯<br>正则表达式<br>win32、MFC、Qt</p>\n","site":{"data":{}},"excerpt":"<p>整理一下C++后端需要掌握的知识点，以备自己复习和整理。</p>\n<h2 id=\"C语言\"><a href=\"#C语言\" class=\"headerlink\" title=\"C语言\"></a>C语言</h2><p>数据类型和类型转换<br>类型修饰符(static const  extern)<br>标准I/O 文件I/O<br>运算符优先级<br>define和typedef(注意区别 以及使用上的注意点)</p>","more":"<p>数组(二维数组 指针数组  数组的指针  下标访问原理)   数组名(sizeof &amp;)<br>指针(二级指针  指针常量 常量指针)<br>动态申请内存(malloc  free)<br>字符串(各种库函数 strlen strcat strcpy strcmp  strncpy strncmp atoi itoa…)<br>结构体(对齐方式)<br>枚举、联合<br>内存分区(堆区 栈区 静态数据区(全局/静态变量(分成初始化和未初始化的) 、 文字常量区(字符串常量)) 代码段 命令行参数)<br>多文件编译(编译的过程、头文件包含去重)</p>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><p>命名空间<br>标准I/O 文件I/O(注意和C效率上的区别)<br>动态申请内存(new delete  注意和C的区别)<br>封装(类  访问修饰符  友元)<br>this指针<br>构造、析构、重载操作符、拷贝构造<br>引用(注意和指针的区别)、const(注意和C的区别)<br>类和类之间的关系(四种平行关系)<br>继承(继承修饰符、单继承、多继承)<br>虚函数、多态、函数重载、重写、内联<br>STL六大组件(内容很多)<br>模板(泛型编程)<br>C++11和C++17新特性<br>异常处理</p>\n<h2 id=\"OS\"><a href=\"#OS\" class=\"headerlink\" title=\"OS\"></a>OS</h2><p>线程(特点、使用场合、内部结构、状态转换)<br>线程之间通信(全局变量、发送消息)<br>线程同步<br>windows(临界区、事件、互斥量、信号量…)<br>linux(临界区(互斥锁)、条件变量、读写锁、信号量…)<br>线程同步典型问题:生产者—消费者模型、哲学家就餐模型、读者写者<br>死锁(定义、产生原因、条件、避免算法(银行家算法))<br>进程(特点、内存分布、与线程的区别)<br>进程间通信(IPC)<br>windows(文件映射、共享内存(前一种的特例)、匿名管道、命名管道、邮件槽、剪贴板、网络….)<br>linux(匿名管道、有名管道、消息、内存共享映射、消息队列、信号量、网络…)<br>多线程模型、线程池、进程池、内存池<br>cpu调度算法(一般是分时复用)<br>内存管理(连续和非连续)<br>分页、段、段页式、页面置换算法、调用约定</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>ip分类和子网划分、子网掩码<br>库(动态库和静态库   区别、适用场合)<br>OSI七层模型、TCP/IP四层模型(每层的作用 )<br>UDP(报文结构、数据报、特点、适用场合)<br>TCP(报文结构、数据流、特点、使用场合、滑动窗口、流量控制、超时重发)<br>三次握手四次挥手(为什么  每次都干了什么)、心跳保活机制<br>HTTP(特点、请求方式、返回码、爬虫)、抓包工具<br>服务器基础  C/S模型  B/S模型<br>I/O模型<br>windows(select、消息机制、时间通知、完成端口)<br>linux(select、poll、epoll)<br>多线程模型服务器(nginx)、多进程模型服务器(Apache)</p>\n<h2 id=\"数据库-知识点还不是很了解、带补\"><a href=\"#数据库-知识点还不是很了解、带补\" class=\"headerlink\" title=\"数据库(知识点还不是很了解、带补)\"></a>数据库(知识点还不是很了解、带补)</h2><p>关系型数据库Mysql(增删改查 索引 事务 )<br>数据库引擎、数据库优化<br>Mysql底层实现(好像是红黑树)<br>关系型数据库Mongdb(增删改查 )</p>\n<h2 id=\"数据结构和算法\"><a href=\"#数据结构和算法\" class=\"headerlink\" title=\"数据结构和算法\"></a>数据结构和算法</h2><p>数组、链表、栈、队列、矩阵<br>二叉树(前序 中序 后序遍历   Morris遍历)、序列化和反序列化<br>哈夫曼编码<br>AVL树、红黑树、B树、B+树、B-树<br>图(有向、无向、有权、无权)<br>图的深度优先和广度优先遍历、拓扑排序、最小生成树问题、单源最短路径问题<br>堆结构<br>哈希表、一致性哈希结构、并查集结构与应用<br>布隆过滤器和bitmap算法(大量数据去重)<br>排序算法(分析其时间空间复杂度)<br>二分查找、字符串查找算法(KMP、Manacher…)<br>贪心、动态规划(0-1背包问题)</p>\n<h2 id=\"linux-待补\"><a href=\"#linux-待补\" class=\"headerlink\" title=\"linux(待补)\"></a>linux(待补)</h2><p>虚拟机的使用<br>vim使用、Shell脚本/python脚本、Makefile编写、gdb调试<br>基本命令(ls,cd….)<br>文件系统(inode)、信号、进程、线程、网络</p>\n<h2 id=\"其他必备知识\"><a href=\"#其他必备知识\" class=\"headerlink\" title=\"其他必备知识\"></a>其他必备知识</h2><p>git、github、markdown写作习惯<br>正则表达式<br>win32、MFC、Qt</p>"},{"title":"庆祝博客的诞生","date":"2018-09-20T05:20:28.000Z","_content":"\n## 起源\n去年就一直想搭一个属于自己的博客，但疏于前端知识的缺乏，动手了几次都因为各种问题搁置了这个想法。随着学的东西越来越多，越发觉得需要一个用来整理、回顾知识的博客。于是，上网找了各种教程和视频，捣鼓了两天终于搭建完成了。\n\n## 心路历程  \n\n前期跟着教程安装node.js git 和 hexo都很顺利。本地的静态博客也搭建完毕了，于是在阿\n里云买了个域名，dns服务器解析也添加了记录，但用自己的域名始终ping不出来，试了一下午都没解决，最后发现是在阿里云上没有**实名认证**。\n紧接着马上写了个测试博文，随之而来的是第二个问题，点P击博文标题无法跳转，又是找了一下午的问题，一遍又一遍看各种配置文件和js文件都没搞定，真的是心力交瘁，无奈一下换了个主题问题就解决了，~~吐槽archer~~，也可能我不会用啊哈哈哈。\n\n## Futuer\n总之，基础的博客总算搭建完成，其余的各种插件和功能后期再慢慢研究和加入吧，纪念一下\n这个激动人心的时候，接下来要好好利用这个平台，坚持写博文,day day up。\n最后感谢一下这个博主的分享 [链接](https://godweiyang.com/2018/04/13/hexo-blog/)\n\n\n## 测试一下\n+ ceshi \n    - sad\n    - sads\n- sadsad\n\n\n- [x] 新增\n- [ ] wuyu \n\n\n```python\nimport math\nprint(math.sqrt(2))\n```\n","source":"_posts/庆祝博客的诞生.md","raw":"---\ntitle: 庆祝博客的诞生\ndate: 2018-09-20 13:20:28\ntags: 随笔\n---\n\n## 起源\n去年就一直想搭一个属于自己的博客，但疏于前端知识的缺乏，动手了几次都因为各种问题搁置了这个想法。随着学的东西越来越多，越发觉得需要一个用来整理、回顾知识的博客。于是，上网找了各种教程和视频，捣鼓了两天终于搭建完成了。\n\n## 心路历程  \n\n前期跟着教程安装node.js git 和 hexo都很顺利。本地的静态博客也搭建完毕了，于是在阿\n里云买了个域名，dns服务器解析也添加了记录，但用自己的域名始终ping不出来，试了一下午都没解决，最后发现是在阿里云上没有**实名认证**。\n紧接着马上写了个测试博文，随之而来的是第二个问题，点P击博文标题无法跳转，又是找了一下午的问题，一遍又一遍看各种配置文件和js文件都没搞定，真的是心力交瘁，无奈一下换了个主题问题就解决了，~~吐槽archer~~，也可能我不会用啊哈哈哈。\n\n## Futuer\n总之，基础的博客总算搭建完成，其余的各种插件和功能后期再慢慢研究和加入吧，纪念一下\n这个激动人心的时候，接下来要好好利用这个平台，坚持写博文,day day up。\n最后感谢一下这个博主的分享 [链接](https://godweiyang.com/2018/04/13/hexo-blog/)\n\n\n## 测试一下\n+ ceshi \n    - sad\n    - sads\n- sadsad\n\n\n- [x] 新增\n- [ ] wuyu \n\n\n```python\nimport math\nprint(math.sqrt(2))\n```\n","slug":"庆祝博客的诞生","published":1,"updated":"2021-12-06T05:30:36.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7v002696cabf00hicz","content":"<h2 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h2><p>去年就一直想搭一个属于自己的博客，但疏于前端知识的缺乏，动手了几次都因为各种问题搁置了这个想法。随着学的东西越来越多，越发觉得需要一个用来整理、回顾知识的博客。于是，上网找了各种教程和视频，捣鼓了两天终于搭建完成了。</p>\n<h2 id=\"心路历程\"><a href=\"#心路历程\" class=\"headerlink\" title=\"心路历程\"></a>心路历程</h2><p>前期跟着教程安装node.js git 和 hexo都很顺利。本地的静态博客也搭建完毕了，于是在阿<br>里云买了个域名，dns服务器解析也添加了记录，但用自己的域名始终ping不出来，试了一下午都没解决，最后发现是在阿里云上没有<strong>实名认证</strong>。<br>紧接着马上写了个测试博文，随之而来的是第二个问题，点P击博文标题无法跳转，又是找了一下午的问题，一遍又一遍看各种配置文件和js文件都没搞定，真的是心力交瘁，无奈一下换了个主题问题就解决了，<del>吐槽archer</del>，也可能我不会用啊哈哈哈。</p>\n<h2 id=\"Futuer\"><a href=\"#Futuer\" class=\"headerlink\" title=\"Futuer\"></a>Futuer</h2><p>总之，基础的博客总算搭建完成，其余的各种插件和功能后期再慢慢研究和加入吧，纪念一下<br>这个激动人心的时候，接下来要好好利用这个平台，坚持写博文,day day up。<br>最后感谢一下这个博主的分享 <a href=\"https://godweiyang.com/2018/04/13/hexo-blog/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"测试一下\"><a href=\"#测试一下\" class=\"headerlink\" title=\"测试一下\"></a>测试一下</h2><ul>\n<li>ceshi <ul>\n<li>sad</li>\n<li>sads</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>sadsad</li>\n</ul>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新增</li>\n<li><input disabled=\"\" type=\"checkbox\"> wuyu </li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\">print(math.sqrt(<span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h2><p>去年就一直想搭一个属于自己的博客，但疏于前端知识的缺乏，动手了几次都因为各种问题搁置了这个想法。随着学的东西越来越多，越发觉得需要一个用来整理、回顾知识的博客。于是，上网找了各种教程和视频，捣鼓了两天终于搭建完成了。</p>\n<h2 id=\"心路历程\"><a href=\"#心路历程\" class=\"headerlink\" title=\"心路历程\"></a>心路历程</h2><p>前期跟着教程安装node.js git 和 hexo都很顺利。本地的静态博客也搭建完毕了，于是在阿<br>里云买了个域名，dns服务器解析也添加了记录，但用自己的域名始终ping不出来，试了一下午都没解决，最后发现是在阿里云上没有<strong>实名认证</strong>。<br>紧接着马上写了个测试博文，随之而来的是第二个问题，点P击博文标题无法跳转，又是找了一下午的问题，一遍又一遍看各种配置文件和js文件都没搞定，真的是心力交瘁，无奈一下换了个主题问题就解决了，<del>吐槽archer</del>，也可能我不会用啊哈哈哈。</p>\n<h2 id=\"Futuer\"><a href=\"#Futuer\" class=\"headerlink\" title=\"Futuer\"></a>Futuer</h2><p>总之，基础的博客总算搭建完成，其余的各种插件和功能后期再慢慢研究和加入吧，纪念一下<br>这个激动人心的时候，接下来要好好利用这个平台，坚持写博文,day day up。<br>最后感谢一下这个博主的分享 <a href=\"https://godweiyang.com/2018/04/13/hexo-blog/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"测试一下\"><a href=\"#测试一下\" class=\"headerlink\" title=\"测试一下\"></a>测试一下</h2><ul>\n<li>ceshi <ul>\n<li>sad</li>\n<li>sads</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>sadsad</li>\n</ul>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新增</li>\n<li><input disabled=\"\" type=\"checkbox\"> wuyu </li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\">print(math.sqrt(<span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n"},{"title":"滑动窗口","date":"2018-11-17T14:07:22.000Z","_content":"\n## 引言\n\n当发送方的发送速率过快，以至于接收方没来得及接收，导致出现丢包现象\n这时候我们需要进行流量控制，TCP采用的是滑动窗口进行流量控制。\n注意：滑动窗口控制的是发送端和接收端，是端到端的控制\n\n## 1比特滑动窗口协议(停止等待协议)\n\n接收方和发送方的窗口大小都是1，发送方每次都发送一个数据包，必须等待到这个数据包的ACK，才能发送下一个。显然这种方式效率很低，带宽利用率很低，只适合网络环境差或者本身带宽很低的情况下。\n\n## 滑动窗口(rwnd)\n\n发送端和接收端都维护一个数据帧的序列，发送方的窗口大小由接收方确定，目的在于控制发送速度，避免接收方缓存不够大，导致溢出丢包，同时控制流量避免网络拥塞。\n\n滑动窗口允许发送方不必等待接收方的确认就可以连续发送多个数据包，提高了传输效率，同时由于窗口的存在，也限制了流量，达到控制的目的。\n<!-- more -->\n\n发送方\n\n![发送方滑动窗口](/pic/发送方滑动窗口.png)\n\n当接收方确认数据后，同时返回提供的窗口大小。\n\n随着窗口中的数据不断被确认，窗口不断右移。\n\n接收方\n\n![接收方](/pic/接收方滑动窗口.png)\n\n流程解释：\n1.客户端向服务器发起连接请求,告诉服务器自己窗口大小是4096，指定MSS为1460\n2.服务器确认客户端的连接请求，并向客户端发起连接请求，指定窗口大小是6144，MSS为1024\n3 客户端确认服务器的连接请求\n1-3就是三次握手过程\n4-9客户端给服务器连续发送了六个数据包，总共6144个字节，填满了接收方的窗口。\n10.接收方确认收到了6144个字节，并且交给应用程序处理了2048个字节，因此返回可用窗口大小2048\n11.接收方确认收到了6144个字节，并且交给应用程序处理了2048个字节，因此返回可用窗口大小4096\n12.客户端给服务器发送1024个字节数据\n13.客户端请求断开与服务器的连接，同时发送1024个字节数据，然后表示不再给服务器发送数据了\n14.服务器确认了新发来的两个数据包和客户端的断开请求，但尚未处理数据，返回可用窗口大小为2048\n15.服务器处理了2048个字节，返回可用窗口大小4096\n16.服务器又处理了2048个字节，返回可用窗口大小6144\n17.服务器请求断开和客户端的连接\n18.客户端确认服务器的断开请求\n\n注：上述所有数字都是以字节为单位。\n\n\n\n\n\n","source":"_posts/滑动窗口.md","raw":"---\ntitle: 滑动窗口\ndate: 2018-11-17 22:07:22\ntags: \n- 网络\n- TCP\n---\n\n## 引言\n\n当发送方的发送速率过快，以至于接收方没来得及接收，导致出现丢包现象\n这时候我们需要进行流量控制，TCP采用的是滑动窗口进行流量控制。\n注意：滑动窗口控制的是发送端和接收端，是端到端的控制\n\n## 1比特滑动窗口协议(停止等待协议)\n\n接收方和发送方的窗口大小都是1，发送方每次都发送一个数据包，必须等待到这个数据包的ACK，才能发送下一个。显然这种方式效率很低，带宽利用率很低，只适合网络环境差或者本身带宽很低的情况下。\n\n## 滑动窗口(rwnd)\n\n发送端和接收端都维护一个数据帧的序列，发送方的窗口大小由接收方确定，目的在于控制发送速度，避免接收方缓存不够大，导致溢出丢包，同时控制流量避免网络拥塞。\n\n滑动窗口允许发送方不必等待接收方的确认就可以连续发送多个数据包，提高了传输效率，同时由于窗口的存在，也限制了流量，达到控制的目的。\n<!-- more -->\n\n发送方\n\n![发送方滑动窗口](/pic/发送方滑动窗口.png)\n\n当接收方确认数据后，同时返回提供的窗口大小。\n\n随着窗口中的数据不断被确认，窗口不断右移。\n\n接收方\n\n![接收方](/pic/接收方滑动窗口.png)\n\n流程解释：\n1.客户端向服务器发起连接请求,告诉服务器自己窗口大小是4096，指定MSS为1460\n2.服务器确认客户端的连接请求，并向客户端发起连接请求，指定窗口大小是6144，MSS为1024\n3 客户端确认服务器的连接请求\n1-3就是三次握手过程\n4-9客户端给服务器连续发送了六个数据包，总共6144个字节，填满了接收方的窗口。\n10.接收方确认收到了6144个字节，并且交给应用程序处理了2048个字节，因此返回可用窗口大小2048\n11.接收方确认收到了6144个字节，并且交给应用程序处理了2048个字节，因此返回可用窗口大小4096\n12.客户端给服务器发送1024个字节数据\n13.客户端请求断开与服务器的连接，同时发送1024个字节数据，然后表示不再给服务器发送数据了\n14.服务器确认了新发来的两个数据包和客户端的断开请求，但尚未处理数据，返回可用窗口大小为2048\n15.服务器处理了2048个字节，返回可用窗口大小4096\n16.服务器又处理了2048个字节，返回可用窗口大小6144\n17.服务器请求断开和客户端的连接\n18.客户端确认服务器的断开请求\n\n注：上述所有数字都是以字节为单位。\n\n\n\n\n\n","slug":"滑动窗口","published":1,"updated":"2021-12-06T05:30:36.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7v002896caagxt0fy3","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>当发送方的发送速率过快，以至于接收方没来得及接收，导致出现丢包现象<br>这时候我们需要进行流量控制，TCP采用的是滑动窗口进行流量控制。<br>注意：滑动窗口控制的是发送端和接收端，是端到端的控制</p>\n<h2 id=\"1比特滑动窗口协议-停止等待协议\"><a href=\"#1比特滑动窗口协议-停止等待协议\" class=\"headerlink\" title=\"1比特滑动窗口协议(停止等待协议)\"></a>1比特滑动窗口协议(停止等待协议)</h2><p>接收方和发送方的窗口大小都是1，发送方每次都发送一个数据包，必须等待到这个数据包的ACK，才能发送下一个。显然这种方式效率很低，带宽利用率很低，只适合网络环境差或者本身带宽很低的情况下。</p>\n<h2 id=\"滑动窗口-rwnd\"><a href=\"#滑动窗口-rwnd\" class=\"headerlink\" title=\"滑动窗口(rwnd)\"></a>滑动窗口(rwnd)</h2><p>发送端和接收端都维护一个数据帧的序列，发送方的窗口大小由接收方确定，目的在于控制发送速度，避免接收方缓存不够大，导致溢出丢包，同时控制流量避免网络拥塞。</p>\n<p>滑动窗口允许发送方不必等待接收方的确认就可以连续发送多个数据包，提高了传输效率，同时由于窗口的存在，也限制了流量，达到控制的目的。</p>\n<a id=\"more\"></a>\n\n<p>发送方</p>\n<p><img src=\"/pic/%E5%8F%91%E9%80%81%E6%96%B9%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png\" alt=\"发送方滑动窗口\"></p>\n<p>当接收方确认数据后，同时返回提供的窗口大小。</p>\n<p>随着窗口中的数据不断被确认，窗口不断右移。</p>\n<p>接收方</p>\n<p><img src=\"/pic/%E6%8E%A5%E6%94%B6%E6%96%B9%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png\" alt=\"接收方\"></p>\n<p>流程解释：<br>1.客户端向服务器发起连接请求,告诉服务器自己窗口大小是4096，指定MSS为1460<br>2.服务器确认客户端的连接请求，并向客户端发起连接请求，指定窗口大小是6144，MSS为1024<br>3 客户端确认服务器的连接请求<br>1-3就是三次握手过程<br>4-9客户端给服务器连续发送了六个数据包，总共6144个字节，填满了接收方的窗口。<br>10.接收方确认收到了6144个字节，并且交给应用程序处理了2048个字节，因此返回可用窗口大小2048<br>11.接收方确认收到了6144个字节，并且交给应用程序处理了2048个字节，因此返回可用窗口大小4096<br>12.客户端给服务器发送1024个字节数据<br>13.客户端请求断开与服务器的连接，同时发送1024个字节数据，然后表示不再给服务器发送数据了<br>14.服务器确认了新发来的两个数据包和客户端的断开请求，但尚未处理数据，返回可用窗口大小为2048<br>15.服务器处理了2048个字节，返回可用窗口大小4096<br>16.服务器又处理了2048个字节，返回可用窗口大小6144<br>17.服务器请求断开和客户端的连接<br>18.客户端确认服务器的断开请求</p>\n<p>注：上述所有数字都是以字节为单位。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>当发送方的发送速率过快，以至于接收方没来得及接收，导致出现丢包现象<br>这时候我们需要进行流量控制，TCP采用的是滑动窗口进行流量控制。<br>注意：滑动窗口控制的是发送端和接收端，是端到端的控制</p>\n<h2 id=\"1比特滑动窗口协议-停止等待协议\"><a href=\"#1比特滑动窗口协议-停止等待协议\" class=\"headerlink\" title=\"1比特滑动窗口协议(停止等待协议)\"></a>1比特滑动窗口协议(停止等待协议)</h2><p>接收方和发送方的窗口大小都是1，发送方每次都发送一个数据包，必须等待到这个数据包的ACK，才能发送下一个。显然这种方式效率很低，带宽利用率很低，只适合网络环境差或者本身带宽很低的情况下。</p>\n<h2 id=\"滑动窗口-rwnd\"><a href=\"#滑动窗口-rwnd\" class=\"headerlink\" title=\"滑动窗口(rwnd)\"></a>滑动窗口(rwnd)</h2><p>发送端和接收端都维护一个数据帧的序列，发送方的窗口大小由接收方确定，目的在于控制发送速度，避免接收方缓存不够大，导致溢出丢包，同时控制流量避免网络拥塞。</p>\n<p>滑动窗口允许发送方不必等待接收方的确认就可以连续发送多个数据包，提高了传输效率，同时由于窗口的存在，也限制了流量，达到控制的目的。</p>","more":"<p>发送方</p>\n<p><img src=\"/pic/%E5%8F%91%E9%80%81%E6%96%B9%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png\" alt=\"发送方滑动窗口\"></p>\n<p>当接收方确认数据后，同时返回提供的窗口大小。</p>\n<p>随着窗口中的数据不断被确认，窗口不断右移。</p>\n<p>接收方</p>\n<p><img src=\"/pic/%E6%8E%A5%E6%94%B6%E6%96%B9%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png\" alt=\"接收方\"></p>\n<p>流程解释：<br>1.客户端向服务器发起连接请求,告诉服务器自己窗口大小是4096，指定MSS为1460<br>2.服务器确认客户端的连接请求，并向客户端发起连接请求，指定窗口大小是6144，MSS为1024<br>3 客户端确认服务器的连接请求<br>1-3就是三次握手过程<br>4-9客户端给服务器连续发送了六个数据包，总共6144个字节，填满了接收方的窗口。<br>10.接收方确认收到了6144个字节，并且交给应用程序处理了2048个字节，因此返回可用窗口大小2048<br>11.接收方确认收到了6144个字节，并且交给应用程序处理了2048个字节，因此返回可用窗口大小4096<br>12.客户端给服务器发送1024个字节数据<br>13.客户端请求断开与服务器的连接，同时发送1024个字节数据，然后表示不再给服务器发送数据了<br>14.服务器确认了新发来的两个数据包和客户端的断开请求，但尚未处理数据，返回可用窗口大小为2048<br>15.服务器处理了2048个字节，返回可用窗口大小4096<br>16.服务器又处理了2048个字节，返回可用窗口大小6144<br>17.服务器请求断开和客户端的连接<br>18.客户端确认服务器的断开请求</p>\n<p>注：上述所有数字都是以字节为单位。</p>"},{"title":"线程同步经典问题练习","date":"2018-11-09T11:29:37.000Z","_content":"\n## 生产者-消费者\n\n### 问题描述\n\n若干个生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个具有多个缓冲区的缓冲池，生产者将它生产的产品放入一个缓冲区中，消费者可以从缓冲区中取走产品进行消费\n\n### 问题分析\n同步: 1.缓冲区满时  生产者不能生产  阻塞  2.缓冲区空时  消费者不能消费  阻塞\n互斥:  生产和消费是互斥行为\n信号量+关键段\n\n代码如下:\n\n```\n#include<iostream>\n#include<windows.h>\n#include<process.h>\nusing namespace std;\n/*两个生产者 两个消费者  四块缓冲区*/\nconst int GoodsMax = 10;\nCRITICAL_SECTION cs;\nHANDLE hSemaphore_notFull;\nHANDLE hSemaphore_notempty;\nunsigned __stdcall ProducerProc( void * );\nunsigned __stdcall ConsumerProc( void * );\nconst int bufsize = 4;\nint buf[bufsize]; //用数组实现循环队列模拟缓冲区\nint g_x,g_y;\nint goods = 1; //模拟产品\nbool Pro_exit_flag = FALSE;\nbool Con_exit_flag = FALSE;\nint main()\n{\n\tInitializeCriticalSection(&cs);\n\thSemaphore_notFull = CreateSemaphore(NULL,4,4,NULL);\n\thSemaphore_notempty = CreateSemaphore(NULL,0,4,NULL);\n\tHANDLE handle[4];\n\thandle[0] = (HANDLE)_beginthreadex(NULL,0,ProducerProc,NULL,0,NULL);\n\thandle[1] = (HANDLE)_beginthreadex(NULL,0,ProducerProc,NULL,0,NULL);\n\thandle[2] = (HANDLE)_beginthreadex(NULL,0,ConsumerProc,NULL,0,NULL);\n\thandle[3] = (HANDLE)_beginthreadex(NULL,0,ConsumerProc,NULL,0,NULL);\n\tWaitForMultipleObjects(4,handle,TRUE,INFINITE);\n\tCloseHandle(hSemaphore_notFull);\n\tCloseHandle(hSemaphore_notempty);\n\tCloseHandle(handle[0]);\n\tCloseHandle(handle[1]);\n\tCloseHandle(handle[2]);\n\tCloseHandle(handle[3]);\n\tDeleteCriticalSection(&cs);\n\n\tgetchar();\n\treturn 0;\n}\n\n\nunsigned __stdcall ProducerProc(void* lparma){\n\n\twhile(1){\n\n\t\t//等待有空余的缓冲区，阻塞在满的时候\n\t\tWaitForSingleObject(hSemaphore_notFull,INFINITE);\n\n\t\tEnterCriticalSection(&cs);\n\t\tif(!Pro_exit_flag)\n\t\t{\n\t\t\tbuf[g_x] = goods;\n\t\t\tprintf(\"%d生产者将数据%d放入缓冲区%d\\n\",GetCurrentThreadId(),goods,g_x);\n\t\t}\n\t\tif(goods == GoodsMax)\n\t\t{\n\t\t   LeaveCriticalSection(&cs);\n\t\t   //通知另一个生产者线程退出，工作已经结束了\n\t\t   ReleaseSemaphore(hSemaphore_notFull,1,NULL);\n\n\t\t   ReleaseSemaphore(hSemaphore_notempty,1,NULL);//通知消费者消费\n\t\t   Pro_exit_flag = TRUE;\n\t\t   break;\n\t\t}\n\t\tgoods++;\n\t\tg_x = (g_x+1)%bufsize;\n\t\tLeaveCriticalSection(&cs);\n\t\t\n\t\tReleaseSemaphore(hSemaphore_notempty,1,NULL); //通知消费可以消费了\n\t}\n\n\tprintf(\"************%d生产者已经完美地结束了工作\\n\",GetCurrentThreadId());\n\n\treturn 0;\n}\nunsigned __stdcall ConsumerProc( void * lparma){\n\n\twhile(1){\n\t\t//等待缓冲区有东西\n\t\tWaitForSingleObject(hSemaphore_notempty,INFINITE);\t\n\t\tEnterCriticalSection(&cs);\n\t\tif(!Con_exit_flag)\n\t\t\tprintf(\"\\t%d消费者将数据%d从缓冲区%d拿出\\n\",GetCurrentThreadId(),buf[g_y],g_y);\n\t\tif(buf[g_y] == GoodsMax){\n\t\t\t LeaveCriticalSection(&cs);\t \n\t\t\t ReleaseSemaphore(hSemaphore_notempty,1,NULL);  //无故释放一个信号量告诉另一个线程退出\n\t\t\t Con_exit_flag = TRUE;\n\t\t\t break;\n\t\t}\n\t\tg_y = (g_y+1)%bufsize;\n\t\tLeaveCriticalSection(&cs);\n\n\t\tSleep(20);\n\n\t\t//通知生产者生产\n\t\tReleaseSemaphore(hSemaphore_notFull,1,NULL);\n\t\t\n\t}\n\n\tprintf(\"**********%d消费者完美地结束了工作\\n\",GetCurrentThreadId());\n\n\treturn 0;\n}\n```\n\n## 读者写者\n\n## 问题描述\n\n有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者在读文件时写者也不去能写文件。\n\n### 问题分析\n\n同步:1.写者要等到没有读者时才能去写文件 2.所有读者要等待写者完成写文件后才能去读文件\n\n人工事件+自动事件\n\n代码如下:\n\n```\n#include<iostream>\n#include<windows.h>\n#include<process.h>\n/*读者写者   有一个写者和多个读者  写和读不能同时进行  可以同时读*/\n/*利用事件进行同步通知*/\n/*用一个变量记录正在读的个数  第一个读的线程设置不能写入标志，最后一个读完的线程解除不能写入标志*/\nHANDLE g_hEventRead,g_hEventWrite;\nCRITICAL_SECTION cs;\nint g_ReaderNum;\n\nunsigned __stdcall WriteProc( void * );\nunsigned __stdcall ReadProc( void * );\n\nint main()\n{\n\tg_hEventRead = CreateEvent(NULL,TRUE,TRUE,NULL);\t//有事件  人工\n\tg_hEventWrite = CreateEvent(NULL,FALSE,FALSE,NULL);\n\tInitializeCriticalSection(&cs);\n\tHANDLE handle[5];\n\n\thandle[0] = (HANDLE)_beginthreadex(NULL,0,WriteProc,NULL,0,NULL);\n\thandle[1] = (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);\n\thandle[2] = (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);\n\n\tSleep(50);\n\thandle[3] = (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);\n\thandle[4] = (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);\n\n\n\tWaitForMultipleObjects(5,handle,TRUE,INFINITE);\n\tfor(int i = 0;i<5;i++)\n\t\tCloseHandle(handle[i]);\n\tCloseHandle(g_hEventRead);\n\tCloseHandle(g_hEventWrite);\n\tDeleteCriticalSection(&cs);\n\tgetchar();\n\treturn 0;\n}\n\nunsigned __stdcall WriteProc( void * lparma){\n\n\t\tprintf(\"写者线程等待写操作\\n\",GetCurrentThreadId());\n\t\tWaitForSingleObject(g_hEventWrite,INFINITE);\n\n\t\tResetEvent(g_hEventRead);\t  //控制不能进行读操作\n\t\tprintf(\"写者线程正在进行写操作\\n\");\n\n\t\tSleep(rand()%100);\n\t\tprintf(\"写者线程结束写操作\\n\");\n\n\t\tSetEvent(g_hEventRead);//告诉读者可以开始读了\n\n\t\treturn 0;\n\n}\nunsigned __stdcall ReadProc( void *lparma ){\n\n\n\t\t/*由于读者等待的是人工事件 一旦有事件并且不置成无信号的话  就可以让线程共享*/\n\t\tprintf(\"%d读者线程等待进行读操作\\n\",GetCurrentThreadId());\n\t\tWaitForSingleObject(g_hEventRead,INFINITE);\n\t\t\n\t\tEnterCriticalSection(&cs);\n\t\tg_ReaderNum++;\n\t\tif(g_ReaderNum == 1)\t\t//一旦有读者开始读 就不让写者工作\n\t\t\tResetEvent(g_hEventWrite);\n\t\tLeaveCriticalSection(&cs);\n\t\t\n\t\tprintf(\"%d读者线程正在进行读操作\\n\",GetCurrentThreadId());\n\n\t\tSleep(rand()%100);\n\t\tprintf(\"%d读者线程结束读操作\\n\",GetCurrentThreadId());\n\t\tEnterCriticalSection(&cs);\t\n\t\tg_ReaderNum--;\n\t\tif(g_ReaderNum == 0)\t   //读者全部读完之后，告诉写者可以工作了\n\t\t\tSetEvent(g_hEventWrite);\n\t\tLeaveCriticalSection(&cs);\n\n\t\treturn 0;\n}\n```\n\n还可以通过读写锁实现\n\n##### 读写锁(SRWLOCK)\n\n读写锁在对资源进行保护的同时，还能区分想要读取资源值的线程（读取者线程）和想要更新资源的线程（写入者线程）。对于读取者线程，读写锁会允许他们并发的执行。当有写入者线程在占有资源时，读写锁会让其它写入者线程和读取者线程等待\n\n初始化:InitializeSRWLock\n\n写入者线程申请写资源:AcquireSRWLockExclusive\n\n写入者线程释放对资源的占用：ReleaseSRWLockExclusive\n\n读取者线程申请读资源:AcquireSRWLockShared\n\n读取者线程释放对资源的占用：ReleaseSRWLockShared\n\n注意：1.一个线程仅能锁定资源一次，不能多次锁定资源。2.先声明后初始化，不用销毁，系统自动清理\n\n只要在线程函数中对读写操作加读写锁就可以了，比事件来得简单多了。\n\n","source":"_posts/线程同步经典问题练习.md","raw":"---\ntitle: 线程同步经典问题练习\ndate: 2018-11-09 19:29:37\ntags: 操作系统\n---\n\n## 生产者-消费者\n\n### 问题描述\n\n若干个生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个具有多个缓冲区的缓冲池，生产者将它生产的产品放入一个缓冲区中，消费者可以从缓冲区中取走产品进行消费\n\n### 问题分析\n同步: 1.缓冲区满时  生产者不能生产  阻塞  2.缓冲区空时  消费者不能消费  阻塞\n互斥:  生产和消费是互斥行为\n信号量+关键段\n\n代码如下:\n\n```\n#include<iostream>\n#include<windows.h>\n#include<process.h>\nusing namespace std;\n/*两个生产者 两个消费者  四块缓冲区*/\nconst int GoodsMax = 10;\nCRITICAL_SECTION cs;\nHANDLE hSemaphore_notFull;\nHANDLE hSemaphore_notempty;\nunsigned __stdcall ProducerProc( void * );\nunsigned __stdcall ConsumerProc( void * );\nconst int bufsize = 4;\nint buf[bufsize]; //用数组实现循环队列模拟缓冲区\nint g_x,g_y;\nint goods = 1; //模拟产品\nbool Pro_exit_flag = FALSE;\nbool Con_exit_flag = FALSE;\nint main()\n{\n\tInitializeCriticalSection(&cs);\n\thSemaphore_notFull = CreateSemaphore(NULL,4,4,NULL);\n\thSemaphore_notempty = CreateSemaphore(NULL,0,4,NULL);\n\tHANDLE handle[4];\n\thandle[0] = (HANDLE)_beginthreadex(NULL,0,ProducerProc,NULL,0,NULL);\n\thandle[1] = (HANDLE)_beginthreadex(NULL,0,ProducerProc,NULL,0,NULL);\n\thandle[2] = (HANDLE)_beginthreadex(NULL,0,ConsumerProc,NULL,0,NULL);\n\thandle[3] = (HANDLE)_beginthreadex(NULL,0,ConsumerProc,NULL,0,NULL);\n\tWaitForMultipleObjects(4,handle,TRUE,INFINITE);\n\tCloseHandle(hSemaphore_notFull);\n\tCloseHandle(hSemaphore_notempty);\n\tCloseHandle(handle[0]);\n\tCloseHandle(handle[1]);\n\tCloseHandle(handle[2]);\n\tCloseHandle(handle[3]);\n\tDeleteCriticalSection(&cs);\n\n\tgetchar();\n\treturn 0;\n}\n\n\nunsigned __stdcall ProducerProc(void* lparma){\n\n\twhile(1){\n\n\t\t//等待有空余的缓冲区，阻塞在满的时候\n\t\tWaitForSingleObject(hSemaphore_notFull,INFINITE);\n\n\t\tEnterCriticalSection(&cs);\n\t\tif(!Pro_exit_flag)\n\t\t{\n\t\t\tbuf[g_x] = goods;\n\t\t\tprintf(\"%d生产者将数据%d放入缓冲区%d\\n\",GetCurrentThreadId(),goods,g_x);\n\t\t}\n\t\tif(goods == GoodsMax)\n\t\t{\n\t\t   LeaveCriticalSection(&cs);\n\t\t   //通知另一个生产者线程退出，工作已经结束了\n\t\t   ReleaseSemaphore(hSemaphore_notFull,1,NULL);\n\n\t\t   ReleaseSemaphore(hSemaphore_notempty,1,NULL);//通知消费者消费\n\t\t   Pro_exit_flag = TRUE;\n\t\t   break;\n\t\t}\n\t\tgoods++;\n\t\tg_x = (g_x+1)%bufsize;\n\t\tLeaveCriticalSection(&cs);\n\t\t\n\t\tReleaseSemaphore(hSemaphore_notempty,1,NULL); //通知消费可以消费了\n\t}\n\n\tprintf(\"************%d生产者已经完美地结束了工作\\n\",GetCurrentThreadId());\n\n\treturn 0;\n}\nunsigned __stdcall ConsumerProc( void * lparma){\n\n\twhile(1){\n\t\t//等待缓冲区有东西\n\t\tWaitForSingleObject(hSemaphore_notempty,INFINITE);\t\n\t\tEnterCriticalSection(&cs);\n\t\tif(!Con_exit_flag)\n\t\t\tprintf(\"\\t%d消费者将数据%d从缓冲区%d拿出\\n\",GetCurrentThreadId(),buf[g_y],g_y);\n\t\tif(buf[g_y] == GoodsMax){\n\t\t\t LeaveCriticalSection(&cs);\t \n\t\t\t ReleaseSemaphore(hSemaphore_notempty,1,NULL);  //无故释放一个信号量告诉另一个线程退出\n\t\t\t Con_exit_flag = TRUE;\n\t\t\t break;\n\t\t}\n\t\tg_y = (g_y+1)%bufsize;\n\t\tLeaveCriticalSection(&cs);\n\n\t\tSleep(20);\n\n\t\t//通知生产者生产\n\t\tReleaseSemaphore(hSemaphore_notFull,1,NULL);\n\t\t\n\t}\n\n\tprintf(\"**********%d消费者完美地结束了工作\\n\",GetCurrentThreadId());\n\n\treturn 0;\n}\n```\n\n## 读者写者\n\n## 问题描述\n\n有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者在读文件时写者也不去能写文件。\n\n### 问题分析\n\n同步:1.写者要等到没有读者时才能去写文件 2.所有读者要等待写者完成写文件后才能去读文件\n\n人工事件+自动事件\n\n代码如下:\n\n```\n#include<iostream>\n#include<windows.h>\n#include<process.h>\n/*读者写者   有一个写者和多个读者  写和读不能同时进行  可以同时读*/\n/*利用事件进行同步通知*/\n/*用一个变量记录正在读的个数  第一个读的线程设置不能写入标志，最后一个读完的线程解除不能写入标志*/\nHANDLE g_hEventRead,g_hEventWrite;\nCRITICAL_SECTION cs;\nint g_ReaderNum;\n\nunsigned __stdcall WriteProc( void * );\nunsigned __stdcall ReadProc( void * );\n\nint main()\n{\n\tg_hEventRead = CreateEvent(NULL,TRUE,TRUE,NULL);\t//有事件  人工\n\tg_hEventWrite = CreateEvent(NULL,FALSE,FALSE,NULL);\n\tInitializeCriticalSection(&cs);\n\tHANDLE handle[5];\n\n\thandle[0] = (HANDLE)_beginthreadex(NULL,0,WriteProc,NULL,0,NULL);\n\thandle[1] = (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);\n\thandle[2] = (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);\n\n\tSleep(50);\n\thandle[3] = (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);\n\thandle[4] = (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);\n\n\n\tWaitForMultipleObjects(5,handle,TRUE,INFINITE);\n\tfor(int i = 0;i<5;i++)\n\t\tCloseHandle(handle[i]);\n\tCloseHandle(g_hEventRead);\n\tCloseHandle(g_hEventWrite);\n\tDeleteCriticalSection(&cs);\n\tgetchar();\n\treturn 0;\n}\n\nunsigned __stdcall WriteProc( void * lparma){\n\n\t\tprintf(\"写者线程等待写操作\\n\",GetCurrentThreadId());\n\t\tWaitForSingleObject(g_hEventWrite,INFINITE);\n\n\t\tResetEvent(g_hEventRead);\t  //控制不能进行读操作\n\t\tprintf(\"写者线程正在进行写操作\\n\");\n\n\t\tSleep(rand()%100);\n\t\tprintf(\"写者线程结束写操作\\n\");\n\n\t\tSetEvent(g_hEventRead);//告诉读者可以开始读了\n\n\t\treturn 0;\n\n}\nunsigned __stdcall ReadProc( void *lparma ){\n\n\n\t\t/*由于读者等待的是人工事件 一旦有事件并且不置成无信号的话  就可以让线程共享*/\n\t\tprintf(\"%d读者线程等待进行读操作\\n\",GetCurrentThreadId());\n\t\tWaitForSingleObject(g_hEventRead,INFINITE);\n\t\t\n\t\tEnterCriticalSection(&cs);\n\t\tg_ReaderNum++;\n\t\tif(g_ReaderNum == 1)\t\t//一旦有读者开始读 就不让写者工作\n\t\t\tResetEvent(g_hEventWrite);\n\t\tLeaveCriticalSection(&cs);\n\t\t\n\t\tprintf(\"%d读者线程正在进行读操作\\n\",GetCurrentThreadId());\n\n\t\tSleep(rand()%100);\n\t\tprintf(\"%d读者线程结束读操作\\n\",GetCurrentThreadId());\n\t\tEnterCriticalSection(&cs);\t\n\t\tg_ReaderNum--;\n\t\tif(g_ReaderNum == 0)\t   //读者全部读完之后，告诉写者可以工作了\n\t\t\tSetEvent(g_hEventWrite);\n\t\tLeaveCriticalSection(&cs);\n\n\t\treturn 0;\n}\n```\n\n还可以通过读写锁实现\n\n##### 读写锁(SRWLOCK)\n\n读写锁在对资源进行保护的同时，还能区分想要读取资源值的线程（读取者线程）和想要更新资源的线程（写入者线程）。对于读取者线程，读写锁会允许他们并发的执行。当有写入者线程在占有资源时，读写锁会让其它写入者线程和读取者线程等待\n\n初始化:InitializeSRWLock\n\n写入者线程申请写资源:AcquireSRWLockExclusive\n\n写入者线程释放对资源的占用：ReleaseSRWLockExclusive\n\n读取者线程申请读资源:AcquireSRWLockShared\n\n读取者线程释放对资源的占用：ReleaseSRWLockShared\n\n注意：1.一个线程仅能锁定资源一次，不能多次锁定资源。2.先声明后初始化，不用销毁，系统自动清理\n\n只要在线程函数中对读写操作加读写锁就可以了，比事件来得简单多了。\n\n","slug":"线程同步经典问题练习","published":1,"updated":"2021-12-06T05:30:36.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7w002b96cab7ot6dfc","content":"<h2 id=\"生产者-消费者\"><a href=\"#生产者-消费者\" class=\"headerlink\" title=\"生产者-消费者\"></a>生产者-消费者</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>若干个生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个具有多个缓冲区的缓冲池，生产者将它生产的产品放入一个缓冲区中，消费者可以从缓冲区中取走产品进行消费</p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>同步: 1.缓冲区满时  生产者不能生产  阻塞  2.缓冲区空时  消费者不能消费  阻塞<br>互斥:  生产和消费是互斥行为<br>信号量+关键段</p>\n<p>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;windows.h&gt;</span><br><span class=\"line\">#include&lt;process.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">&#x2F;*两个生产者 两个消费者  四块缓冲区*&#x2F;</span><br><span class=\"line\">const int GoodsMax &#x3D; 10;</span><br><span class=\"line\">CRITICAL_SECTION cs;</span><br><span class=\"line\">HANDLE hSemaphore_notFull;</span><br><span class=\"line\">HANDLE hSemaphore_notempty;</span><br><span class=\"line\">unsigned __stdcall ProducerProc( void * );</span><br><span class=\"line\">unsigned __stdcall ConsumerProc( void * );</span><br><span class=\"line\">const int bufsize &#x3D; 4;</span><br><span class=\"line\">int buf[bufsize]; &#x2F;&#x2F;用数组实现循环队列模拟缓冲区</span><br><span class=\"line\">int g_x,g_y;</span><br><span class=\"line\">int goods &#x3D; 1; &#x2F;&#x2F;模拟产品</span><br><span class=\"line\">bool Pro_exit_flag &#x3D; FALSE;</span><br><span class=\"line\">bool Con_exit_flag &#x3D; FALSE;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tInitializeCriticalSection(&amp;cs);</span><br><span class=\"line\">\thSemaphore_notFull &#x3D; CreateSemaphore(NULL,4,4,NULL);</span><br><span class=\"line\">\thSemaphore_notempty &#x3D; CreateSemaphore(NULL,0,4,NULL);</span><br><span class=\"line\">\tHANDLE handle[4];</span><br><span class=\"line\">\thandle[0] &#x3D; (HANDLE)_beginthreadex(NULL,0,ProducerProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[1] &#x3D; (HANDLE)_beginthreadex(NULL,0,ProducerProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[2] &#x3D; (HANDLE)_beginthreadex(NULL,0,ConsumerProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[3] &#x3D; (HANDLE)_beginthreadex(NULL,0,ConsumerProc,NULL,0,NULL);</span><br><span class=\"line\">\tWaitForMultipleObjects(4,handle,TRUE,INFINITE);</span><br><span class=\"line\">\tCloseHandle(hSemaphore_notFull);</span><br><span class=\"line\">\tCloseHandle(hSemaphore_notempty);</span><br><span class=\"line\">\tCloseHandle(handle[0]);</span><br><span class=\"line\">\tCloseHandle(handle[1]);</span><br><span class=\"line\">\tCloseHandle(handle[2]);</span><br><span class=\"line\">\tCloseHandle(handle[3]);</span><br><span class=\"line\">\tDeleteCriticalSection(&amp;cs);</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">unsigned __stdcall ProducerProc(void* lparma)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F;等待有空余的缓冲区，阻塞在满的时候</span><br><span class=\"line\">\t\tWaitForSingleObject(hSemaphore_notFull,INFINITE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tEnterCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\tif(!Pro_exit_flag)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbuf[g_x] &#x3D; goods;</span><br><span class=\"line\">\t\t\tprintf(&quot;%d生产者将数据%d放入缓冲区%d\\n&quot;,GetCurrentThreadId(),goods,g_x);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(goods &#x3D;&#x3D; GoodsMax)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t   LeaveCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\t   &#x2F;&#x2F;通知另一个生产者线程退出，工作已经结束了</span><br><span class=\"line\">\t\t   ReleaseSemaphore(hSemaphore_notFull,1,NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t   ReleaseSemaphore(hSemaphore_notempty,1,NULL);&#x2F;&#x2F;通知消费者消费</span><br><span class=\"line\">\t\t   Pro_exit_flag &#x3D; TRUE;</span><br><span class=\"line\">\t\t   break;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tgoods++;</span><br><span class=\"line\">\t\tg_x &#x3D; (g_x+1)%bufsize;</span><br><span class=\"line\">\t\tLeaveCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tReleaseSemaphore(hSemaphore_notempty,1,NULL); &#x2F;&#x2F;通知消费可以消费了</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(&quot;************%d生产者已经完美地结束了工作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unsigned __stdcall ConsumerProc( void * lparma)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;等待缓冲区有东西</span><br><span class=\"line\">\t\tWaitForSingleObject(hSemaphore_notempty,INFINITE);\t</span><br><span class=\"line\">\t\tEnterCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\tif(!Con_exit_flag)</span><br><span class=\"line\">\t\t\tprintf(&quot;\\t%d消费者将数据%d从缓冲区%d拿出\\n&quot;,GetCurrentThreadId(),buf[g_y],g_y);</span><br><span class=\"line\">\t\tif(buf[g_y] &#x3D;&#x3D; GoodsMax)&#123;</span><br><span class=\"line\">\t\t\t LeaveCriticalSection(&amp;cs);\t </span><br><span class=\"line\">\t\t\t ReleaseSemaphore(hSemaphore_notempty,1,NULL);  &#x2F;&#x2F;无故释放一个信号量告诉另一个线程退出</span><br><span class=\"line\">\t\t\t Con_exit_flag &#x3D; TRUE;</span><br><span class=\"line\">\t\t\t break;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tg_y &#x3D; (g_y+1)%bufsize;</span><br><span class=\"line\">\t\tLeaveCriticalSection(&amp;cs);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(20);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F;通知生产者生产</span><br><span class=\"line\">\t\tReleaseSemaphore(hSemaphore_notFull,1,NULL);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(&quot;**********%d消费者完美地结束了工作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"读者写者\"><a href=\"#读者写者\" class=\"headerlink\" title=\"读者写者\"></a>读者写者</h2><h2 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者在读文件时写者也不去能写文件。</p>\n<h3 id=\"问题分析-1\"><a href=\"#问题分析-1\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>同步:1.写者要等到没有读者时才能去写文件 2.所有读者要等待写者完成写文件后才能去读文件</p>\n<p>人工事件+自动事件</p>\n<p>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;windows.h&gt;</span><br><span class=\"line\">#include&lt;process.h&gt;</span><br><span class=\"line\">&#x2F;*读者写者   有一个写者和多个读者  写和读不能同时进行  可以同时读*&#x2F;</span><br><span class=\"line\">&#x2F;*利用事件进行同步通知*&#x2F;</span><br><span class=\"line\">&#x2F;*用一个变量记录正在读的个数  第一个读的线程设置不能写入标志，最后一个读完的线程解除不能写入标志*&#x2F;</span><br><span class=\"line\">HANDLE g_hEventRead,g_hEventWrite;</span><br><span class=\"line\">CRITICAL_SECTION cs;</span><br><span class=\"line\">int g_ReaderNum;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned __stdcall WriteProc( void * );</span><br><span class=\"line\">unsigned __stdcall ReadProc( void * );</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tg_hEventRead &#x3D; CreateEvent(NULL,TRUE,TRUE,NULL);\t&#x2F;&#x2F;有事件  人工</span><br><span class=\"line\">\tg_hEventWrite &#x3D; CreateEvent(NULL,FALSE,FALSE,NULL);</span><br><span class=\"line\">\tInitializeCriticalSection(&amp;cs);</span><br><span class=\"line\">\tHANDLE handle[5];</span><br><span class=\"line\"></span><br><span class=\"line\">\thandle[0] &#x3D; (HANDLE)_beginthreadex(NULL,0,WriteProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[1] &#x3D; (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[2] &#x3D; (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSleep(50);</span><br><span class=\"line\">\thandle[3] &#x3D; (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[4] &#x3D; (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tWaitForMultipleObjects(5,handle,TRUE,INFINITE);</span><br><span class=\"line\">\tfor(int i &#x3D; 0;i&lt;5;i++)</span><br><span class=\"line\">\t\tCloseHandle(handle[i]);</span><br><span class=\"line\">\tCloseHandle(g_hEventRead);</span><br><span class=\"line\">\tCloseHandle(g_hEventWrite);</span><br><span class=\"line\">\tDeleteCriticalSection(&amp;cs);</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned __stdcall WriteProc( void * lparma)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprintf(&quot;写者线程等待写操作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\">\t\tWaitForSingleObject(g_hEventWrite,INFINITE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tResetEvent(g_hEventRead);\t  &#x2F;&#x2F;控制不能进行读操作</span><br><span class=\"line\">\t\tprintf(&quot;写者线程正在进行写操作\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(rand()%100);</span><br><span class=\"line\">\t\tprintf(&quot;写者线程结束写操作\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSetEvent(g_hEventRead);&#x2F;&#x2F;告诉读者可以开始读了</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unsigned __stdcall ReadProc( void *lparma )&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;*由于读者等待的是人工事件 一旦有事件并且不置成无信号的话  就可以让线程共享*&#x2F;</span><br><span class=\"line\">\t\tprintf(&quot;%d读者线程等待进行读操作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\">\t\tWaitForSingleObject(g_hEventRead,INFINITE);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tEnterCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\tg_ReaderNum++;</span><br><span class=\"line\">\t\tif(g_ReaderNum &#x3D;&#x3D; 1)\t\t&#x2F;&#x2F;一旦有读者开始读 就不让写者工作</span><br><span class=\"line\">\t\t\tResetEvent(g_hEventWrite);</span><br><span class=\"line\">\t\tLeaveCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tprintf(&quot;%d读者线程正在进行读操作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(rand()%100);</span><br><span class=\"line\">\t\tprintf(&quot;%d读者线程结束读操作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\">\t\tEnterCriticalSection(&amp;cs);\t</span><br><span class=\"line\">\t\tg_ReaderNum--;</span><br><span class=\"line\">\t\tif(g_ReaderNum &#x3D;&#x3D; 0)\t   &#x2F;&#x2F;读者全部读完之后，告诉写者可以工作了</span><br><span class=\"line\">\t\t\tSetEvent(g_hEventWrite);</span><br><span class=\"line\">\t\tLeaveCriticalSection(&amp;cs);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以通过读写锁实现</p>\n<h5 id=\"读写锁-SRWLOCK\"><a href=\"#读写锁-SRWLOCK\" class=\"headerlink\" title=\"读写锁(SRWLOCK)\"></a>读写锁(SRWLOCK)</h5><p>读写锁在对资源进行保护的同时，还能区分想要读取资源值的线程（读取者线程）和想要更新资源的线程（写入者线程）。对于读取者线程，读写锁会允许他们并发的执行。当有写入者线程在占有资源时，读写锁会让其它写入者线程和读取者线程等待</p>\n<p>初始化:InitializeSRWLock</p>\n<p>写入者线程申请写资源:AcquireSRWLockExclusive</p>\n<p>写入者线程释放对资源的占用：ReleaseSRWLockExclusive</p>\n<p>读取者线程申请读资源:AcquireSRWLockShared</p>\n<p>读取者线程释放对资源的占用：ReleaseSRWLockShared</p>\n<p>注意：1.一个线程仅能锁定资源一次，不能多次锁定资源。2.先声明后初始化，不用销毁，系统自动清理</p>\n<p>只要在线程函数中对读写操作加读写锁就可以了，比事件来得简单多了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"生产者-消费者\"><a href=\"#生产者-消费者\" class=\"headerlink\" title=\"生产者-消费者\"></a>生产者-消费者</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>若干个生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个具有多个缓冲区的缓冲池，生产者将它生产的产品放入一个缓冲区中，消费者可以从缓冲区中取走产品进行消费</p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>同步: 1.缓冲区满时  生产者不能生产  阻塞  2.缓冲区空时  消费者不能消费  阻塞<br>互斥:  生产和消费是互斥行为<br>信号量+关键段</p>\n<p>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;windows.h&gt;</span><br><span class=\"line\">#include&lt;process.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">&#x2F;*两个生产者 两个消费者  四块缓冲区*&#x2F;</span><br><span class=\"line\">const int GoodsMax &#x3D; 10;</span><br><span class=\"line\">CRITICAL_SECTION cs;</span><br><span class=\"line\">HANDLE hSemaphore_notFull;</span><br><span class=\"line\">HANDLE hSemaphore_notempty;</span><br><span class=\"line\">unsigned __stdcall ProducerProc( void * );</span><br><span class=\"line\">unsigned __stdcall ConsumerProc( void * );</span><br><span class=\"line\">const int bufsize &#x3D; 4;</span><br><span class=\"line\">int buf[bufsize]; &#x2F;&#x2F;用数组实现循环队列模拟缓冲区</span><br><span class=\"line\">int g_x,g_y;</span><br><span class=\"line\">int goods &#x3D; 1; &#x2F;&#x2F;模拟产品</span><br><span class=\"line\">bool Pro_exit_flag &#x3D; FALSE;</span><br><span class=\"line\">bool Con_exit_flag &#x3D; FALSE;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tInitializeCriticalSection(&amp;cs);</span><br><span class=\"line\">\thSemaphore_notFull &#x3D; CreateSemaphore(NULL,4,4,NULL);</span><br><span class=\"line\">\thSemaphore_notempty &#x3D; CreateSemaphore(NULL,0,4,NULL);</span><br><span class=\"line\">\tHANDLE handle[4];</span><br><span class=\"line\">\thandle[0] &#x3D; (HANDLE)_beginthreadex(NULL,0,ProducerProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[1] &#x3D; (HANDLE)_beginthreadex(NULL,0,ProducerProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[2] &#x3D; (HANDLE)_beginthreadex(NULL,0,ConsumerProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[3] &#x3D; (HANDLE)_beginthreadex(NULL,0,ConsumerProc,NULL,0,NULL);</span><br><span class=\"line\">\tWaitForMultipleObjects(4,handle,TRUE,INFINITE);</span><br><span class=\"line\">\tCloseHandle(hSemaphore_notFull);</span><br><span class=\"line\">\tCloseHandle(hSemaphore_notempty);</span><br><span class=\"line\">\tCloseHandle(handle[0]);</span><br><span class=\"line\">\tCloseHandle(handle[1]);</span><br><span class=\"line\">\tCloseHandle(handle[2]);</span><br><span class=\"line\">\tCloseHandle(handle[3]);</span><br><span class=\"line\">\tDeleteCriticalSection(&amp;cs);</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">unsigned __stdcall ProducerProc(void* lparma)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F;等待有空余的缓冲区，阻塞在满的时候</span><br><span class=\"line\">\t\tWaitForSingleObject(hSemaphore_notFull,INFINITE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tEnterCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\tif(!Pro_exit_flag)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbuf[g_x] &#x3D; goods;</span><br><span class=\"line\">\t\t\tprintf(&quot;%d生产者将数据%d放入缓冲区%d\\n&quot;,GetCurrentThreadId(),goods,g_x);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif(goods &#x3D;&#x3D; GoodsMax)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t   LeaveCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\t   &#x2F;&#x2F;通知另一个生产者线程退出，工作已经结束了</span><br><span class=\"line\">\t\t   ReleaseSemaphore(hSemaphore_notFull,1,NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t   ReleaseSemaphore(hSemaphore_notempty,1,NULL);&#x2F;&#x2F;通知消费者消费</span><br><span class=\"line\">\t\t   Pro_exit_flag &#x3D; TRUE;</span><br><span class=\"line\">\t\t   break;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tgoods++;</span><br><span class=\"line\">\t\tg_x &#x3D; (g_x+1)%bufsize;</span><br><span class=\"line\">\t\tLeaveCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tReleaseSemaphore(hSemaphore_notempty,1,NULL); &#x2F;&#x2F;通知消费可以消费了</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(&quot;************%d生产者已经完美地结束了工作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unsigned __stdcall ConsumerProc( void * lparma)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;等待缓冲区有东西</span><br><span class=\"line\">\t\tWaitForSingleObject(hSemaphore_notempty,INFINITE);\t</span><br><span class=\"line\">\t\tEnterCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\tif(!Con_exit_flag)</span><br><span class=\"line\">\t\t\tprintf(&quot;\\t%d消费者将数据%d从缓冲区%d拿出\\n&quot;,GetCurrentThreadId(),buf[g_y],g_y);</span><br><span class=\"line\">\t\tif(buf[g_y] &#x3D;&#x3D; GoodsMax)&#123;</span><br><span class=\"line\">\t\t\t LeaveCriticalSection(&amp;cs);\t </span><br><span class=\"line\">\t\t\t ReleaseSemaphore(hSemaphore_notempty,1,NULL);  &#x2F;&#x2F;无故释放一个信号量告诉另一个线程退出</span><br><span class=\"line\">\t\t\t Con_exit_flag &#x3D; TRUE;</span><br><span class=\"line\">\t\t\t break;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tg_y &#x3D; (g_y+1)%bufsize;</span><br><span class=\"line\">\t\tLeaveCriticalSection(&amp;cs);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(20);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;&#x2F;通知生产者生产</span><br><span class=\"line\">\t\tReleaseSemaphore(hSemaphore_notFull,1,NULL);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprintf(&quot;**********%d消费者完美地结束了工作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"读者写者\"><a href=\"#读者写者\" class=\"headerlink\" title=\"读者写者\"></a>读者写者</h2><h2 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者在读文件时写者也不去能写文件。</p>\n<h3 id=\"问题分析-1\"><a href=\"#问题分析-1\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>同步:1.写者要等到没有读者时才能去写文件 2.所有读者要等待写者完成写文件后才能去读文件</p>\n<p>人工事件+自动事件</p>\n<p>代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;windows.h&gt;</span><br><span class=\"line\">#include&lt;process.h&gt;</span><br><span class=\"line\">&#x2F;*读者写者   有一个写者和多个读者  写和读不能同时进行  可以同时读*&#x2F;</span><br><span class=\"line\">&#x2F;*利用事件进行同步通知*&#x2F;</span><br><span class=\"line\">&#x2F;*用一个变量记录正在读的个数  第一个读的线程设置不能写入标志，最后一个读完的线程解除不能写入标志*&#x2F;</span><br><span class=\"line\">HANDLE g_hEventRead,g_hEventWrite;</span><br><span class=\"line\">CRITICAL_SECTION cs;</span><br><span class=\"line\">int g_ReaderNum;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned __stdcall WriteProc( void * );</span><br><span class=\"line\">unsigned __stdcall ReadProc( void * );</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tg_hEventRead &#x3D; CreateEvent(NULL,TRUE,TRUE,NULL);\t&#x2F;&#x2F;有事件  人工</span><br><span class=\"line\">\tg_hEventWrite &#x3D; CreateEvent(NULL,FALSE,FALSE,NULL);</span><br><span class=\"line\">\tInitializeCriticalSection(&amp;cs);</span><br><span class=\"line\">\tHANDLE handle[5];</span><br><span class=\"line\"></span><br><span class=\"line\">\thandle[0] &#x3D; (HANDLE)_beginthreadex(NULL,0,WriteProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[1] &#x3D; (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[2] &#x3D; (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSleep(50);</span><br><span class=\"line\">\thandle[3] &#x3D; (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);</span><br><span class=\"line\">\thandle[4] &#x3D; (HANDLE)_beginthreadex(NULL,0,ReadProc,NULL,0,NULL);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tWaitForMultipleObjects(5,handle,TRUE,INFINITE);</span><br><span class=\"line\">\tfor(int i &#x3D; 0;i&lt;5;i++)</span><br><span class=\"line\">\t\tCloseHandle(handle[i]);</span><br><span class=\"line\">\tCloseHandle(g_hEventRead);</span><br><span class=\"line\">\tCloseHandle(g_hEventWrite);</span><br><span class=\"line\">\tDeleteCriticalSection(&amp;cs);</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned __stdcall WriteProc( void * lparma)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprintf(&quot;写者线程等待写操作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\">\t\tWaitForSingleObject(g_hEventWrite,INFINITE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tResetEvent(g_hEventRead);\t  &#x2F;&#x2F;控制不能进行读操作</span><br><span class=\"line\">\t\tprintf(&quot;写者线程正在进行写操作\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(rand()%100);</span><br><span class=\"line\">\t\tprintf(&quot;写者线程结束写操作\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSetEvent(g_hEventRead);&#x2F;&#x2F;告诉读者可以开始读了</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">unsigned __stdcall ReadProc( void *lparma )&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#x2F;*由于读者等待的是人工事件 一旦有事件并且不置成无信号的话  就可以让线程共享*&#x2F;</span><br><span class=\"line\">\t\tprintf(&quot;%d读者线程等待进行读操作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\">\t\tWaitForSingleObject(g_hEventRead,INFINITE);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tEnterCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\tg_ReaderNum++;</span><br><span class=\"line\">\t\tif(g_ReaderNum &#x3D;&#x3D; 1)\t\t&#x2F;&#x2F;一旦有读者开始读 就不让写者工作</span><br><span class=\"line\">\t\t\tResetEvent(g_hEventWrite);</span><br><span class=\"line\">\t\tLeaveCriticalSection(&amp;cs);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tprintf(&quot;%d读者线程正在进行读操作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSleep(rand()%100);</span><br><span class=\"line\">\t\tprintf(&quot;%d读者线程结束读操作\\n&quot;,GetCurrentThreadId());</span><br><span class=\"line\">\t\tEnterCriticalSection(&amp;cs);\t</span><br><span class=\"line\">\t\tg_ReaderNum--;</span><br><span class=\"line\">\t\tif(g_ReaderNum &#x3D;&#x3D; 0)\t   &#x2F;&#x2F;读者全部读完之后，告诉写者可以工作了</span><br><span class=\"line\">\t\t\tSetEvent(g_hEventWrite);</span><br><span class=\"line\">\t\tLeaveCriticalSection(&amp;cs);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以通过读写锁实现</p>\n<h5 id=\"读写锁-SRWLOCK\"><a href=\"#读写锁-SRWLOCK\" class=\"headerlink\" title=\"读写锁(SRWLOCK)\"></a>读写锁(SRWLOCK)</h5><p>读写锁在对资源进行保护的同时，还能区分想要读取资源值的线程（读取者线程）和想要更新资源的线程（写入者线程）。对于读取者线程，读写锁会允许他们并发的执行。当有写入者线程在占有资源时，读写锁会让其它写入者线程和读取者线程等待</p>\n<p>初始化:InitializeSRWLock</p>\n<p>写入者线程申请写资源:AcquireSRWLockExclusive</p>\n<p>写入者线程释放对资源的占用：ReleaseSRWLockExclusive</p>\n<p>读取者线程申请读资源:AcquireSRWLockShared</p>\n<p>读取者线程释放对资源的占用：ReleaseSRWLockShared</p>\n<p>注意：1.一个线程仅能锁定资源一次，不能多次锁定资源。2.先声明后初始化，不用销毁，系统自动清理</p>\n<p>只要在线程函数中对读写操作加读写锁就可以了，比事件来得简单多了。</p>\n"},{"title":"线程池","date":"2019-04-19T12:33:47.000Z","_content":"\n用线程池实现一个简易的Web服务器，[代码链接](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/tree/master/15_chapter/Web_server)\n\n采用半同步/半反应堆并发模式，这种模式下主线程负责管理监听socket和连接socket，有新的连接，主线程建立连接，有新的事件发生，插入到请求队列，工作线程从队列中取出任务并执行。\n\n首先，需要准备好一个线程池，采用模板类  模板的参数是http_coon类对象，这个类待会再介绍\n\n<!--more-->\n\n线程池主要封装：\n\n- 线程池的线程数量(固定，初始化的时候传入)\n- 请求队列允许的最大请求数(也就是同一时刻队列中能同时存在的任务总数)\n- 类型为pthread_t的指针，保存线程池中的线程\n- 任务队列(这里用的是链表模拟)\n- 保护任务队列的互斥锁\n- 信号量(表示是否有任务需要处理，每来一个任务都释放一个信号量，每个线程都阻塞等待信号量)\n- 线程结束标志\n\n主要的方法就：\n\n- 往队列中添加任务append\n- 线程处理函数调用run()\n- run()的工作是从队列中取出任务，并执行，执行用模板传入的对象调用自身的process方法\n\n这里需要注意的是：线程处理函数作为类的成员函数需要声明为静态成员。\n\n而线程处理函数拿到类的普通成员变量和函数的方法有：\n\n1.通过类的静态对象来调用，比如单例模式\n\n2.在创建线程的时候将类对象作为参数传给静态函数，比较常用，\n\n而线程处理函数的工作就是从队列中取出任务并执行，但是每次需要类中的普通成员都要用对象的指针拿到比较麻烦，因此单独写一个类的普通成员函数run()来完成自己要做的工作，而自己只需要调用run().\n\nmain函数的工作：\n\n进行一些网络的初始化工作，创建线程池，预先准备好http_conn数组，用连接socket作为数组的索引，代表所有可能的连接的连接信息。\n\n然后使用epoll管理监听socket和所有的连接socket，采用非阻塞socket和ET工作模式。\n\n对于连接socket，还设置EPOLLONESHOT选项\n\n主线程监听到新的连接，接收并交给epoll管理，监听到可读事件，主线程读取数据，然后将任务投递到线程池(调用append方法，相当于将数据给线程去进行逻辑处理)，监听到可写事件，主线程负责将数据写回给客户端(HTTP响应的报文是由线程完成填写的，主线程只负责发送),监听到错误，关闭连接。\n\n在进行逻辑处理的过程，用到一些技巧：\n\n- 有限状态机，主线程每接收一段数据就交给线程池处理，也就是在一边接收请求报文，一边进行报文分析，相对于完整地接收整个HTTP请求报文再去进行分析，这样做节省了很多时间。\n\n- 集中写writev，对于HTTP应答，可能有应答头部和消息体，而这两部分大概率内存不连续，一种常规的操作是准备一块足够大的缓冲区，将头部信息读入缓冲区，再将消息体也读入缓冲区，然后一起发送。但是，使用writev就可以将两块不连续的内存一次性发送出去，提升了效率。\n- 通过实现一个可变参数的函数add_response简化了添加HTTP响应的代码\n- 如果请求的是文件，经过一系统检验如果请求合法，使用mmap共享内存将文件映射到某块内存，提升了效率，避免了从硬盘读入内存的过程。\n\n[压力测试](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/16_chapter/stress_test.cpp)","source":"_posts/线程池.md","raw":"---\ntitle: 线程池\ndate: 2019-04-19 20:33:47\ntags:\n- Linux高性能服务器编程\n- 线程\n---\n\n用线程池实现一个简易的Web服务器，[代码链接](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/tree/master/15_chapter/Web_server)\n\n采用半同步/半反应堆并发模式，这种模式下主线程负责管理监听socket和连接socket，有新的连接，主线程建立连接，有新的事件发生，插入到请求队列，工作线程从队列中取出任务并执行。\n\n首先，需要准备好一个线程池，采用模板类  模板的参数是http_coon类对象，这个类待会再介绍\n\n<!--more-->\n\n线程池主要封装：\n\n- 线程池的线程数量(固定，初始化的时候传入)\n- 请求队列允许的最大请求数(也就是同一时刻队列中能同时存在的任务总数)\n- 类型为pthread_t的指针，保存线程池中的线程\n- 任务队列(这里用的是链表模拟)\n- 保护任务队列的互斥锁\n- 信号量(表示是否有任务需要处理，每来一个任务都释放一个信号量，每个线程都阻塞等待信号量)\n- 线程结束标志\n\n主要的方法就：\n\n- 往队列中添加任务append\n- 线程处理函数调用run()\n- run()的工作是从队列中取出任务，并执行，执行用模板传入的对象调用自身的process方法\n\n这里需要注意的是：线程处理函数作为类的成员函数需要声明为静态成员。\n\n而线程处理函数拿到类的普通成员变量和函数的方法有：\n\n1.通过类的静态对象来调用，比如单例模式\n\n2.在创建线程的时候将类对象作为参数传给静态函数，比较常用，\n\n而线程处理函数的工作就是从队列中取出任务并执行，但是每次需要类中的普通成员都要用对象的指针拿到比较麻烦，因此单独写一个类的普通成员函数run()来完成自己要做的工作，而自己只需要调用run().\n\nmain函数的工作：\n\n进行一些网络的初始化工作，创建线程池，预先准备好http_conn数组，用连接socket作为数组的索引，代表所有可能的连接的连接信息。\n\n然后使用epoll管理监听socket和所有的连接socket，采用非阻塞socket和ET工作模式。\n\n对于连接socket，还设置EPOLLONESHOT选项\n\n主线程监听到新的连接，接收并交给epoll管理，监听到可读事件，主线程读取数据，然后将任务投递到线程池(调用append方法，相当于将数据给线程去进行逻辑处理)，监听到可写事件，主线程负责将数据写回给客户端(HTTP响应的报文是由线程完成填写的，主线程只负责发送),监听到错误，关闭连接。\n\n在进行逻辑处理的过程，用到一些技巧：\n\n- 有限状态机，主线程每接收一段数据就交给线程池处理，也就是在一边接收请求报文，一边进行报文分析，相对于完整地接收整个HTTP请求报文再去进行分析，这样做节省了很多时间。\n\n- 集中写writev，对于HTTP应答，可能有应答头部和消息体，而这两部分大概率内存不连续，一种常规的操作是准备一块足够大的缓冲区，将头部信息读入缓冲区，再将消息体也读入缓冲区，然后一起发送。但是，使用writev就可以将两块不连续的内存一次性发送出去，提升了效率。\n- 通过实现一个可变参数的函数add_response简化了添加HTTP响应的代码\n- 如果请求的是文件，经过一系统检验如果请求合法，使用mmap共享内存将文件映射到某块内存，提升了效率，避免了从硬盘读入内存的过程。\n\n[压力测试](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/16_chapter/stress_test.cpp)","slug":"线程池","published":1,"updated":"2021-12-06T05:30:36.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7x002d96caap3x4lig","content":"<p>用线程池实现一个简易的Web服务器，<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/tree/master/15_chapter/Web_server\" target=\"_blank\" rel=\"noopener\">代码链接</a></p>\n<p>采用半同步/半反应堆并发模式，这种模式下主线程负责管理监听socket和连接socket，有新的连接，主线程建立连接，有新的事件发生，插入到请求队列，工作线程从队列中取出任务并执行。</p>\n<p>首先，需要准备好一个线程池，采用模板类  模板的参数是http_coon类对象，这个类待会再介绍</p>\n<a id=\"more\"></a>\n\n<p>线程池主要封装：</p>\n<ul>\n<li>线程池的线程数量(固定，初始化的时候传入)</li>\n<li>请求队列允许的最大请求数(也就是同一时刻队列中能同时存在的任务总数)</li>\n<li>类型为pthread_t的指针，保存线程池中的线程</li>\n<li>任务队列(这里用的是链表模拟)</li>\n<li>保护任务队列的互斥锁</li>\n<li>信号量(表示是否有任务需要处理，每来一个任务都释放一个信号量，每个线程都阻塞等待信号量)</li>\n<li>线程结束标志</li>\n</ul>\n<p>主要的方法就：</p>\n<ul>\n<li>往队列中添加任务append</li>\n<li>线程处理函数调用run()</li>\n<li>run()的工作是从队列中取出任务，并执行，执行用模板传入的对象调用自身的process方法</li>\n</ul>\n<p>这里需要注意的是：线程处理函数作为类的成员函数需要声明为静态成员。</p>\n<p>而线程处理函数拿到类的普通成员变量和函数的方法有：</p>\n<p>1.通过类的静态对象来调用，比如单例模式</p>\n<p>2.在创建线程的时候将类对象作为参数传给静态函数，比较常用，</p>\n<p>而线程处理函数的工作就是从队列中取出任务并执行，但是每次需要类中的普通成员都要用对象的指针拿到比较麻烦，因此单独写一个类的普通成员函数run()来完成自己要做的工作，而自己只需要调用run().</p>\n<p>main函数的工作：</p>\n<p>进行一些网络的初始化工作，创建线程池，预先准备好http_conn数组，用连接socket作为数组的索引，代表所有可能的连接的连接信息。</p>\n<p>然后使用epoll管理监听socket和所有的连接socket，采用非阻塞socket和ET工作模式。</p>\n<p>对于连接socket，还设置EPOLLONESHOT选项</p>\n<p>主线程监听到新的连接，接收并交给epoll管理，监听到可读事件，主线程读取数据，然后将任务投递到线程池(调用append方法，相当于将数据给线程去进行逻辑处理)，监听到可写事件，主线程负责将数据写回给客户端(HTTP响应的报文是由线程完成填写的，主线程只负责发送),监听到错误，关闭连接。</p>\n<p>在进行逻辑处理的过程，用到一些技巧：</p>\n<ul>\n<li><p>有限状态机，主线程每接收一段数据就交给线程池处理，也就是在一边接收请求报文，一边进行报文分析，相对于完整地接收整个HTTP请求报文再去进行分析，这样做节省了很多时间。</p>\n</li>\n<li><p>集中写writev，对于HTTP应答，可能有应答头部和消息体，而这两部分大概率内存不连续，一种常规的操作是准备一块足够大的缓冲区，将头部信息读入缓冲区，再将消息体也读入缓冲区，然后一起发送。但是，使用writev就可以将两块不连续的内存一次性发送出去，提升了效率。</p>\n</li>\n<li><p>通过实现一个可变参数的函数add_response简化了添加HTTP响应的代码</p>\n</li>\n<li><p>如果请求的是文件，经过一系统检验如果请求合法，使用mmap共享内存将文件映射到某块内存，提升了效率，避免了从硬盘读入内存的过程。</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/16_chapter/stress_test.cpp\" target=\"_blank\" rel=\"noopener\">压力测试</a></p>\n","site":{"data":{}},"excerpt":"<p>用线程池实现一个简易的Web服务器，<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/tree/master/15_chapter/Web_server\" target=\"_blank\" rel=\"noopener\">代码链接</a></p>\n<p>采用半同步/半反应堆并发模式，这种模式下主线程负责管理监听socket和连接socket，有新的连接，主线程建立连接，有新的事件发生，插入到请求队列，工作线程从队列中取出任务并执行。</p>\n<p>首先，需要准备好一个线程池，采用模板类  模板的参数是http_coon类对象，这个类待会再介绍</p>","more":"<p>线程池主要封装：</p>\n<ul>\n<li>线程池的线程数量(固定，初始化的时候传入)</li>\n<li>请求队列允许的最大请求数(也就是同一时刻队列中能同时存在的任务总数)</li>\n<li>类型为pthread_t的指针，保存线程池中的线程</li>\n<li>任务队列(这里用的是链表模拟)</li>\n<li>保护任务队列的互斥锁</li>\n<li>信号量(表示是否有任务需要处理，每来一个任务都释放一个信号量，每个线程都阻塞等待信号量)</li>\n<li>线程结束标志</li>\n</ul>\n<p>主要的方法就：</p>\n<ul>\n<li>往队列中添加任务append</li>\n<li>线程处理函数调用run()</li>\n<li>run()的工作是从队列中取出任务，并执行，执行用模板传入的对象调用自身的process方法</li>\n</ul>\n<p>这里需要注意的是：线程处理函数作为类的成员函数需要声明为静态成员。</p>\n<p>而线程处理函数拿到类的普通成员变量和函数的方法有：</p>\n<p>1.通过类的静态对象来调用，比如单例模式</p>\n<p>2.在创建线程的时候将类对象作为参数传给静态函数，比较常用，</p>\n<p>而线程处理函数的工作就是从队列中取出任务并执行，但是每次需要类中的普通成员都要用对象的指针拿到比较麻烦，因此单独写一个类的普通成员函数run()来完成自己要做的工作，而自己只需要调用run().</p>\n<p>main函数的工作：</p>\n<p>进行一些网络的初始化工作，创建线程池，预先准备好http_conn数组，用连接socket作为数组的索引，代表所有可能的连接的连接信息。</p>\n<p>然后使用epoll管理监听socket和所有的连接socket，采用非阻塞socket和ET工作模式。</p>\n<p>对于连接socket，还设置EPOLLONESHOT选项</p>\n<p>主线程监听到新的连接，接收并交给epoll管理，监听到可读事件，主线程读取数据，然后将任务投递到线程池(调用append方法，相当于将数据给线程去进行逻辑处理)，监听到可写事件，主线程负责将数据写回给客户端(HTTP响应的报文是由线程完成填写的，主线程只负责发送),监听到错误，关闭连接。</p>\n<p>在进行逻辑处理的过程，用到一些技巧：</p>\n<ul>\n<li><p>有限状态机，主线程每接收一段数据就交给线程池处理，也就是在一边接收请求报文，一边进行报文分析，相对于完整地接收整个HTTP请求报文再去进行分析，这样做节省了很多时间。</p>\n</li>\n<li><p>集中写writev，对于HTTP应答，可能有应答头部和消息体，而这两部分大概率内存不连续，一种常规的操作是准备一块足够大的缓冲区，将头部信息读入缓冲区，再将消息体也读入缓冲区，然后一起发送。但是，使用writev就可以将两块不连续的内存一次性发送出去，提升了效率。</p>\n</li>\n<li><p>通过实现一个可变参数的函数add_response简化了添加HTTP响应的代码</p>\n</li>\n<li><p>如果请求的是文件，经过一系统检验如果请求合法，使用mmap共享内存将文件映射到某块内存，提升了效率，避免了从硬盘读入内存的过程。</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/16_chapter/stress_test.cpp\" target=\"_blank\" rel=\"noopener\">压力测试</a></p>"},{"title":"算法整理","date":"2019-03-20T10:45:02.000Z","_content":"\n## 数组问题\n\n[二维数组中的查找](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.cpp)\n\n[旋转数组的最小数字](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.cpp)\n\n[调整数组顺序使奇数位于偶数前面](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.cpp)\n\n[顺时针打印矩阵](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.cpp)\n\n<!--more-->\n\n[数组中出现次数超过一半的数字](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.cpp)\n\n[最小的k个数](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.cpp)\n\n[连续子数组的最大和_dp问题](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp)\n\n[两个不相交的字数组的最大和](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp)\n\n[把数组排成最小的数](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.cpp)\n\n[数组中的逆序对](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.cpp)\n\n\n\n## 栈和队列\n\n[两个栈实现队列](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.cpp)\n\n[两个队列实现栈](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.cpp)\n\n[包含min函数的栈 leetcode 155](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.cpp)\n\n[栈的压入、弹出序列](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.cpp)\n\n[滑动窗口的最大值](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.cpp)\n\n[仅用递归函数和栈操作逆序一个栈](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88.cpp)\n\n[猫狗队列](https://www.cnblogs.com/PrimeLife/p/5318291.html)\n\n[用一个栈实现另一个栈的排序](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F.cpp)\n\n[用栈来求解汉诺塔问题](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E7%94%A8%E6%A0%88%E6%9D%A5%E6%B1%82%E8%A7%A3%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98.cpp)\n\n[构造数组的MaxTree]()\n\n[最大子矩阵的大小]()\n\n[京东环形烽火台问题]()\n\n## 链表问题\n\n[从尾到头打印链表 leetcode 206](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.cpp)\n\n[打印两个有序链表的公共部分](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%89%93%E5%8D%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86.cpp)\n\n[反转单向和双向链表]()\n\n[反转部分单向链表]()\n\n[合并两个有序的链表 leetcode 21](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.cpp)\n\n[链表中倒数第K个元素](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp)\n\n[在单链表和双链表中删除倒数第k个节点]()\n\n[删除链表的中间节点和a/b处的节点]()\n\n[复杂链表的复制 letcode 138](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.cpp)\n\n[判断链表是否有环，如果有环返回入环结点](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF.cpp)\n\n[两个无环单链表的第一个相交结点](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%97%A0%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9.cpp)\n\n[两个有环单链表的相交结点](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9.cpp)\n\n[删除链表中重复的结点](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.cpp)\n\n[判断一个链表是否为回文结构 leetcode 234 ](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84.cpp)\n\n[单向链表按某值划分左边小、中间相等、右边大](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E9%93%BE%E8%A1%A8Partition.cpp)\n\n[单链表中的数字相加  leetcode 2](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0.cpp)\n\n[给单链表重新排序(reorder) leetcode 143](https://github.com/oldbuffalo/DayDayUp/blob/master/list/leetcode143_reorder_list.cpp)\n\n\n\n## 树问题\n\n[二叉树的重建](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)\n\n[二叉树的子结构](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.cpp)\n\n[二叉树的镜像](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.cpp)\n\n[二叉搜索树的后序遍历序列](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.cpp)\n\n[二叉树中和为某一值的路径](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.cpp)\n\n[二叉搜索树变成双向链表](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E6%88%90%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.cpp)\n\n[二叉树的深度](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.cpp)\n\n[二叉树的后继结点](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9.cpp)\n\n[对称的二叉树](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)\n\n[之字型打印二叉树](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%B9%8B%E5%AD%97%E5%9E%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)\n\n[层次遍历_把二叉树打印成多行](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.cpp)\n\n[判断平衡二叉树](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)\n\n[序列化和反序列化二叉树](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.cpp)\n\n[二叉搜索树的第k个结点](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp)\n\n[数据流中的中位数](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.cpp)\n\n\n\n## 图问题\n\n\n\n## 位操作\n\n\n\n## 数值计算\n\n[整数中1出现的次数]()\n\n[丑数]()\n\n\n\n## 字符串问题\n\n\n\n## 排序\n\n\n\n## 搜索\n\n\n\n## 动态规划\n\n[矩形嵌套问题]()\n\n## 回溯\n\n\n\n","source":"_posts/算法整理.md","raw":"---\ntitle: 算法整理\ndate: 2019-03-20 18:45:02\ntags:\n- 数据结构\n- 算法\n---\n\n## 数组问题\n\n[二维数组中的查找](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.cpp)\n\n[旋转数组的最小数字](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.cpp)\n\n[调整数组顺序使奇数位于偶数前面](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.cpp)\n\n[顺时针打印矩阵](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.cpp)\n\n<!--more-->\n\n[数组中出现次数超过一半的数字](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.cpp)\n\n[最小的k个数](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.cpp)\n\n[连续子数组的最大和_dp问题](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp)\n\n[两个不相交的字数组的最大和](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp)\n\n[把数组排成最小的数](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.cpp)\n\n[数组中的逆序对](https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.cpp)\n\n\n\n## 栈和队列\n\n[两个栈实现队列](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.cpp)\n\n[两个队列实现栈](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.cpp)\n\n[包含min函数的栈 leetcode 155](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.cpp)\n\n[栈的压入、弹出序列](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.cpp)\n\n[滑动窗口的最大值](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.cpp)\n\n[仅用递归函数和栈操作逆序一个栈](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88.cpp)\n\n[猫狗队列](https://www.cnblogs.com/PrimeLife/p/5318291.html)\n\n[用一个栈实现另一个栈的排序](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F.cpp)\n\n[用栈来求解汉诺塔问题](https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E7%94%A8%E6%A0%88%E6%9D%A5%E6%B1%82%E8%A7%A3%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98.cpp)\n\n[构造数组的MaxTree]()\n\n[最大子矩阵的大小]()\n\n[京东环形烽火台问题]()\n\n## 链表问题\n\n[从尾到头打印链表 leetcode 206](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.cpp)\n\n[打印两个有序链表的公共部分](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%89%93%E5%8D%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86.cpp)\n\n[反转单向和双向链表]()\n\n[反转部分单向链表]()\n\n[合并两个有序的链表 leetcode 21](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.cpp)\n\n[链表中倒数第K个元素](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp)\n\n[在单链表和双链表中删除倒数第k个节点]()\n\n[删除链表的中间节点和a/b处的节点]()\n\n[复杂链表的复制 letcode 138](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.cpp)\n\n[判断链表是否有环，如果有环返回入环结点](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF.cpp)\n\n[两个无环单链表的第一个相交结点](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%97%A0%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9.cpp)\n\n[两个有环单链表的相交结点](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9.cpp)\n\n[删除链表中重复的结点](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.cpp)\n\n[判断一个链表是否为回文结构 leetcode 234 ](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84.cpp)\n\n[单向链表按某值划分左边小、中间相等、右边大](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E9%93%BE%E8%A1%A8Partition.cpp)\n\n[单链表中的数字相加  leetcode 2](https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0.cpp)\n\n[给单链表重新排序(reorder) leetcode 143](https://github.com/oldbuffalo/DayDayUp/blob/master/list/leetcode143_reorder_list.cpp)\n\n\n\n## 树问题\n\n[二叉树的重建](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)\n\n[二叉树的子结构](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.cpp)\n\n[二叉树的镜像](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.cpp)\n\n[二叉搜索树的后序遍历序列](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.cpp)\n\n[二叉树中和为某一值的路径](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.cpp)\n\n[二叉搜索树变成双向链表](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E6%88%90%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.cpp)\n\n[二叉树的深度](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.cpp)\n\n[二叉树的后继结点](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9.cpp)\n\n[对称的二叉树](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)\n\n[之字型打印二叉树](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%B9%8B%E5%AD%97%E5%9E%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)\n\n[层次遍历_把二叉树打印成多行](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.cpp)\n\n[判断平衡二叉树](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)\n\n[序列化和反序列化二叉树](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.cpp)\n\n[二叉搜索树的第k个结点](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp)\n\n[数据流中的中位数](https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.cpp)\n\n\n\n## 图问题\n\n\n\n## 位操作\n\n\n\n## 数值计算\n\n[整数中1出现的次数]()\n\n[丑数]()\n\n\n\n## 字符串问题\n\n\n\n## 排序\n\n\n\n## 搜索\n\n\n\n## 动态规划\n\n[矩形嵌套问题]()\n\n## 回溯\n\n\n\n","slug":"算法整理","published":1,"updated":"2021-12-06T05:30:36.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7x002f96ca596mgo4m","content":"<h2 id=\"数组问题\"><a href=\"#数组问题\" class=\"headerlink\" title=\"数组问题\"></a>数组问题</h2><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.cpp\" target=\"_blank\" rel=\"noopener\">二维数组中的查找</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.cpp\" target=\"_blank\" rel=\"noopener\">旋转数组的最小数字</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.cpp\" target=\"_blank\" rel=\"noopener\">调整数组顺序使奇数位于偶数前面</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.cpp\" target=\"_blank\" rel=\"noopener\">顺时针打印矩阵</a></p>\n<a id=\"more\"></a>\n\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.cpp\" target=\"_blank\" rel=\"noopener\">数组中出现次数超过一半的数字</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.cpp\" target=\"_blank\" rel=\"noopener\">最小的k个数</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp\" target=\"_blank\" rel=\"noopener\">连续子数组的最大和_dp问题</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp\" target=\"_blank\" rel=\"noopener\">两个不相交的字数组的最大和</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.cpp\" target=\"_blank\" rel=\"noopener\">把数组排成最小的数</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.cpp\" target=\"_blank\" rel=\"noopener\">数组中的逆序对</a></p>\n<h2 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h2><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.cpp\" target=\"_blank\" rel=\"noopener\">两个栈实现队列</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.cpp\" target=\"_blank\" rel=\"noopener\">两个队列实现栈</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.cpp\" target=\"_blank\" rel=\"noopener\">包含min函数的栈 leetcode 155</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.cpp\" target=\"_blank\" rel=\"noopener\">栈的压入、弹出序列</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.cpp\" target=\"_blank\" rel=\"noopener\">滑动窗口的最大值</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88.cpp\" target=\"_blank\" rel=\"noopener\">仅用递归函数和栈操作逆序一个栈</a></p>\n<p><a href=\"https://www.cnblogs.com/PrimeLife/p/5318291.html\" target=\"_blank\" rel=\"noopener\">猫狗队列</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F.cpp\" target=\"_blank\" rel=\"noopener\">用一个栈实现另一个栈的排序</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E7%94%A8%E6%A0%88%E6%9D%A5%E6%B1%82%E8%A7%A3%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98.cpp\" target=\"_blank\" rel=\"noopener\">用栈来求解汉诺塔问题</a></p>\n<p><a href=\"\">构造数组的MaxTree</a></p>\n<p><a href=\"\">最大子矩阵的大小</a></p>\n<p><a href=\"\">京东环形烽火台问题</a></p>\n<h2 id=\"链表问题\"><a href=\"#链表问题\" class=\"headerlink\" title=\"链表问题\"></a>链表问题</h2><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.cpp\" target=\"_blank\" rel=\"noopener\">从尾到头打印链表 leetcode 206</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%89%93%E5%8D%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86.cpp\" target=\"_blank\" rel=\"noopener\">打印两个有序链表的公共部分</a></p>\n<p><a href=\"\">反转单向和双向链表</a></p>\n<p><a href=\"\">反转部分单向链表</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.cpp\" target=\"_blank\" rel=\"noopener\">合并两个有序的链表 leetcode 21</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">链表中倒数第K个元素</a></p>\n<p><a href=\"\">在单链表和双链表中删除倒数第k个节点</a></p>\n<p><a href=\"\">删除链表的中间节点和a/b处的节点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.cpp\" target=\"_blank\" rel=\"noopener\">复杂链表的复制 letcode 138</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF.cpp\" target=\"_blank\" rel=\"noopener\">判断链表是否有环，如果有环返回入环结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%97%A0%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">两个无环单链表的第一个相交结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">两个有环单链表的相交结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">删除链表中重复的结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84.cpp\" target=\"_blank\" rel=\"noopener\">判断一个链表是否为回文结构 leetcode 234 </a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E9%93%BE%E8%A1%A8Partition.cpp\" target=\"_blank\" rel=\"noopener\">单向链表按某值划分左边小、中间相等、右边大</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0.cpp\" target=\"_blank\" rel=\"noopener\">单链表中的数字相加  leetcode 2</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/leetcode143_reorder_list.cpp\" target=\"_blank\" rel=\"noopener\">给单链表重新排序(reorder) leetcode 143</a></p>\n<h2 id=\"树问题\"><a href=\"#树问题\" class=\"headerlink\" title=\"树问题\"></a>树问题</h2><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的重建</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的子结构</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的镜像</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.cpp\" target=\"_blank\" rel=\"noopener\">二叉搜索树的后序遍历序列</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.cpp\" target=\"_blank\" rel=\"noopener\">二叉树中和为某一值的路径</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E6%88%90%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.cpp\" target=\"_blank\" rel=\"noopener\">二叉搜索树变成双向链表</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的深度</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的后继结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.cpp\" target=\"_blank\" rel=\"noopener\">对称的二叉树</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%B9%8B%E5%AD%97%E5%9E%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp\" target=\"_blank\" rel=\"noopener\">之字型打印二叉树</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.cpp\" target=\"_blank\" rel=\"noopener\">层次遍历_把二叉树打印成多行</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.cpp\" target=\"_blank\" rel=\"noopener\">判断平衡二叉树</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.cpp\" target=\"_blank\" rel=\"noopener\">序列化和反序列化二叉树</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">二叉搜索树的第k个结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.cpp\" target=\"_blank\" rel=\"noopener\">数据流中的中位数</a></p>\n<h2 id=\"图问题\"><a href=\"#图问题\" class=\"headerlink\" title=\"图问题\"></a>图问题</h2><h2 id=\"位操作\"><a href=\"#位操作\" class=\"headerlink\" title=\"位操作\"></a>位操作</h2><h2 id=\"数值计算\"><a href=\"#数值计算\" class=\"headerlink\" title=\"数值计算\"></a>数值计算</h2><p><a href=\"\">整数中1出现的次数</a></p>\n<p><a href=\"\">丑数</a></p>\n<h2 id=\"字符串问题\"><a href=\"#字符串问题\" class=\"headerlink\" title=\"字符串问题\"></a>字符串问题</h2><h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p><a href=\"\">矩形嵌套问题</a></p>\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2>","site":{"data":{}},"excerpt":"<h2 id=\"数组问题\"><a href=\"#数组问题\" class=\"headerlink\" title=\"数组问题\"></a>数组问题</h2><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.cpp\" target=\"_blank\" rel=\"noopener\">二维数组中的查找</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.cpp\" target=\"_blank\" rel=\"noopener\">旋转数组的最小数字</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.cpp\" target=\"_blank\" rel=\"noopener\">调整数组顺序使奇数位于偶数前面</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.cpp\" target=\"_blank\" rel=\"noopener\">顺时针打印矩阵</a></p>","more":"<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.cpp\" target=\"_blank\" rel=\"noopener\">数组中出现次数超过一半的数字</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.cpp\" target=\"_blank\" rel=\"noopener\">最小的k个数</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp\" target=\"_blank\" rel=\"noopener\">连续子数组的最大和_dp问题</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp\" target=\"_blank\" rel=\"noopener\">两个不相交的字数组的最大和</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.cpp\" target=\"_blank\" rel=\"noopener\">把数组排成最小的数</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/array/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.cpp\" target=\"_blank\" rel=\"noopener\">数组中的逆序对</a></p>\n<h2 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h2><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.cpp\" target=\"_blank\" rel=\"noopener\">两个栈实现队列</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.cpp\" target=\"_blank\" rel=\"noopener\">两个队列实现栈</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.cpp\" target=\"_blank\" rel=\"noopener\">包含min函数的栈 leetcode 155</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.cpp\" target=\"_blank\" rel=\"noopener\">栈的压入、弹出序列</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.cpp\" target=\"_blank\" rel=\"noopener\">滑动窗口的最大值</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88.cpp\" target=\"_blank\" rel=\"noopener\">仅用递归函数和栈操作逆序一个栈</a></p>\n<p><a href=\"https://www.cnblogs.com/PrimeLife/p/5318291.html\" target=\"_blank\" rel=\"noopener\">猫狗队列</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F.cpp\" target=\"_blank\" rel=\"noopener\">用一个栈实现另一个栈的排序</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/stack_and_queue/%E7%94%A8%E6%A0%88%E6%9D%A5%E6%B1%82%E8%A7%A3%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98.cpp\" target=\"_blank\" rel=\"noopener\">用栈来求解汉诺塔问题</a></p>\n<p><a href=\"\">构造数组的MaxTree</a></p>\n<p><a href=\"\">最大子矩阵的大小</a></p>\n<p><a href=\"\">京东环形烽火台问题</a></p>\n<h2 id=\"链表问题\"><a href=\"#链表问题\" class=\"headerlink\" title=\"链表问题\"></a>链表问题</h2><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.cpp\" target=\"_blank\" rel=\"noopener\">从尾到头打印链表 leetcode 206</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%89%93%E5%8D%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86.cpp\" target=\"_blank\" rel=\"noopener\">打印两个有序链表的公共部分</a></p>\n<p><a href=\"\">反转单向和双向链表</a></p>\n<p><a href=\"\">反转部分单向链表</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.cpp\" target=\"_blank\" rel=\"noopener\">合并两个有序的链表 leetcode 21</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">链表中倒数第K个元素</a></p>\n<p><a href=\"\">在单链表和双链表中删除倒数第k个节点</a></p>\n<p><a href=\"\">删除链表的中间节点和a/b处的节点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.cpp\" target=\"_blank\" rel=\"noopener\">复杂链表的复制 letcode 138</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF.cpp\" target=\"_blank\" rel=\"noopener\">判断链表是否有环，如果有环返回入环结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%97%A0%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">两个无环单链表的第一个相交结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">两个有环单链表的相交结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">删除链表中重复的结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84.cpp\" target=\"_blank\" rel=\"noopener\">判断一个链表是否为回文结构 leetcode 234 </a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E9%93%BE%E8%A1%A8Partition.cpp\" target=\"_blank\" rel=\"noopener\">单向链表按某值划分左边小、中间相等、右边大</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0.cpp\" target=\"_blank\" rel=\"noopener\">单链表中的数字相加  leetcode 2</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/list/leetcode143_reorder_list.cpp\" target=\"_blank\" rel=\"noopener\">给单链表重新排序(reorder) leetcode 143</a></p>\n<h2 id=\"树问题\"><a href=\"#树问题\" class=\"headerlink\" title=\"树问题\"></a>树问题</h2><p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的重建</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的子结构</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的镜像</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.cpp\" target=\"_blank\" rel=\"noopener\">二叉搜索树的后序遍历序列</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.cpp\" target=\"_blank\" rel=\"noopener\">二叉树中和为某一值的路径</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E6%88%90%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.cpp\" target=\"_blank\" rel=\"noopener\">二叉搜索树变成双向链表</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的深度</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">二叉树的后继结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.cpp\" target=\"_blank\" rel=\"noopener\">对称的二叉树</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%B9%8B%E5%AD%97%E5%9E%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp\" target=\"_blank\" rel=\"noopener\">之字型打印二叉树</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.cpp\" target=\"_blank\" rel=\"noopener\">层次遍历_把二叉树打印成多行</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.cpp\" target=\"_blank\" rel=\"noopener\">判断平衡二叉树</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.cpp\" target=\"_blank\" rel=\"noopener\">序列化和反序列化二叉树</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp\" target=\"_blank\" rel=\"noopener\">二叉搜索树的第k个结点</a></p>\n<p><a href=\"https://github.com/oldbuffalo/DayDayUp/blob/master/tree/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.cpp\" target=\"_blank\" rel=\"noopener\">数据流中的中位数</a></p>\n<h2 id=\"图问题\"><a href=\"#图问题\" class=\"headerlink\" title=\"图问题\"></a>图问题</h2><h2 id=\"位操作\"><a href=\"#位操作\" class=\"headerlink\" title=\"位操作\"></a>位操作</h2><h2 id=\"数值计算\"><a href=\"#数值计算\" class=\"headerlink\" title=\"数值计算\"></a>数值计算</h2><p><a href=\"\">整数中1出现的次数</a></p>\n<p><a href=\"\">丑数</a></p>\n<h2 id=\"字符串问题\"><a href=\"#字符串问题\" class=\"headerlink\" title=\"字符串问题\"></a>字符串问题</h2><h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p><a href=\"\">矩形嵌套问题</a></p>\n<h2 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h2>"},{"title":"策略模式","date":"2019-04-27T06:57:46.000Z","_content":"\n策略模式和模板方法有着异曲同工之妙。\n\n#### 应用场景\n\n在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担。\n\n定义：\n\n定义一系列算法，把它们一个个封装起来，并且使它们可互相替换(变化)，该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展，子类化)。\n\n<!--more-->\n\n实例演示，在许多电子商务平台有很多税务的计算\n\n```\nenum TaxBase{ //考虑跨国结算\n\tCN_Tax,\n    US_Tax,\n    DE_Tax\n};\n\nclass SalesOrder{\n\tTaxBase tax;\npublic:\n\tdouble CalculateTax(){\n        //...\n        if(tax == CN_Tax){\n            //CN......\n        }\n        else if(tax == US_Tax){\n            //US......\n        }\n        else if(tax == DE_Tax){\n            //DE...\n        }\n        //...\n\t}\n};\n```\n\n上面这种实现的弊端显而易见，如果在未来加入计算更多国家税务的需求，需要大量的更改源代码，违背了开闭原则。\n\n使用策略模式之后的代码：\n\n```\nclass TaxStrategy{\npublic:    \n\tvirtual double Calculate(const Context &context) = 0;\n\tvirtual ~TaxStrategy(){}\n};\n\nclass CNTax:public TaxStrategy{\npublic:\n\tvirtual double Calculate(const Context &context){\n        //.....\n\t}\n};\n\nclass USTax:public TaxStrategy{\npublic:\n\tvirtual double Calculate(const Context &context){\n        //.....\n\t}\n}；\n\nclass DETax:public TaxStrategy{\npublic:\n\tvirtual double Calculate(const Context &context){\n        //.....\n\t}\n}；\n\nclass SalesOrder{\nprivate:\n\tTaxStrategy* strategy; //因为是抽象类 所以必须放一个多态指针\npublic:\n\tSalesOrder(StrategyFactory* strategyFactory){\n        this->strategy=strategyFactory->NewStrategy();//通过工厂决定new哪个对象\n\t}\n\t~SalesOrder(){\n        delete this->strategy;\n\t}\n\tdouble CalculateTax(){\n\t\t//...\n        Context contect;\n        \n        double val = strategy->Calculate(contect);\n        //...\n\t}\n};\n```\n\n当加入新的需求的时候，只需要新写一个类继承TaxStrategy类并重写Calculate方法。别的地方代码都没动，也就是SalesOrder得到了复用性。\n\n#### 类图\n\n![](/pic/策略模式类图.png)\n\n其中Context类就是上面的SalesOrder类，\n\nStrategy类是上面的TaxStrategy类。\n\n这两个类是稳定的。\n\n这里的关键就是将算法的逻辑抽象接口(ContextInterface)封装到Context类中\n\n#### 总结\n\n- Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换\n- Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。\n- 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。","source":"_posts/策略模式.md","raw":"---\ntitle: 策略模式\ndate: 2019-04-27 14:57:46\ntags:\n- 设计模式\n---\n\n策略模式和模板方法有着异曲同工之妙。\n\n#### 应用场景\n\n在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担。\n\n定义：\n\n定义一系列算法，把它们一个个封装起来，并且使它们可互相替换(变化)，该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展，子类化)。\n\n<!--more-->\n\n实例演示，在许多电子商务平台有很多税务的计算\n\n```\nenum TaxBase{ //考虑跨国结算\n\tCN_Tax,\n    US_Tax,\n    DE_Tax\n};\n\nclass SalesOrder{\n\tTaxBase tax;\npublic:\n\tdouble CalculateTax(){\n        //...\n        if(tax == CN_Tax){\n            //CN......\n        }\n        else if(tax == US_Tax){\n            //US......\n        }\n        else if(tax == DE_Tax){\n            //DE...\n        }\n        //...\n\t}\n};\n```\n\n上面这种实现的弊端显而易见，如果在未来加入计算更多国家税务的需求，需要大量的更改源代码，违背了开闭原则。\n\n使用策略模式之后的代码：\n\n```\nclass TaxStrategy{\npublic:    \n\tvirtual double Calculate(const Context &context) = 0;\n\tvirtual ~TaxStrategy(){}\n};\n\nclass CNTax:public TaxStrategy{\npublic:\n\tvirtual double Calculate(const Context &context){\n        //.....\n\t}\n};\n\nclass USTax:public TaxStrategy{\npublic:\n\tvirtual double Calculate(const Context &context){\n        //.....\n\t}\n}；\n\nclass DETax:public TaxStrategy{\npublic:\n\tvirtual double Calculate(const Context &context){\n        //.....\n\t}\n}；\n\nclass SalesOrder{\nprivate:\n\tTaxStrategy* strategy; //因为是抽象类 所以必须放一个多态指针\npublic:\n\tSalesOrder(StrategyFactory* strategyFactory){\n        this->strategy=strategyFactory->NewStrategy();//通过工厂决定new哪个对象\n\t}\n\t~SalesOrder(){\n        delete this->strategy;\n\t}\n\tdouble CalculateTax(){\n\t\t//...\n        Context contect;\n        \n        double val = strategy->Calculate(contect);\n        //...\n\t}\n};\n```\n\n当加入新的需求的时候，只需要新写一个类继承TaxStrategy类并重写Calculate方法。别的地方代码都没动，也就是SalesOrder得到了复用性。\n\n#### 类图\n\n![](/pic/策略模式类图.png)\n\n其中Context类就是上面的SalesOrder类，\n\nStrategy类是上面的TaxStrategy类。\n\n这两个类是稳定的。\n\n这里的关键就是将算法的逻辑抽象接口(ContextInterface)封装到Context类中\n\n#### 总结\n\n- Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换\n- Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。\n- 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。","slug":"策略模式","published":1,"updated":"2021-12-06T05:30:36.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7y002i96cacv6k6zfm","content":"<p>策略模式和模板方法有着异曲同工之妙。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担。</p>\n<p>定义：</p>\n<p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换(变化)，该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展，子类化)。</p>\n<a id=\"more\"></a>\n\n<p>实例演示，在许多电子商务平台有很多税务的计算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum TaxBase&#123; &#x2F;&#x2F;考虑跨国结算</span><br><span class=\"line\">\tCN_Tax,</span><br><span class=\"line\">    US_Tax,</span><br><span class=\"line\">    DE_Tax</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SalesOrder&#123;</span><br><span class=\"line\">\tTaxBase tax;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tdouble CalculateTax()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">        if(tax &#x3D;&#x3D; CN_Tax)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F;CN......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(tax &#x3D;&#x3D; US_Tax)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F;US......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(tax &#x3D;&#x3D; DE_Tax)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F;DE...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面这种实现的弊端显而易见，如果在未来加入计算更多国家税务的需求，需要大量的更改源代码，违背了开闭原则。</p>\n<p>使用策略模式之后的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaxStrategy&#123;</span><br><span class=\"line\">public:    </span><br><span class=\"line\">\tvirtual double Calculate(const Context &amp;context) &#x3D; 0;</span><br><span class=\"line\">\tvirtual ~TaxStrategy()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class CNTax:public TaxStrategy&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual double Calculate(const Context &amp;context)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class USTax:public TaxStrategy&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual double Calculate(const Context &amp;context)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;；</span><br><span class=\"line\"></span><br><span class=\"line\">class DETax:public TaxStrategy&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual double Calculate(const Context &amp;context)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;；</span><br><span class=\"line\"></span><br><span class=\"line\">class SalesOrder&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tTaxStrategy* strategy; &#x2F;&#x2F;因为是抽象类 所以必须放一个多态指针</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tSalesOrder(StrategyFactory* strategyFactory)&#123;</span><br><span class=\"line\">        this-&gt;strategy&#x3D;strategyFactory-&gt;NewStrategy();&#x2F;&#x2F;通过工厂决定new哪个对象</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~SalesOrder()&#123;</span><br><span class=\"line\">        delete this-&gt;strategy;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdouble CalculateTax()&#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;...</span><br><span class=\"line\">        Context contect;</span><br><span class=\"line\">        </span><br><span class=\"line\">        double val &#x3D; strategy-&gt;Calculate(contect);</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>当加入新的需求的时候，只需要新写一个类继承TaxStrategy类并重写Calculate方法。别的地方代码都没动，也就是SalesOrder得到了复用性。</p>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><p><img src=\"/pic/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png\" alt=\"\"></p>\n<p>其中Context类就是上面的SalesOrder类，</p>\n<p>Strategy类是上面的TaxStrategy类。</p>\n<p>这两个类是稳定的。</p>\n<p>这里的关键就是将算法的逻辑抽象接口(ContextInterface)封装到Context类中</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换</li>\n<li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。</li>\n<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>策略模式和模板方法有着异曲同工之妙。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担。</p>\n<p>定义：</p>\n<p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换(变化)，该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展，子类化)。</p>","more":"<p>实例演示，在许多电子商务平台有很多税务的计算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum TaxBase&#123; &#x2F;&#x2F;考虑跨国结算</span><br><span class=\"line\">\tCN_Tax,</span><br><span class=\"line\">    US_Tax,</span><br><span class=\"line\">    DE_Tax</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SalesOrder&#123;</span><br><span class=\"line\">\tTaxBase tax;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tdouble CalculateTax()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">        if(tax &#x3D;&#x3D; CN_Tax)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F;CN......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(tax &#x3D;&#x3D; US_Tax)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F;US......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if(tax &#x3D;&#x3D; DE_Tax)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F;DE...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面这种实现的弊端显而易见，如果在未来加入计算更多国家税务的需求，需要大量的更改源代码，违背了开闭原则。</p>\n<p>使用策略模式之后的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaxStrategy&#123;</span><br><span class=\"line\">public:    </span><br><span class=\"line\">\tvirtual double Calculate(const Context &amp;context) &#x3D; 0;</span><br><span class=\"line\">\tvirtual ~TaxStrategy()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class CNTax:public TaxStrategy&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual double Calculate(const Context &amp;context)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class USTax:public TaxStrategy&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual double Calculate(const Context &amp;context)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;；</span><br><span class=\"line\"></span><br><span class=\"line\">class DETax:public TaxStrategy&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual double Calculate(const Context &amp;context)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;.....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;；</span><br><span class=\"line\"></span><br><span class=\"line\">class SalesOrder&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tTaxStrategy* strategy; &#x2F;&#x2F;因为是抽象类 所以必须放一个多态指针</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tSalesOrder(StrategyFactory* strategyFactory)&#123;</span><br><span class=\"line\">        this-&gt;strategy&#x3D;strategyFactory-&gt;NewStrategy();&#x2F;&#x2F;通过工厂决定new哪个对象</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~SalesOrder()&#123;</span><br><span class=\"line\">        delete this-&gt;strategy;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdouble CalculateTax()&#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;...</span><br><span class=\"line\">        Context contect;</span><br><span class=\"line\">        </span><br><span class=\"line\">        double val &#x3D; strategy-&gt;Calculate(contect);</span><br><span class=\"line\">        &#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>当加入新的需求的时候，只需要新写一个类继承TaxStrategy类并重写Calculate方法。别的地方代码都没动，也就是SalesOrder得到了复用性。</p>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><p><img src=\"/pic/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png\" alt=\"\"></p>\n<p>其中Context类就是上面的SalesOrder类，</p>\n<p>Strategy类是上面的TaxStrategy类。</p>\n<p>这两个类是稳定的。</p>\n<p>这里的关键就是将算法的逻辑抽象接口(ContextInterface)封装到Context类中</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换</li>\n<li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。</li>\n<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。</li>\n</ul>"},{"title":"网络中一些高级I/O函数","date":"2019-03-24T12:44:57.000Z","_content":"\n跟着游双老师的《Linux高性能服务器编程》第六章敲了一些demon\n\n理解了一些特殊场合使用的函数\n\n## dup和dup2\n\n用来创建一个文件描述符，一般用来重定向\n\nCGI服务器原理：把标准输入重定向到一个网络连接\n\n```\nint dup(int file_descriptor)\nint dup2(int file_descriptor_one,int file_descriptor_two)\n```\n\ndup函数创建一个新的文件描述符，新的fd和原有文件描述符file_descriptor指向同一个文件，dup返回系统当前可用的最小的整数值。\n\n<!--more-->\n\ndup2和dup类似，不过它返回第一个不小于file_descriptor_two的整数值。\n\n注意点：dup和dup2创建的文件描述符不继承原文件描述符的属性，如close-on-exec和no-blocking等\n\n[CGI服务器原理代码](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/cgi_server.cpp)\n\n##  readv和writev\n\nreadv:将数据从文件描述符读到分散的内存块中，分散读\n\nwritev:将多块分散的内存书籍怒一并写入文件描述符中，几种写\n\n```\nssize_t readv(int fd,const struct iovec* vector,int count);\nssize_t writev(int fd,const struct iovec* vector,int count);\n\nstruct iovect{\n    void* iov_base; //内存起始地址\n    size_t iov_len; //这块内存的长度\n};\n```\n\n这两个函数相当于简易版的recvmsg和sendmsg。\n\n对于web服务器，在收到一个HTTP请求之后，解析请求，需要回复一个HTTP应答(应答头+请求资源)给用户，可能HTTP应答放在一块内存中，而资源的内容被读入到另一块内存中，并不需要把这两部分内容拼接到一起再发送，而是可以借助writev将它们同时写出。\n\n[web服务器上的集中写](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E4%B8%AD%E5%86%99.cpp)\n\n## sendfile\n\n该函数在两个文件描述符中直接传递数据，完全在内核中操作，避免了内核缓冲区到用户缓冲区之间的数据拷贝，效率高，也叫零拷贝。\n\n```\nssize_t sendfile（int out_fd,int in_fd,off_t* offset,size_t count）；\n```\n\nout_fd:待写入内容的文件描述符,**必须是一个socket**\n\nin_fd:待读出内容的文件描述符,**必须指向真是的文件，不能是socket和管道**\n\noffset:从读入文件流的哪个位置开始读，如果是NULL，默认从起始位置。\n\n因此，sendfile是专门为网络上传输文件设计的。\n\n[sendfile传输文件](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/sendfile.cpp)\n\n## splice\n\n用于在两个文件描述符之间移动数据，也是零拷贝操作\n\n```\nssize_t splice(int fd_in,loff_t* off_in,int fd_out,loff_t* off_out,size_t len,unsigned int flags)\n```\n\nfd_in:带输入数据的文件描述符。如果fd_in是管道文件，off_in必须是NULL\n\noff_in:如果fd_in不是管道文件，该参数表示从输入数据流的何处开始读取位置，如果是NULL，表示从输入数据流的当前偏移位置读入。\n\nflags参数：\n\n![](/pic/splice函数flag参数.png)\n\n**注意：fd_in和fd_out中至少有一个是管道文件描述符**\n\n[使用splice实现的echo服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/splice.cpp)\n\n## tee \n\n在两个**管道文件描述符**之间复制数据，也是零拷贝操作。不消耗数据，因此源文件描述符上的数据仍然可以用于后续操作。\n\n```\nssize_t tee(int fd_in,int fd_out,size_t len,unsigned int flags)\n```\n\n参数含义和splice一样。\n\n**注意：fd_in和fd_out必须都是管道文件描述符**\n\n[利用tee实现同时输出数据到终端和文件](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/tee.cpp)\n\n","source":"_posts/网络中一些高级IO函数.md","raw":"---\ntitle: 网络中一些高级I/O函数\ndate: 2019-03-24 20:44:57\ntags:\n- 网络\n- Linux高性能服务器编程\n---\n\n跟着游双老师的《Linux高性能服务器编程》第六章敲了一些demon\n\n理解了一些特殊场合使用的函数\n\n## dup和dup2\n\n用来创建一个文件描述符，一般用来重定向\n\nCGI服务器原理：把标准输入重定向到一个网络连接\n\n```\nint dup(int file_descriptor)\nint dup2(int file_descriptor_one,int file_descriptor_two)\n```\n\ndup函数创建一个新的文件描述符，新的fd和原有文件描述符file_descriptor指向同一个文件，dup返回系统当前可用的最小的整数值。\n\n<!--more-->\n\ndup2和dup类似，不过它返回第一个不小于file_descriptor_two的整数值。\n\n注意点：dup和dup2创建的文件描述符不继承原文件描述符的属性，如close-on-exec和no-blocking等\n\n[CGI服务器原理代码](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/cgi_server.cpp)\n\n##  readv和writev\n\nreadv:将数据从文件描述符读到分散的内存块中，分散读\n\nwritev:将多块分散的内存书籍怒一并写入文件描述符中，几种写\n\n```\nssize_t readv(int fd,const struct iovec* vector,int count);\nssize_t writev(int fd,const struct iovec* vector,int count);\n\nstruct iovect{\n    void* iov_base; //内存起始地址\n    size_t iov_len; //这块内存的长度\n};\n```\n\n这两个函数相当于简易版的recvmsg和sendmsg。\n\n对于web服务器，在收到一个HTTP请求之后，解析请求，需要回复一个HTTP应答(应答头+请求资源)给用户，可能HTTP应答放在一块内存中，而资源的内容被读入到另一块内存中，并不需要把这两部分内容拼接到一起再发送，而是可以借助writev将它们同时写出。\n\n[web服务器上的集中写](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E4%B8%AD%E5%86%99.cpp)\n\n## sendfile\n\n该函数在两个文件描述符中直接传递数据，完全在内核中操作，避免了内核缓冲区到用户缓冲区之间的数据拷贝，效率高，也叫零拷贝。\n\n```\nssize_t sendfile（int out_fd,int in_fd,off_t* offset,size_t count）；\n```\n\nout_fd:待写入内容的文件描述符,**必须是一个socket**\n\nin_fd:待读出内容的文件描述符,**必须指向真是的文件，不能是socket和管道**\n\noffset:从读入文件流的哪个位置开始读，如果是NULL，默认从起始位置。\n\n因此，sendfile是专门为网络上传输文件设计的。\n\n[sendfile传输文件](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/sendfile.cpp)\n\n## splice\n\n用于在两个文件描述符之间移动数据，也是零拷贝操作\n\n```\nssize_t splice(int fd_in,loff_t* off_in,int fd_out,loff_t* off_out,size_t len,unsigned int flags)\n```\n\nfd_in:带输入数据的文件描述符。如果fd_in是管道文件，off_in必须是NULL\n\noff_in:如果fd_in不是管道文件，该参数表示从输入数据流的何处开始读取位置，如果是NULL，表示从输入数据流的当前偏移位置读入。\n\nflags参数：\n\n![](/pic/splice函数flag参数.png)\n\n**注意：fd_in和fd_out中至少有一个是管道文件描述符**\n\n[使用splice实现的echo服务器](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/splice.cpp)\n\n## tee \n\n在两个**管道文件描述符**之间复制数据，也是零拷贝操作。不消耗数据，因此源文件描述符上的数据仍然可以用于后续操作。\n\n```\nssize_t tee(int fd_in,int fd_out,size_t len,unsigned int flags)\n```\n\n参数含义和splice一样。\n\n**注意：fd_in和fd_out必须都是管道文件描述符**\n\n[利用tee实现同时输出数据到终端和文件](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/tee.cpp)\n\n","slug":"网络中一些高级IO函数","published":1,"updated":"2021-12-06T05:30:36.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7z002k96ca3pkd2dgd","content":"<p>跟着游双老师的《Linux高性能服务器编程》第六章敲了一些demon</p>\n<p>理解了一些特殊场合使用的函数</p>\n<h2 id=\"dup和dup2\"><a href=\"#dup和dup2\" class=\"headerlink\" title=\"dup和dup2\"></a>dup和dup2</h2><p>用来创建一个文件描述符，一般用来重定向</p>\n<p>CGI服务器原理：把标准输入重定向到一个网络连接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int dup(int file_descriptor)</span><br><span class=\"line\">int dup2(int file_descriptor_one,int file_descriptor_two)</span><br></pre></td></tr></table></figure>\n\n<p>dup函数创建一个新的文件描述符，新的fd和原有文件描述符file_descriptor指向同一个文件，dup返回系统当前可用的最小的整数值。</p>\n<a id=\"more\"></a>\n\n<p>dup2和dup类似，不过它返回第一个不小于file_descriptor_two的整数值。</p>\n<p>注意点：dup和dup2创建的文件描述符不继承原文件描述符的属性，如close-on-exec和no-blocking等</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/cgi_server.cpp\" target=\"_blank\" rel=\"noopener\">CGI服务器原理代码</a></p>\n<h2 id=\"readv和writev\"><a href=\"#readv和writev\" class=\"headerlink\" title=\"readv和writev\"></a>readv和writev</h2><p>readv:将数据从文件描述符读到分散的内存块中，分散读</p>\n<p>writev:将多块分散的内存书籍怒一并写入文件描述符中，几种写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t readv(int fd,const struct iovec* vector,int count);</span><br><span class=\"line\">ssize_t writev(int fd,const struct iovec* vector,int count);</span><br><span class=\"line\"></span><br><span class=\"line\">struct iovect&#123;</span><br><span class=\"line\">    void* iov_base; &#x2F;&#x2F;内存起始地址</span><br><span class=\"line\">    size_t iov_len; &#x2F;&#x2F;这块内存的长度</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这两个函数相当于简易版的recvmsg和sendmsg。</p>\n<p>对于web服务器，在收到一个HTTP请求之后，解析请求，需要回复一个HTTP应答(应答头+请求资源)给用户，可能HTTP应答放在一块内存中，而资源的内容被读入到另一块内存中，并不需要把这两部分内容拼接到一起再发送，而是可以借助writev将它们同时写出。</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E4%B8%AD%E5%86%99.cpp\" target=\"_blank\" rel=\"noopener\">web服务器上的集中写</a></p>\n<h2 id=\"sendfile\"><a href=\"#sendfile\" class=\"headerlink\" title=\"sendfile\"></a>sendfile</h2><p>该函数在两个文件描述符中直接传递数据，完全在内核中操作，避免了内核缓冲区到用户缓冲区之间的数据拷贝，效率高，也叫零拷贝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t sendfile（int out_fd,int in_fd,off_t* offset,size_t count）；</span><br></pre></td></tr></table></figure>\n\n<p>out_fd:待写入内容的文件描述符,<strong>必须是一个socket</strong></p>\n<p>in_fd:待读出内容的文件描述符,<strong>必须指向真是的文件，不能是socket和管道</strong></p>\n<p>offset:从读入文件流的哪个位置开始读，如果是NULL，默认从起始位置。</p>\n<p>因此，sendfile是专门为网络上传输文件设计的。</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/sendfile.cpp\" target=\"_blank\" rel=\"noopener\">sendfile传输文件</a></p>\n<h2 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h2><p>用于在两个文件描述符之间移动数据，也是零拷贝操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t splice(int fd_in,loff_t* off_in,int fd_out,loff_t* off_out,size_t len,unsigned int flags)</span><br></pre></td></tr></table></figure>\n\n<p>fd_in:带输入数据的文件描述符。如果fd_in是管道文件，off_in必须是NULL</p>\n<p>off_in:如果fd_in不是管道文件，该参数表示从输入数据流的何处开始读取位置，如果是NULL，表示从输入数据流的当前偏移位置读入。</p>\n<p>flags参数：</p>\n<p><img src=\"/pic/splice%E5%87%BD%E6%95%B0flag%E5%8F%82%E6%95%B0.png\" alt=\"\"></p>\n<p><strong>注意：fd_in和fd_out中至少有一个是管道文件描述符</strong></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/splice.cpp\" target=\"_blank\" rel=\"noopener\">使用splice实现的echo服务器</a></p>\n<h2 id=\"tee\"><a href=\"#tee\" class=\"headerlink\" title=\"tee\"></a>tee</h2><p>在两个<strong>管道文件描述符</strong>之间复制数据，也是零拷贝操作。不消耗数据，因此源文件描述符上的数据仍然可以用于后续操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t tee(int fd_in,int fd_out,size_t len,unsigned int flags)</span><br></pre></td></tr></table></figure>\n\n<p>参数含义和splice一样。</p>\n<p><strong>注意：fd_in和fd_out必须都是管道文件描述符</strong></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/tee.cpp\" target=\"_blank\" rel=\"noopener\">利用tee实现同时输出数据到终端和文件</a></p>\n","site":{"data":{}},"excerpt":"<p>跟着游双老师的《Linux高性能服务器编程》第六章敲了一些demon</p>\n<p>理解了一些特殊场合使用的函数</p>\n<h2 id=\"dup和dup2\"><a href=\"#dup和dup2\" class=\"headerlink\" title=\"dup和dup2\"></a>dup和dup2</h2><p>用来创建一个文件描述符，一般用来重定向</p>\n<p>CGI服务器原理：把标准输入重定向到一个网络连接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int dup(int file_descriptor)</span><br><span class=\"line\">int dup2(int file_descriptor_one,int file_descriptor_two)</span><br></pre></td></tr></table></figure>\n\n<p>dup函数创建一个新的文件描述符，新的fd和原有文件描述符file_descriptor指向同一个文件，dup返回系统当前可用的最小的整数值。</p>","more":"<p>dup2和dup类似，不过它返回第一个不小于file_descriptor_two的整数值。</p>\n<p>注意点：dup和dup2创建的文件描述符不继承原文件描述符的属性，如close-on-exec和no-blocking等</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/cgi_server.cpp\" target=\"_blank\" rel=\"noopener\">CGI服务器原理代码</a></p>\n<h2 id=\"readv和writev\"><a href=\"#readv和writev\" class=\"headerlink\" title=\"readv和writev\"></a>readv和writev</h2><p>readv:将数据从文件描述符读到分散的内存块中，分散读</p>\n<p>writev:将多块分散的内存书籍怒一并写入文件描述符中，几种写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t readv(int fd,const struct iovec* vector,int count);</span><br><span class=\"line\">ssize_t writev(int fd,const struct iovec* vector,int count);</span><br><span class=\"line\"></span><br><span class=\"line\">struct iovect&#123;</span><br><span class=\"line\">    void* iov_base; &#x2F;&#x2F;内存起始地址</span><br><span class=\"line\">    size_t iov_len; &#x2F;&#x2F;这块内存的长度</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这两个函数相当于简易版的recvmsg和sendmsg。</p>\n<p>对于web服务器，在收到一个HTTP请求之后，解析请求，需要回复一个HTTP应答(应答头+请求资源)给用户，可能HTTP应答放在一块内存中，而资源的内容被读入到另一块内存中，并不需要把这两部分内容拼接到一起再发送，而是可以借助writev将它们同时写出。</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E4%B8%AD%E5%86%99.cpp\" target=\"_blank\" rel=\"noopener\">web服务器上的集中写</a></p>\n<h2 id=\"sendfile\"><a href=\"#sendfile\" class=\"headerlink\" title=\"sendfile\"></a>sendfile</h2><p>该函数在两个文件描述符中直接传递数据，完全在内核中操作，避免了内核缓冲区到用户缓冲区之间的数据拷贝，效率高，也叫零拷贝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t sendfile（int out_fd,int in_fd,off_t* offset,size_t count）；</span><br></pre></td></tr></table></figure>\n\n<p>out_fd:待写入内容的文件描述符,<strong>必须是一个socket</strong></p>\n<p>in_fd:待读出内容的文件描述符,<strong>必须指向真是的文件，不能是socket和管道</strong></p>\n<p>offset:从读入文件流的哪个位置开始读，如果是NULL，默认从起始位置。</p>\n<p>因此，sendfile是专门为网络上传输文件设计的。</p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/sendfile.cpp\" target=\"_blank\" rel=\"noopener\">sendfile传输文件</a></p>\n<h2 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h2><p>用于在两个文件描述符之间移动数据，也是零拷贝操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t splice(int fd_in,loff_t* off_in,int fd_out,loff_t* off_out,size_t len,unsigned int flags)</span><br></pre></td></tr></table></figure>\n\n<p>fd_in:带输入数据的文件描述符。如果fd_in是管道文件，off_in必须是NULL</p>\n<p>off_in:如果fd_in不是管道文件，该参数表示从输入数据流的何处开始读取位置，如果是NULL，表示从输入数据流的当前偏移位置读入。</p>\n<p>flags参数：</p>\n<p><img src=\"/pic/splice%E5%87%BD%E6%95%B0flag%E5%8F%82%E6%95%B0.png\" alt=\"\"></p>\n<p><strong>注意：fd_in和fd_out中至少有一个是管道文件描述符</strong></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/splice.cpp\" target=\"_blank\" rel=\"noopener\">使用splice实现的echo服务器</a></p>\n<h2 id=\"tee\"><a href=\"#tee\" class=\"headerlink\" title=\"tee\"></a>tee</h2><p>在两个<strong>管道文件描述符</strong>之间复制数据，也是零拷贝操作。不消耗数据，因此源文件描述符上的数据仍然可以用于后续操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssize_t tee(int fd_in,int fd_out,size_t len,unsigned int flags)</span><br></pre></td></tr></table></figure>\n\n<p>参数含义和splice一样。</p>\n<p><strong>注意：fd_in和fd_out必须都是管道文件描述符</strong></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/6_chapter/tee.cpp\" target=\"_blank\" rel=\"noopener\">利用tee实现同时输出数据到终端和文件</a></p>"},{"title":"虚函数表","date":"2019-03-23T05:44:50.000Z","_content":"\n\n\n## 前置知识\n\nC++中virtual主要是用来实现多态，一般的流程是用父类的指针指向子类的对象，然后通过父类的指针调用子类重写父类的虚函数。所谓多态，就是让父类指针有“多种形态”，换言之，就是用不变的代码实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。\n\nvirtual函数的实现又借助了虚函数指针(vptr)和虚函数表(v-table)实现。vptr的位置为编译器决定，现在很多C++的编译器保证虚函数表的指针存在于对象实例中最前面的位置。\n\n<!--more-->\n\n##  虚函数表\n\n```\nclass Base{\npublic:\n\tdouble x;\n\tint y;\npublic:\n\tvirtual void f(){ cout<<\"f\"<<endl;}\n\tvirtual void g(){cout<<\"g\"<<endl;}\n\tvirtual void h(){cout<<\"h\"<<endl;}\n};\ntypedef void(*PFUN)();  \nint main()\n{\n    Base b;\n    printf(\"%p\\n\",&b); //对象的地址\n    printf(\"%p\\n\",*(int*)&b);    //vptr的值，也就是虚函数表的地址\n    PFUN pfun = (PFUN)*(int*)*(int*)&b;\n    pfun();   //调用了f()     (*pfun)()也行\n\treturn 0;    \n}\n\n/*\n(PFUN)*((int*)*(int*)&b+0) -------->Base::f()的地址\n(PFUN)*((int*)*(int*)&b+1) -------->Base::g()的地址\n(PFUN)*((int*)*(int*)&b+2) -------->Base::h()的地址\n*/\n```\n\n根据上面这个实例，可见通过对实例取地址，转换成int类型指针，然后间接引用取到vptr的值，也就是虚表的地址，然后再进行一次强转int类型指针，再次间接引用，取得函数地址。\n\n**注意点：32位的机器用int类型指针强转，而64位机器要用long long 强转  因为32位和64位指针大小不一样**\n\n![](/pic/虚函数表.png)\n\n## 一般单继承\n\n原则：\n\n1. 子类与父类拥有各自的一个虚函数表\n2. 若子类并无overwrite父类虚函数，用父类虚函数\n3. 若子类重写（overwrite）了父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数\n4. 若子声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后\n\n- 子类没有重写父类的虚函数\n\n```\nclass Base{\npublic:\n\tint m_x;\npublic:\n\tBase(int x = 1):m_x(x){}\n\tvirtual void f(){ cout<<\"f\"<<endl;}\n\tvirtual void g(){cout<<\"g\"<<endl;}\n\tvirtual void h(){cout<<\"h\"<<endl;}\n};\nclass Derive:public Base{\npublic:\n\tDerive(int x = 2.0):Base(x){}\n\tvirtual void f1(){ cout<<\"f1\"<<endl;}\n\tvirtual void g1(){cout<<\"g1\"<<endl;}\n\tvirtual void h1(){cout<<\"h1\"<<endl;}\n};\n\ntypedef void(*PFUN)();  \n\nint main()\n{\n    Base b;\n    PFUN pfun = (PFUN)*(int*)*(int*)&b;\n\tprintf(\"%d\\n\",sizeof(b));\t\t     //实例b的字节数\t\t输出8\n\tprintf(\"%p\\n\",&b);\t\t\t\t\t //对象b的地址  \t    010FFABC\n\tprintf(\"%p\\n\",&b.m_x);\t//对象中m_x成员的地址  010FFAC0   比上一个多4  也就是vptr的大小\n\t\n\t//将对象的地址 移动一个int  然后强制成int*   010FFAC0   也就是m_x的地址\n\tprintf(\"%p\\n\",(int*)((int*)&b+1));\t\n\t//将对象的地址 移动一个int  然后强制成int* 再间接引用  取出来m_x的值\t 输出1\n    printf(\"%d\\n\",*(int*)((int*)&b+1));\t\n    pfun(); \n\n\tDerive d;\n\tPFUN pfun1 = (PFUN)*(int*)*(int*)&d;\t //Base::f()的地址\n\tPFUN pfun2 = (PFUN)*((int*)*(int*)&d+3); //Derive::f1()的地址\n\tprintf(\"%d\\n\",sizeof(d));            // 实例d的字节数\t\t 输出8\n\tprintf(\"%p\\n\",&d);\t\t\t\t\t //对象b的地址  \t    010FFAA0\n\tprintf(\"%p\\n\",&d.m_x);//对象中m_x成员的地址  010FFAA4   比上一个多4  也就是子类vptr的大小\n\t//将对象的地址 移动一个int  然后强制成int*   010FFAA4   也就是m_x的地址\n\tprintf(\"%p\\n\",(int*)((int*)&d+1));\n    //将对象的地址 移动一个int  然后强制成int* 再间接引用  取出来m_x的值 输出2\n    printf(\"%d\\n\",*(int*)((int*)&d+1));\t \n\tpfun1();\t\t\t\t  \n\tpfun2();\n\n\tgetchar();\n\treturn 0;    \n}\n```\n\nDerive类的虚函数表如下：\n\n![](/pic/单继承但不重写虚函数表.png)\n\n由上图可以看到下面几点： \n1）虚函数按照其声明顺序放于表中。 \n2）父类的虚函数在子类的虚函数前面。\n\n有一个问题：\n\n```\nclass Test{\n\tint a;\n    double b;\n    virtual void A(){}\n};\nsizeof(Test)------------>24  why? 好像不符合内存字节对齐的规律\n```\n\n- 子类重写父类的虚函数\n\n```\nclass Base{\npublic:\n\tint m_x;\npublic:\n\tvirtual void f(){ cout<<\"Base::f\"<<endl;}\n\tvirtual void g(){cout<<\"g\"<<endl;}\n\tvirtual void h(){cout<<\"h\"<<endl;}\n};\nclass Derive:public Base{\npublic:\n\tvirtual void f(){ cout<<\"Derive::f\"<<endl;}\n\tvirtual void g1(){cout<<\"g1\"<<endl;}\n\tvirtual void h1(){cout<<\"h1\"<<endl;}\n};\n\ntypedef void(*PFUN)();  \n\n\nint main()\n{\n\tDerive d;\n\n\tPFUN pfun= (PFUN) *(int*)*(int*)&d;  //\tDerive::f()\n\tPFUN pfun1= (PFUN)*((int*)*(int*)&d+3);// Derive::g1()\n\tpfun();\n\tpfun1();\n\n\tgetchar();\n\treturn 0;    \n}\n```\n\nDerive类的虚函数表如下：\n\n![](/pic/单继承重写虚函数.png)\n\n由上图可以看到下面几点：\n1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 \n2）没有被覆盖的函数依旧。\n\n因此，多态的实现可以通过\n\n```\n Base *b = new Derive();\n b->f();\n```\n\n由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。\n\n## 多重继承\n\n原则：\n\n1. 若子类新增虚函数，放在声明的第一个父类的虚函数表中\n2. 若子类重写了父类的虚函数，所有父类的虚函数表都要改变：如fun1\n3. 内存布局中，父类按照其声明顺序排列\n\n- 无虚函数重写\n\n类图：\n\n![](/pic/多重继承无虚函数覆盖.png)\n\nDerive类的虚函数表如下：\n\n![](/pic/多继承无虚函数覆盖的虚函数表.png)\n\n由上图可以看到下面几点：\n1） 每个父类都有自己的虚表。 \n2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）\n\n- 有虚函数重写\n\n![](/pic/多重继承有虚函数重写.png)\n\n图中子类重写了父类的f()函数\n\nDerive类的虚函数表如下：\n\n![](/pic/多重继承有虚函数重写的虚函数表.png)\n\n```\nDerive d;\nBase1 *b1 = &d;\nBase2 *b2 = &d;\nBase3 *b3 = &d;\nb1->f(); //Derive::f()\nb2->f(); //Derive::f()\nb3->f(); //Derive::f()\nb1->g(); //Base1::g()\nb2->g(); //Base2::g()\nb3->g(); //Base3::g()\n```\n\n## 虚继承\n\n虚继承解决了菱形继承中派生类拥有多个间接父类实例的情况\n\n原则：\n\n1. 虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个新的虚函数指针（vptr）以及一张虚函数表。该vptr位于对象内存最前面（对比非虚继承：直接扩展父类虚函数表）\n2. 虚继承的子类也单独保留了父类的vptr与虚函数表\n3. 虚继承的子类有虚基类表指针（vbptr）\n\n- 简单虚继承\n\n  ```\n  class Base{\n  private:\n  \tint m_base;\n  public:\n  \tvirtual void fun1(){cout << \"Base::fun1\"<<endl;}\n  \tvirtual void fun2(){cout<<\"Base::fun2\"<<endl;}\n  };\n  \n  class Derive : virtual public Base{\n  private:\n  \tint m_y;\n  public:\n      void fun1(){cout << \"Derive::fun1\"<<endl;}\n  \tvirtual void fun3(){cout << \"Derive::fun3\"<<endl;}\n  \n  };\n  \n  typedef void (*PFUN)();\n  \n  \n  int main()\n  {\n  \tDerive d;\n  \tPFUN pfun = (PFUN)*(int*)*(int*)&d;\t  // Derive::fun3\n  \tpfun();\n  \tPFUN pfun1 = (PFUN)*(int*)*((int*)&d+3);  // Derive::fun1\n  \tPFUN pfun2 = (PFUN) *((int*)*((int*)&d+3)+1);  //Base::fun2\n  \tpfun1();\n  \tpfun2();\n  \tgetchar();\n  \treturn 0;    \n  }\n  ```\n\n  对象模型：\n\n  ![](/pic/简单虚继承对象模型.png)\n\n- 菱形虚继承\n\n  对象模型:\n\n  ![](/pic/菱形虚继承.png)\n","source":"_posts/虚函数表.md","raw":"---\ntitle: 虚函数表\ndate: 2019-03-23 13:44:50\ntags:\n- C++\n---\n\n\n\n## 前置知识\n\nC++中virtual主要是用来实现多态，一般的流程是用父类的指针指向子类的对象，然后通过父类的指针调用子类重写父类的虚函数。所谓多态，就是让父类指针有“多种形态”，换言之，就是用不变的代码实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。\n\nvirtual函数的实现又借助了虚函数指针(vptr)和虚函数表(v-table)实现。vptr的位置为编译器决定，现在很多C++的编译器保证虚函数表的指针存在于对象实例中最前面的位置。\n\n<!--more-->\n\n##  虚函数表\n\n```\nclass Base{\npublic:\n\tdouble x;\n\tint y;\npublic:\n\tvirtual void f(){ cout<<\"f\"<<endl;}\n\tvirtual void g(){cout<<\"g\"<<endl;}\n\tvirtual void h(){cout<<\"h\"<<endl;}\n};\ntypedef void(*PFUN)();  \nint main()\n{\n    Base b;\n    printf(\"%p\\n\",&b); //对象的地址\n    printf(\"%p\\n\",*(int*)&b);    //vptr的值，也就是虚函数表的地址\n    PFUN pfun = (PFUN)*(int*)*(int*)&b;\n    pfun();   //调用了f()     (*pfun)()也行\n\treturn 0;    \n}\n\n/*\n(PFUN)*((int*)*(int*)&b+0) -------->Base::f()的地址\n(PFUN)*((int*)*(int*)&b+1) -------->Base::g()的地址\n(PFUN)*((int*)*(int*)&b+2) -------->Base::h()的地址\n*/\n```\n\n根据上面这个实例，可见通过对实例取地址，转换成int类型指针，然后间接引用取到vptr的值，也就是虚表的地址，然后再进行一次强转int类型指针，再次间接引用，取得函数地址。\n\n**注意点：32位的机器用int类型指针强转，而64位机器要用long long 强转  因为32位和64位指针大小不一样**\n\n![](/pic/虚函数表.png)\n\n## 一般单继承\n\n原则：\n\n1. 子类与父类拥有各自的一个虚函数表\n2. 若子类并无overwrite父类虚函数，用父类虚函数\n3. 若子类重写（overwrite）了父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数\n4. 若子声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后\n\n- 子类没有重写父类的虚函数\n\n```\nclass Base{\npublic:\n\tint m_x;\npublic:\n\tBase(int x = 1):m_x(x){}\n\tvirtual void f(){ cout<<\"f\"<<endl;}\n\tvirtual void g(){cout<<\"g\"<<endl;}\n\tvirtual void h(){cout<<\"h\"<<endl;}\n};\nclass Derive:public Base{\npublic:\n\tDerive(int x = 2.0):Base(x){}\n\tvirtual void f1(){ cout<<\"f1\"<<endl;}\n\tvirtual void g1(){cout<<\"g1\"<<endl;}\n\tvirtual void h1(){cout<<\"h1\"<<endl;}\n};\n\ntypedef void(*PFUN)();  \n\nint main()\n{\n    Base b;\n    PFUN pfun = (PFUN)*(int*)*(int*)&b;\n\tprintf(\"%d\\n\",sizeof(b));\t\t     //实例b的字节数\t\t输出8\n\tprintf(\"%p\\n\",&b);\t\t\t\t\t //对象b的地址  \t    010FFABC\n\tprintf(\"%p\\n\",&b.m_x);\t//对象中m_x成员的地址  010FFAC0   比上一个多4  也就是vptr的大小\n\t\n\t//将对象的地址 移动一个int  然后强制成int*   010FFAC0   也就是m_x的地址\n\tprintf(\"%p\\n\",(int*)((int*)&b+1));\t\n\t//将对象的地址 移动一个int  然后强制成int* 再间接引用  取出来m_x的值\t 输出1\n    printf(\"%d\\n\",*(int*)((int*)&b+1));\t\n    pfun(); \n\n\tDerive d;\n\tPFUN pfun1 = (PFUN)*(int*)*(int*)&d;\t //Base::f()的地址\n\tPFUN pfun2 = (PFUN)*((int*)*(int*)&d+3); //Derive::f1()的地址\n\tprintf(\"%d\\n\",sizeof(d));            // 实例d的字节数\t\t 输出8\n\tprintf(\"%p\\n\",&d);\t\t\t\t\t //对象b的地址  \t    010FFAA0\n\tprintf(\"%p\\n\",&d.m_x);//对象中m_x成员的地址  010FFAA4   比上一个多4  也就是子类vptr的大小\n\t//将对象的地址 移动一个int  然后强制成int*   010FFAA4   也就是m_x的地址\n\tprintf(\"%p\\n\",(int*)((int*)&d+1));\n    //将对象的地址 移动一个int  然后强制成int* 再间接引用  取出来m_x的值 输出2\n    printf(\"%d\\n\",*(int*)((int*)&d+1));\t \n\tpfun1();\t\t\t\t  \n\tpfun2();\n\n\tgetchar();\n\treturn 0;    \n}\n```\n\nDerive类的虚函数表如下：\n\n![](/pic/单继承但不重写虚函数表.png)\n\n由上图可以看到下面几点： \n1）虚函数按照其声明顺序放于表中。 \n2）父类的虚函数在子类的虚函数前面。\n\n有一个问题：\n\n```\nclass Test{\n\tint a;\n    double b;\n    virtual void A(){}\n};\nsizeof(Test)------------>24  why? 好像不符合内存字节对齐的规律\n```\n\n- 子类重写父类的虚函数\n\n```\nclass Base{\npublic:\n\tint m_x;\npublic:\n\tvirtual void f(){ cout<<\"Base::f\"<<endl;}\n\tvirtual void g(){cout<<\"g\"<<endl;}\n\tvirtual void h(){cout<<\"h\"<<endl;}\n};\nclass Derive:public Base{\npublic:\n\tvirtual void f(){ cout<<\"Derive::f\"<<endl;}\n\tvirtual void g1(){cout<<\"g1\"<<endl;}\n\tvirtual void h1(){cout<<\"h1\"<<endl;}\n};\n\ntypedef void(*PFUN)();  \n\n\nint main()\n{\n\tDerive d;\n\n\tPFUN pfun= (PFUN) *(int*)*(int*)&d;  //\tDerive::f()\n\tPFUN pfun1= (PFUN)*((int*)*(int*)&d+3);// Derive::g1()\n\tpfun();\n\tpfun1();\n\n\tgetchar();\n\treturn 0;    \n}\n```\n\nDerive类的虚函数表如下：\n\n![](/pic/单继承重写虚函数.png)\n\n由上图可以看到下面几点：\n1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 \n2）没有被覆盖的函数依旧。\n\n因此，多态的实现可以通过\n\n```\n Base *b = new Derive();\n b->f();\n```\n\n由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。\n\n## 多重继承\n\n原则：\n\n1. 若子类新增虚函数，放在声明的第一个父类的虚函数表中\n2. 若子类重写了父类的虚函数，所有父类的虚函数表都要改变：如fun1\n3. 内存布局中，父类按照其声明顺序排列\n\n- 无虚函数重写\n\n类图：\n\n![](/pic/多重继承无虚函数覆盖.png)\n\nDerive类的虚函数表如下：\n\n![](/pic/多继承无虚函数覆盖的虚函数表.png)\n\n由上图可以看到下面几点：\n1） 每个父类都有自己的虚表。 \n2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）\n\n- 有虚函数重写\n\n![](/pic/多重继承有虚函数重写.png)\n\n图中子类重写了父类的f()函数\n\nDerive类的虚函数表如下：\n\n![](/pic/多重继承有虚函数重写的虚函数表.png)\n\n```\nDerive d;\nBase1 *b1 = &d;\nBase2 *b2 = &d;\nBase3 *b3 = &d;\nb1->f(); //Derive::f()\nb2->f(); //Derive::f()\nb3->f(); //Derive::f()\nb1->g(); //Base1::g()\nb2->g(); //Base2::g()\nb3->g(); //Base3::g()\n```\n\n## 虚继承\n\n虚继承解决了菱形继承中派生类拥有多个间接父类实例的情况\n\n原则：\n\n1. 虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个新的虚函数指针（vptr）以及一张虚函数表。该vptr位于对象内存最前面（对比非虚继承：直接扩展父类虚函数表）\n2. 虚继承的子类也单独保留了父类的vptr与虚函数表\n3. 虚继承的子类有虚基类表指针（vbptr）\n\n- 简单虚继承\n\n  ```\n  class Base{\n  private:\n  \tint m_base;\n  public:\n  \tvirtual void fun1(){cout << \"Base::fun1\"<<endl;}\n  \tvirtual void fun2(){cout<<\"Base::fun2\"<<endl;}\n  };\n  \n  class Derive : virtual public Base{\n  private:\n  \tint m_y;\n  public:\n      void fun1(){cout << \"Derive::fun1\"<<endl;}\n  \tvirtual void fun3(){cout << \"Derive::fun3\"<<endl;}\n  \n  };\n  \n  typedef void (*PFUN)();\n  \n  \n  int main()\n  {\n  \tDerive d;\n  \tPFUN pfun = (PFUN)*(int*)*(int*)&d;\t  // Derive::fun3\n  \tpfun();\n  \tPFUN pfun1 = (PFUN)*(int*)*((int*)&d+3);  // Derive::fun1\n  \tPFUN pfun2 = (PFUN) *((int*)*((int*)&d+3)+1);  //Base::fun2\n  \tpfun1();\n  \tpfun2();\n  \tgetchar();\n  \treturn 0;    \n  }\n  ```\n\n  对象模型：\n\n  ![](/pic/简单虚继承对象模型.png)\n\n- 菱形虚继承\n\n  对象模型:\n\n  ![](/pic/菱形虚继承.png)\n","slug":"虚函数表","published":1,"updated":"2021-12-06T05:30:36.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip7z002n96ca13xu6tfa","content":"<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>C++中virtual主要是用来实现多态，一般的流程是用父类的指针指向子类的对象，然后通过父类的指针调用子类重写父类的虚函数。所谓多态，就是让父类指针有“多种形态”，换言之，就是用不变的代码实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>\n<p>virtual函数的实现又借助了虚函数指针(vptr)和虚函数表(v-table)实现。vptr的位置为编译器决定，现在很多C++的编译器保证虚函数表的指针存在于对象实例中最前面的位置。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"虚函数表\"><a href=\"#虚函数表\" class=\"headerlink\" title=\"虚函数表\"></a>虚函数表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tdouble x;</span><br><span class=\"line\">\tint y;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void f()&#123; cout&lt;&lt;&quot;f&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g()&#123;cout&lt;&lt;&quot;g&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h()&#123;cout&lt;&lt;&quot;h&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">typedef void(*PFUN)();  </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Base b;</span><br><span class=\"line\">    printf(&quot;%p\\n&quot;,&amp;b); &#x2F;&#x2F;对象的地址</span><br><span class=\"line\">    printf(&quot;%p\\n&quot;,*(int*)&amp;b);    &#x2F;&#x2F;vptr的值，也就是虚函数表的地址</span><br><span class=\"line\">    PFUN pfun &#x3D; (PFUN)*(int*)*(int*)&amp;b;</span><br><span class=\"line\">    pfun();   &#x2F;&#x2F;调用了f()     (*pfun)()也行</span><br><span class=\"line\">\treturn 0;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\">(PFUN)*((int*)*(int*)&amp;b+0) --------&gt;Base::f()的地址</span><br><span class=\"line\">(PFUN)*((int*)*(int*)&amp;b+1) --------&gt;Base::g()的地址</span><br><span class=\"line\">(PFUN)*((int*)*(int*)&amp;b+2) --------&gt;Base::h()的地址</span><br><span class=\"line\">*&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>根据上面这个实例，可见通过对实例取地址，转换成int类型指针，然后间接引用取到vptr的值，也就是虚表的地址，然后再进行一次强转int类型指针，再次间接引用，取得函数地址。</p>\n<p><strong>注意点：32位的机器用int类型指针强转，而64位机器要用long long 强转  因为32位和64位指针大小不一样</strong></p>\n<p><img src=\"/pic/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png\" alt=\"\"></p>\n<h2 id=\"一般单继承\"><a href=\"#一般单继承\" class=\"headerlink\" title=\"一般单继承\"></a>一般单继承</h2><p>原则：</p>\n<ol>\n<li>子类与父类拥有各自的一个虚函数表</li>\n<li>若子类并无overwrite父类虚函数，用父类虚函数</li>\n<li>若子类重写（overwrite）了父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数</li>\n<li>若子声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后</li>\n</ol>\n<ul>\n<li>子类没有重写父类的虚函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint m_x;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tBase(int x &#x3D; 1):m_x(x)&#123;&#125;</span><br><span class=\"line\">\tvirtual void f()&#123; cout&lt;&lt;&quot;f&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g()&#123;cout&lt;&lt;&quot;g&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h()&#123;cout&lt;&lt;&quot;h&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Derive:public Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tDerive(int x &#x3D; 2.0):Base(x)&#123;&#125;</span><br><span class=\"line\">\tvirtual void f1()&#123; cout&lt;&lt;&quot;f1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g1()&#123;cout&lt;&lt;&quot;g1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h1()&#123;cout&lt;&lt;&quot;h1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void(*PFUN)();  </span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Base b;</span><br><span class=\"line\">    PFUN pfun &#x3D; (PFUN)*(int*)*(int*)&amp;b;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,sizeof(b));\t\t     &#x2F;&#x2F;实例b的字节数\t\t输出8</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,&amp;b);\t\t\t\t\t &#x2F;&#x2F;对象b的地址  \t    010FFABC</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,&amp;b.m_x);\t&#x2F;&#x2F;对象中m_x成员的地址  010FFAC0   比上一个多4  也就是vptr的大小</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;将对象的地址 移动一个int  然后强制成int*   010FFAC0   也就是m_x的地址</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,(int*)((int*)&amp;b+1));\t</span><br><span class=\"line\">\t&#x2F;&#x2F;将对象的地址 移动一个int  然后强制成int* 再间接引用  取出来m_x的值\t 输出1</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,*(int*)((int*)&amp;b+1));\t</span><br><span class=\"line\">    pfun(); </span><br><span class=\"line\"></span><br><span class=\"line\">\tDerive d;</span><br><span class=\"line\">\tPFUN pfun1 &#x3D; (PFUN)*(int*)*(int*)&amp;d;\t &#x2F;&#x2F;Base::f()的地址</span><br><span class=\"line\">\tPFUN pfun2 &#x3D; (PFUN)*((int*)*(int*)&amp;d+3); &#x2F;&#x2F;Derive::f1()的地址</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,sizeof(d));            &#x2F;&#x2F; 实例d的字节数\t\t 输出8</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,&amp;d);\t\t\t\t\t &#x2F;&#x2F;对象b的地址  \t    010FFAA0</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,&amp;d.m_x);&#x2F;&#x2F;对象中m_x成员的地址  010FFAA4   比上一个多4  也就是子类vptr的大小</span><br><span class=\"line\">\t&#x2F;&#x2F;将对象的地址 移动一个int  然后强制成int*   010FFAA4   也就是m_x的地址</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,(int*)((int*)&amp;d+1));</span><br><span class=\"line\">    &#x2F;&#x2F;将对象的地址 移动一个int  然后强制成int* 再间接引用  取出来m_x的值 输出2</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,*(int*)((int*)&amp;d+1));\t </span><br><span class=\"line\">\tpfun1();\t\t\t\t  </span><br><span class=\"line\">\tpfun2();</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Derive类的虚函数表如下：</p>\n<p><img src=\"/pic/%E5%8D%95%E7%BB%A7%E6%89%BF%E4%BD%86%E4%B8%8D%E9%87%8D%E5%86%99%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png\" alt=\"\"></p>\n<p>由上图可以看到下面几点：<br>1）虚函数按照其声明顺序放于表中。<br>2）父类的虚函数在子类的虚函数前面。</p>\n<p>有一个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test&#123;</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">    double b;</span><br><span class=\"line\">    virtual void A()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">sizeof(Test)------------&gt;24  why? 好像不符合内存字节对齐的规律</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>子类重写父类的虚函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint m_x;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void f()&#123; cout&lt;&lt;&quot;Base::f&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g()&#123;cout&lt;&lt;&quot;g&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h()&#123;cout&lt;&lt;&quot;h&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Derive:public Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void f()&#123; cout&lt;&lt;&quot;Derive::f&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g1()&#123;cout&lt;&lt;&quot;g1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h1()&#123;cout&lt;&lt;&quot;h1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void(*PFUN)();  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDerive d;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPFUN pfun&#x3D; (PFUN) *(int*)*(int*)&amp;d;  &#x2F;&#x2F;\tDerive::f()</span><br><span class=\"line\">\tPFUN pfun1&#x3D; (PFUN)*((int*)*(int*)&amp;d+3);&#x2F;&#x2F; Derive::g1()</span><br><span class=\"line\">\tpfun();</span><br><span class=\"line\">\tpfun1();</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Derive类的虚函数表如下：</p>\n<p><img src=\"/pic/%E5%8D%95%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99%E8%99%9A%E5%87%BD%E6%95%B0.png\" alt=\"\"></p>\n<p>由上图可以看到下面几点：<br>1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。<br>2）没有被覆盖的函数依旧。</p>\n<p>因此，多态的实现可以通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base *b &#x3D; new Derive();</span><br><span class=\"line\">b-&gt;f();</span><br></pre></td></tr></table></figure>\n\n<p>由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</p>\n<h2 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h2><p>原则：</p>\n<ol>\n<li>若子类新增虚函数，放在声明的第一个父类的虚函数表中</li>\n<li>若子类重写了父类的虚函数，所有父类的虚函数表都要改变：如fun1</li>\n<li>内存布局中，父类按照其声明顺序排列</li>\n</ol>\n<ul>\n<li>无虚函数重写</li>\n</ul>\n<p>类图：</p>\n<p><img src=\"/pic/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%97%A0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96.png\" alt=\"\"></p>\n<p>Derive类的虚函数表如下：</p>\n<p><img src=\"/pic/%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%97%A0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png\" alt=\"\"></p>\n<p>由上图可以看到下面几点：<br>1） 每个父类都有自己的虚表。<br>2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</p>\n<ul>\n<li>有虚函数重写</li>\n</ul>\n<p><img src=\"/pic/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99.png\" alt=\"\"></p>\n<p>图中子类重写了父类的f()函数</p>\n<p>Derive类的虚函数表如下：</p>\n<p><img src=\"/pic/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Derive d;</span><br><span class=\"line\">Base1 *b1 &#x3D; &amp;d;</span><br><span class=\"line\">Base2 *b2 &#x3D; &amp;d;</span><br><span class=\"line\">Base3 *b3 &#x3D; &amp;d;</span><br><span class=\"line\">b1-&gt;f(); &#x2F;&#x2F;Derive::f()</span><br><span class=\"line\">b2-&gt;f(); &#x2F;&#x2F;Derive::f()</span><br><span class=\"line\">b3-&gt;f(); &#x2F;&#x2F;Derive::f()</span><br><span class=\"line\">b1-&gt;g(); &#x2F;&#x2F;Base1::g()</span><br><span class=\"line\">b2-&gt;g(); &#x2F;&#x2F;Base2::g()</span><br><span class=\"line\">b3-&gt;g(); &#x2F;&#x2F;Base3::g()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h2><p>虚继承解决了菱形继承中派生类拥有多个间接父类实例的情况</p>\n<p>原则：</p>\n<ol>\n<li>虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个新的虚函数指针（vptr）以及一张虚函数表。该vptr位于对象内存最前面（对比非虚继承：直接扩展父类虚函数表）</li>\n<li>虚继承的子类也单独保留了父类的vptr与虚函数表</li>\n<li>虚继承的子类有虚基类表指针（vbptr）</li>\n</ol>\n<ul>\n<li><p>简单虚继承</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint m_base;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void fun1()&#123;cout &lt;&lt; &quot;Base::fun1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void fun2()&#123;cout&lt;&lt;&quot;Base::fun2&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Derive : virtual public Base&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint m_y;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void fun1()&#123;cout &lt;&lt; &quot;Derive::fun1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void fun3()&#123;cout &lt;&lt; &quot;Derive::fun3&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void (*PFUN)();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDerive d;</span><br><span class=\"line\">\tPFUN pfun &#x3D; (PFUN)*(int*)*(int*)&amp;d;\t  &#x2F;&#x2F; Derive::fun3</span><br><span class=\"line\">\tpfun();</span><br><span class=\"line\">\tPFUN pfun1 &#x3D; (PFUN)*(int*)*((int*)&amp;d+3);  &#x2F;&#x2F; Derive::fun1</span><br><span class=\"line\">\tPFUN pfun2 &#x3D; (PFUN) *((int*)*((int*)&amp;d+3)+1);  &#x2F;&#x2F;Base::fun2</span><br><span class=\"line\">\tpfun1();</span><br><span class=\"line\">\tpfun2();</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对象模型：</p>\n<p><img src=\"/pic/%E7%AE%80%E5%8D%95%E8%99%9A%E7%BB%A7%E6%89%BF%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png\" alt=\"\"></p>\n</li>\n<li><p>菱形虚继承</p>\n<p>对象模型:</p>\n<p><img src=\"/pic/%E8%8F%B1%E5%BD%A2%E8%99%9A%E7%BB%A7%E6%89%BF.png\" alt=\"\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>C++中virtual主要是用来实现多态，一般的流程是用父类的指针指向子类的对象，然后通过父类的指针调用子类重写父类的虚函数。所谓多态，就是让父类指针有“多种形态”，换言之，就是用不变的代码实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>\n<p>virtual函数的实现又借助了虚函数指针(vptr)和虚函数表(v-table)实现。vptr的位置为编译器决定，现在很多C++的编译器保证虚函数表的指针存在于对象实例中最前面的位置。</p>","more":"<h2 id=\"虚函数表\"><a href=\"#虚函数表\" class=\"headerlink\" title=\"虚函数表\"></a>虚函数表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tdouble x;</span><br><span class=\"line\">\tint y;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void f()&#123; cout&lt;&lt;&quot;f&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g()&#123;cout&lt;&lt;&quot;g&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h()&#123;cout&lt;&lt;&quot;h&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">typedef void(*PFUN)();  </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Base b;</span><br><span class=\"line\">    printf(&quot;%p\\n&quot;,&amp;b); &#x2F;&#x2F;对象的地址</span><br><span class=\"line\">    printf(&quot;%p\\n&quot;,*(int*)&amp;b);    &#x2F;&#x2F;vptr的值，也就是虚函数表的地址</span><br><span class=\"line\">    PFUN pfun &#x3D; (PFUN)*(int*)*(int*)&amp;b;</span><br><span class=\"line\">    pfun();   &#x2F;&#x2F;调用了f()     (*pfun)()也行</span><br><span class=\"line\">\treturn 0;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\">(PFUN)*((int*)*(int*)&amp;b+0) --------&gt;Base::f()的地址</span><br><span class=\"line\">(PFUN)*((int*)*(int*)&amp;b+1) --------&gt;Base::g()的地址</span><br><span class=\"line\">(PFUN)*((int*)*(int*)&amp;b+2) --------&gt;Base::h()的地址</span><br><span class=\"line\">*&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>根据上面这个实例，可见通过对实例取地址，转换成int类型指针，然后间接引用取到vptr的值，也就是虚表的地址，然后再进行一次强转int类型指针，再次间接引用，取得函数地址。</p>\n<p><strong>注意点：32位的机器用int类型指针强转，而64位机器要用long long 强转  因为32位和64位指针大小不一样</strong></p>\n<p><img src=\"/pic/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png\" alt=\"\"></p>\n<h2 id=\"一般单继承\"><a href=\"#一般单继承\" class=\"headerlink\" title=\"一般单继承\"></a>一般单继承</h2><p>原则：</p>\n<ol>\n<li>子类与父类拥有各自的一个虚函数表</li>\n<li>若子类并无overwrite父类虚函数，用父类虚函数</li>\n<li>若子类重写（overwrite）了父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数</li>\n<li>若子声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后</li>\n</ol>\n<ul>\n<li>子类没有重写父类的虚函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint m_x;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tBase(int x &#x3D; 1):m_x(x)&#123;&#125;</span><br><span class=\"line\">\tvirtual void f()&#123; cout&lt;&lt;&quot;f&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g()&#123;cout&lt;&lt;&quot;g&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h()&#123;cout&lt;&lt;&quot;h&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Derive:public Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tDerive(int x &#x3D; 2.0):Base(x)&#123;&#125;</span><br><span class=\"line\">\tvirtual void f1()&#123; cout&lt;&lt;&quot;f1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g1()&#123;cout&lt;&lt;&quot;g1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h1()&#123;cout&lt;&lt;&quot;h1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void(*PFUN)();  </span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Base b;</span><br><span class=\"line\">    PFUN pfun &#x3D; (PFUN)*(int*)*(int*)&amp;b;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,sizeof(b));\t\t     &#x2F;&#x2F;实例b的字节数\t\t输出8</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,&amp;b);\t\t\t\t\t &#x2F;&#x2F;对象b的地址  \t    010FFABC</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,&amp;b.m_x);\t&#x2F;&#x2F;对象中m_x成员的地址  010FFAC0   比上一个多4  也就是vptr的大小</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;将对象的地址 移动一个int  然后强制成int*   010FFAC0   也就是m_x的地址</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,(int*)((int*)&amp;b+1));\t</span><br><span class=\"line\">\t&#x2F;&#x2F;将对象的地址 移动一个int  然后强制成int* 再间接引用  取出来m_x的值\t 输出1</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,*(int*)((int*)&amp;b+1));\t</span><br><span class=\"line\">    pfun(); </span><br><span class=\"line\"></span><br><span class=\"line\">\tDerive d;</span><br><span class=\"line\">\tPFUN pfun1 &#x3D; (PFUN)*(int*)*(int*)&amp;d;\t &#x2F;&#x2F;Base::f()的地址</span><br><span class=\"line\">\tPFUN pfun2 &#x3D; (PFUN)*((int*)*(int*)&amp;d+3); &#x2F;&#x2F;Derive::f1()的地址</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,sizeof(d));            &#x2F;&#x2F; 实例d的字节数\t\t 输出8</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,&amp;d);\t\t\t\t\t &#x2F;&#x2F;对象b的地址  \t    010FFAA0</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,&amp;d.m_x);&#x2F;&#x2F;对象中m_x成员的地址  010FFAA4   比上一个多4  也就是子类vptr的大小</span><br><span class=\"line\">\t&#x2F;&#x2F;将对象的地址 移动一个int  然后强制成int*   010FFAA4   也就是m_x的地址</span><br><span class=\"line\">\tprintf(&quot;%p\\n&quot;,(int*)((int*)&amp;d+1));</span><br><span class=\"line\">    &#x2F;&#x2F;将对象的地址 移动一个int  然后强制成int* 再间接引用  取出来m_x的值 输出2</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;,*(int*)((int*)&amp;d+1));\t </span><br><span class=\"line\">\tpfun1();\t\t\t\t  </span><br><span class=\"line\">\tpfun2();</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Derive类的虚函数表如下：</p>\n<p><img src=\"/pic/%E5%8D%95%E7%BB%A7%E6%89%BF%E4%BD%86%E4%B8%8D%E9%87%8D%E5%86%99%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png\" alt=\"\"></p>\n<p>由上图可以看到下面几点：<br>1）虚函数按照其声明顺序放于表中。<br>2）父类的虚函数在子类的虚函数前面。</p>\n<p>有一个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test&#123;</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">    double b;</span><br><span class=\"line\">    virtual void A()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">sizeof(Test)------------&gt;24  why? 好像不符合内存字节对齐的规律</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>子类重写父类的虚函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint m_x;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void f()&#123; cout&lt;&lt;&quot;Base::f&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g()&#123;cout&lt;&lt;&quot;g&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h()&#123;cout&lt;&lt;&quot;h&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Derive:public Base&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void f()&#123; cout&lt;&lt;&quot;Derive::f&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void g1()&#123;cout&lt;&lt;&quot;g1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void h1()&#123;cout&lt;&lt;&quot;h1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void(*PFUN)();  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDerive d;</span><br><span class=\"line\"></span><br><span class=\"line\">\tPFUN pfun&#x3D; (PFUN) *(int*)*(int*)&amp;d;  &#x2F;&#x2F;\tDerive::f()</span><br><span class=\"line\">\tPFUN pfun1&#x3D; (PFUN)*((int*)*(int*)&amp;d+3);&#x2F;&#x2F; Derive::g1()</span><br><span class=\"line\">\tpfun();</span><br><span class=\"line\">\tpfun1();</span><br><span class=\"line\"></span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Derive类的虚函数表如下：</p>\n<p><img src=\"/pic/%E5%8D%95%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99%E8%99%9A%E5%87%BD%E6%95%B0.png\" alt=\"\"></p>\n<p>由上图可以看到下面几点：<br>1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。<br>2）没有被覆盖的函数依旧。</p>\n<p>因此，多态的实现可以通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base *b &#x3D; new Derive();</span><br><span class=\"line\">b-&gt;f();</span><br></pre></td></tr></table></figure>\n\n<p>由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</p>\n<h2 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h2><p>原则：</p>\n<ol>\n<li>若子类新增虚函数，放在声明的第一个父类的虚函数表中</li>\n<li>若子类重写了父类的虚函数，所有父类的虚函数表都要改变：如fun1</li>\n<li>内存布局中，父类按照其声明顺序排列</li>\n</ol>\n<ul>\n<li>无虚函数重写</li>\n</ul>\n<p>类图：</p>\n<p><img src=\"/pic/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%97%A0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96.png\" alt=\"\"></p>\n<p>Derive类的虚函数表如下：</p>\n<p><img src=\"/pic/%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%97%A0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png\" alt=\"\"></p>\n<p>由上图可以看到下面几点：<br>1） 每个父类都有自己的虚表。<br>2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</p>\n<ul>\n<li>有虚函数重写</li>\n</ul>\n<p><img src=\"/pic/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99.png\" alt=\"\"></p>\n<p>图中子类重写了父类的f()函数</p>\n<p>Derive类的虚函数表如下：</p>\n<p><img src=\"/pic/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Derive d;</span><br><span class=\"line\">Base1 *b1 &#x3D; &amp;d;</span><br><span class=\"line\">Base2 *b2 &#x3D; &amp;d;</span><br><span class=\"line\">Base3 *b3 &#x3D; &amp;d;</span><br><span class=\"line\">b1-&gt;f(); &#x2F;&#x2F;Derive::f()</span><br><span class=\"line\">b2-&gt;f(); &#x2F;&#x2F;Derive::f()</span><br><span class=\"line\">b3-&gt;f(); &#x2F;&#x2F;Derive::f()</span><br><span class=\"line\">b1-&gt;g(); &#x2F;&#x2F;Base1::g()</span><br><span class=\"line\">b2-&gt;g(); &#x2F;&#x2F;Base2::g()</span><br><span class=\"line\">b3-&gt;g(); &#x2F;&#x2F;Base3::g()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h2><p>虚继承解决了菱形继承中派生类拥有多个间接父类实例的情况</p>\n<p>原则：</p>\n<ol>\n<li>虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个新的虚函数指针（vptr）以及一张虚函数表。该vptr位于对象内存最前面（对比非虚继承：直接扩展父类虚函数表）</li>\n<li>虚继承的子类也单独保留了父类的vptr与虚函数表</li>\n<li>虚继承的子类有虚基类表指针（vbptr）</li>\n</ol>\n<ul>\n<li><p>简单虚继承</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint m_base;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void fun1()&#123;cout &lt;&lt; &quot;Base::fun1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void fun2()&#123;cout&lt;&lt;&quot;Base::fun2&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Derive : virtual public Base&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint m_y;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void fun1()&#123;cout &lt;&lt; &quot;Derive::fun1&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\">\tvirtual void fun3()&#123;cout &lt;&lt; &quot;Derive::fun3&quot;&lt;&lt;endl;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void (*PFUN)();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDerive d;</span><br><span class=\"line\">\tPFUN pfun &#x3D; (PFUN)*(int*)*(int*)&amp;d;\t  &#x2F;&#x2F; Derive::fun3</span><br><span class=\"line\">\tpfun();</span><br><span class=\"line\">\tPFUN pfun1 &#x3D; (PFUN)*(int*)*((int*)&amp;d+3);  &#x2F;&#x2F; Derive::fun1</span><br><span class=\"line\">\tPFUN pfun2 &#x3D; (PFUN) *((int*)*((int*)&amp;d+3)+1);  &#x2F;&#x2F;Base::fun2</span><br><span class=\"line\">\tpfun1();</span><br><span class=\"line\">\tpfun2();</span><br><span class=\"line\">\tgetchar();</span><br><span class=\"line\">\treturn 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对象模型：</p>\n<p><img src=\"/pic/%E7%AE%80%E5%8D%95%E8%99%9A%E7%BB%A7%E6%89%BF%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png\" alt=\"\"></p>\n</li>\n<li><p>菱形虚继承</p>\n<p>对象模型:</p>\n<p><img src=\"/pic/%E8%8F%B1%E5%BD%A2%E8%99%9A%E7%BB%A7%E6%89%BF.png\" alt=\"\"></p>\n</li>\n</ul>"},{"title":"设计模式之简单工厂","date":"2018-11-12T12:12:15.000Z","_content":"\n学习C++也有一年多了，基础语法、计算机基础也掌握地不错了，但是在写项目时总是觉得设计框架很困难，分析类之间的关系很杂乱，因此开始学习设计模式。\n\n## 简单工厂\n\n也叫做静态工厂模式，是类创建型模式(同种类型的还有，单例，工厂方法，抽象工厂，建造者)，在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个工厂类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n\n## 模式结构\n\n- 工厂类：是该模式的核心，在客户端的直接调用下根据传入参数的不同创建对应的产品(类对象)\n- 抽象产品类：是由简单工厂模式所创建对象的父类，拥有产品们共有的特性和接口\n- 具体产品类: 简单工厂创建的任何对象都是这个角色的实例，用来完成具体工作\n\n## 实例分析\n\n![](/pic/简单工厂.png)\n\n实例中，加减乘除派生自一个基类，该基类定义了公有的属性以及虚函数接口。在各个派生类中实现了每个派生类中需要的功能。除此之外还定义了简单工厂类，在简单工厂类中，根据运算符决定需要实例化那个运算功能类。\n\n```\nclass Calculation{  /*抽象产品类*/\npublic:\t\t\n\tCalculation(int x,int y):\n\t\tnum1(x),num2(y){};\n\tint num1;\n\tint num2;\n\tvirtual int calculate() = 0;\n};\n\nclass Add: public Calculation{\npublic:\n\tAdd(int n1,int n2):Calculation(n1,n2){}\n\tint calculate(){\n\t\treturn num1+num2;\n\t}\n};\nclass Sub: public Calculation{\npublic:\n\tSub(int n1,int n2):Calculation(n1,n2){}\n\tint calculate(){\n\t\treturn num1-num2;\n\t}\n};\nclass Mul: public Calculation{\npublic:\n\tMul(int n1,int n2):Calculation(n1,n2){}\n\tint calculate(){\n\t\treturn num1*num2;\n\t}\n};\nclass Div: public Calculation{\npublic:\n\tDiv(int n1,int n2):Calculation(n1,n2){}\n\tint calculate(){\n\t\tif(num2 == 0)\n\t\t\treturn 0;\n\t\treturn num1/num2;\n\t}\n};\n\n\nclass Factory{  /*简单工厂类*/\npublic:\n\tint num1;\n\tint num2;\n\tchar op;\n\tint result;\n\tCalculation* cal;\n\tFactory(int n1,char op,int n2){\n\t\tnum1 =n1;\n\t\tnum2 = n2;\n\t\tthis->op = op;\n\t}\n\tint GetResult(){\n\t\t\n\t\tswitch(this->op)\n\t\t{\n\t\tcase '+':\n\t\t\tcal = new Add(num1,num2);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tcal = new Sub(num1,num2);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tcal = new Mul(num1,num2);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tcal = new Div(num1,num2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = cal->calculate();\n\n\t\treturn result;\n\t}\n};\n```\n\n## 优缺点分析\n\n优点：\n\n1.客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量\n\n2.当需要引入新的产品是不需要修改客户端的代码，只需要添加相应的产品类并修改工厂类就可以了，所以说从产品的角度上简单工厂模式是符合“开-闭”原则的\n\n3.工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象\n\n缺点：\n1.一旦工厂类出问题，整个程序会受影响\n\n2.增加系统了中类的个数，在一定程序上增加了系统的复杂度和理解难度\n\n3.系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护\n\n## 适用场合\n\n1.工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。\n\n2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。","source":"_posts/设计模式之简单工厂.md","raw":"---\ntitle: 设计模式之简单工厂\ndate: 2018-11-12 20:12:15\ntags: 设计模式\n---\n\n学习C++也有一年多了，基础语法、计算机基础也掌握地不错了，但是在写项目时总是觉得设计框架很困难，分析类之间的关系很杂乱，因此开始学习设计模式。\n\n## 简单工厂\n\n也叫做静态工厂模式，是类创建型模式(同种类型的还有，单例，工厂方法，抽象工厂，建造者)，在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个工厂类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n\n## 模式结构\n\n- 工厂类：是该模式的核心，在客户端的直接调用下根据传入参数的不同创建对应的产品(类对象)\n- 抽象产品类：是由简单工厂模式所创建对象的父类，拥有产品们共有的特性和接口\n- 具体产品类: 简单工厂创建的任何对象都是这个角色的实例，用来完成具体工作\n\n## 实例分析\n\n![](/pic/简单工厂.png)\n\n实例中，加减乘除派生自一个基类，该基类定义了公有的属性以及虚函数接口。在各个派生类中实现了每个派生类中需要的功能。除此之外还定义了简单工厂类，在简单工厂类中，根据运算符决定需要实例化那个运算功能类。\n\n```\nclass Calculation{  /*抽象产品类*/\npublic:\t\t\n\tCalculation(int x,int y):\n\t\tnum1(x),num2(y){};\n\tint num1;\n\tint num2;\n\tvirtual int calculate() = 0;\n};\n\nclass Add: public Calculation{\npublic:\n\tAdd(int n1,int n2):Calculation(n1,n2){}\n\tint calculate(){\n\t\treturn num1+num2;\n\t}\n};\nclass Sub: public Calculation{\npublic:\n\tSub(int n1,int n2):Calculation(n1,n2){}\n\tint calculate(){\n\t\treturn num1-num2;\n\t}\n};\nclass Mul: public Calculation{\npublic:\n\tMul(int n1,int n2):Calculation(n1,n2){}\n\tint calculate(){\n\t\treturn num1*num2;\n\t}\n};\nclass Div: public Calculation{\npublic:\n\tDiv(int n1,int n2):Calculation(n1,n2){}\n\tint calculate(){\n\t\tif(num2 == 0)\n\t\t\treturn 0;\n\t\treturn num1/num2;\n\t}\n};\n\n\nclass Factory{  /*简单工厂类*/\npublic:\n\tint num1;\n\tint num2;\n\tchar op;\n\tint result;\n\tCalculation* cal;\n\tFactory(int n1,char op,int n2){\n\t\tnum1 =n1;\n\t\tnum2 = n2;\n\t\tthis->op = op;\n\t}\n\tint GetResult(){\n\t\t\n\t\tswitch(this->op)\n\t\t{\n\t\tcase '+':\n\t\t\tcal = new Add(num1,num2);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tcal = new Sub(num1,num2);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tcal = new Mul(num1,num2);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tcal = new Div(num1,num2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tresult = cal->calculate();\n\n\t\treturn result;\n\t}\n};\n```\n\n## 优缺点分析\n\n优点：\n\n1.客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量\n\n2.当需要引入新的产品是不需要修改客户端的代码，只需要添加相应的产品类并修改工厂类就可以了，所以说从产品的角度上简单工厂模式是符合“开-闭”原则的\n\n3.工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象\n\n缺点：\n1.一旦工厂类出问题，整个程序会受影响\n\n2.增加系统了中类的个数，在一定程序上增加了系统的复杂度和理解难度\n\n3.系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护\n\n## 适用场合\n\n1.工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。\n\n2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。","slug":"设计模式之简单工厂","published":1,"updated":"2021-12-06T05:30:36.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip80002p96ca86s1asbq","content":"<p>学习C++也有一年多了，基础语法、计算机基础也掌握地不错了，但是在写项目时总是觉得设计框架很困难，分析类之间的关系很杂乱，因此开始学习设计模式。</p>\n<h2 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h2><p>也叫做静态工厂模式，是类创建型模式(同种类型的还有，单例，工厂方法，抽象工厂，建造者)，在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个工厂类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><ul>\n<li>工厂类：是该模式的核心，在客户端的直接调用下根据传入参数的不同创建对应的产品(类对象)</li>\n<li>抽象产品类：是由简单工厂模式所创建对象的父类，拥有产品们共有的特性和接口</li>\n<li>具体产品类: 简单工厂创建的任何对象都是这个角色的实例，用来完成具体工作</li>\n</ul>\n<h2 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h2><p><img src=\"/pic/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png\" alt=\"\"></p>\n<p>实例中，加减乘除派生自一个基类，该基类定义了公有的属性以及虚函数接口。在各个派生类中实现了每个派生类中需要的功能。除此之外还定义了简单工厂类，在简单工厂类中，根据运算符决定需要实例化那个运算功能类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Calculation&#123;  &#x2F;*抽象产品类*&#x2F;</span><br><span class=\"line\">public:\t\t</span><br><span class=\"line\">\tCalculation(int x,int y):</span><br><span class=\"line\">\t\tnum1(x),num2(y)&#123;&#125;;</span><br><span class=\"line\">\tint num1;</span><br><span class=\"line\">\tint num2;</span><br><span class=\"line\">\tvirtual int calculate() &#x3D; 0;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Add: public Calculation&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tAdd(int n1,int n2):Calculation(n1,n2)&#123;&#125;</span><br><span class=\"line\">\tint calculate()&#123;</span><br><span class=\"line\">\t\treturn num1+num2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Sub: public Calculation&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tSub(int n1,int n2):Calculation(n1,n2)&#123;&#125;</span><br><span class=\"line\">\tint calculate()&#123;</span><br><span class=\"line\">\t\treturn num1-num2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Mul: public Calculation&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tMul(int n1,int n2):Calculation(n1,n2)&#123;&#125;</span><br><span class=\"line\">\tint calculate()&#123;</span><br><span class=\"line\">\t\treturn num1*num2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Div: public Calculation&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tDiv(int n1,int n2):Calculation(n1,n2)&#123;&#125;</span><br><span class=\"line\">\tint calculate()&#123;</span><br><span class=\"line\">\t\tif(num2 &#x3D;&#x3D; 0)</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\treturn num1&#x2F;num2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class Factory&#123;  &#x2F;*简单工厂类*&#x2F;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint num1;</span><br><span class=\"line\">\tint num2;</span><br><span class=\"line\">\tchar op;</span><br><span class=\"line\">\tint result;</span><br><span class=\"line\">\tCalculation* cal;</span><br><span class=\"line\">\tFactory(int n1,char op,int n2)&#123;</span><br><span class=\"line\">\t\tnum1 &#x3D;n1;</span><br><span class=\"line\">\t\tnum2 &#x3D; n2;</span><br><span class=\"line\">\t\tthis-&gt;op &#x3D; op;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint GetResult()&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tswitch(this-&gt;op)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\tcase &#39;+&#39;:</span><br><span class=\"line\">\t\t\tcal &#x3D; new Add(num1,num2);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &#39;-&#39;:</span><br><span class=\"line\">\t\t\tcal &#x3D; new Sub(num1,num2);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &#39;*&#39;:</span><br><span class=\"line\">\t\t\tcal &#x3D; new Mul(num1,num2);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &#39;&#x2F;&#39;:</span><br><span class=\"line\">\t\t\tcal &#x3D; new Div(num1,num2);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tdefault:</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tresult &#x3D; cal-&gt;calculate();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h2><p>优点：</p>\n<p>1.客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量</p>\n<p>2.当需要引入新的产品是不需要修改客户端的代码，只需要添加相应的产品类并修改工厂类就可以了，所以说从产品的角度上简单工厂模式是符合“开-闭”原则的</p>\n<p>3.工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象</p>\n<p>缺点：<br>1.一旦工厂类出问题，整个程序会受影响</p>\n<p>2.增加系统了中类的个数，在一定程序上增加了系统的复杂度和理解难度</p>\n<p>3.系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护</p>\n<h2 id=\"适用场合\"><a href=\"#适用场合\" class=\"headerlink\" title=\"适用场合\"></a>适用场合</h2><p>1.工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p>\n<p>2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习C++也有一年多了，基础语法、计算机基础也掌握地不错了，但是在写项目时总是觉得设计框架很困难，分析类之间的关系很杂乱，因此开始学习设计模式。</p>\n<h2 id=\"简单工厂\"><a href=\"#简单工厂\" class=\"headerlink\" title=\"简单工厂\"></a>简单工厂</h2><p>也叫做静态工厂模式，是类创建型模式(同种类型的还有，单例，工厂方法，抽象工厂，建造者)，在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个工厂类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><ul>\n<li>工厂类：是该模式的核心，在客户端的直接调用下根据传入参数的不同创建对应的产品(类对象)</li>\n<li>抽象产品类：是由简单工厂模式所创建对象的父类，拥有产品们共有的特性和接口</li>\n<li>具体产品类: 简单工厂创建的任何对象都是这个角色的实例，用来完成具体工作</li>\n</ul>\n<h2 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h2><p><img src=\"/pic/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png\" alt=\"\"></p>\n<p>实例中，加减乘除派生自一个基类，该基类定义了公有的属性以及虚函数接口。在各个派生类中实现了每个派生类中需要的功能。除此之外还定义了简单工厂类，在简单工厂类中，根据运算符决定需要实例化那个运算功能类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Calculation&#123;  &#x2F;*抽象产品类*&#x2F;</span><br><span class=\"line\">public:\t\t</span><br><span class=\"line\">\tCalculation(int x,int y):</span><br><span class=\"line\">\t\tnum1(x),num2(y)&#123;&#125;;</span><br><span class=\"line\">\tint num1;</span><br><span class=\"line\">\tint num2;</span><br><span class=\"line\">\tvirtual int calculate() &#x3D; 0;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Add: public Calculation&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tAdd(int n1,int n2):Calculation(n1,n2)&#123;&#125;</span><br><span class=\"line\">\tint calculate()&#123;</span><br><span class=\"line\">\t\treturn num1+num2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Sub: public Calculation&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tSub(int n1,int n2):Calculation(n1,n2)&#123;&#125;</span><br><span class=\"line\">\tint calculate()&#123;</span><br><span class=\"line\">\t\treturn num1-num2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Mul: public Calculation&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tMul(int n1,int n2):Calculation(n1,n2)&#123;&#125;</span><br><span class=\"line\">\tint calculate()&#123;</span><br><span class=\"line\">\t\treturn num1*num2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Div: public Calculation&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tDiv(int n1,int n2):Calculation(n1,n2)&#123;&#125;</span><br><span class=\"line\">\tint calculate()&#123;</span><br><span class=\"line\">\t\tif(num2 &#x3D;&#x3D; 0)</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\treturn num1&#x2F;num2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class Factory&#123;  &#x2F;*简单工厂类*&#x2F;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint num1;</span><br><span class=\"line\">\tint num2;</span><br><span class=\"line\">\tchar op;</span><br><span class=\"line\">\tint result;</span><br><span class=\"line\">\tCalculation* cal;</span><br><span class=\"line\">\tFactory(int n1,char op,int n2)&#123;</span><br><span class=\"line\">\t\tnum1 &#x3D;n1;</span><br><span class=\"line\">\t\tnum2 &#x3D; n2;</span><br><span class=\"line\">\t\tthis-&gt;op &#x3D; op;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint GetResult()&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tswitch(this-&gt;op)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\tcase &#39;+&#39;:</span><br><span class=\"line\">\t\t\tcal &#x3D; new Add(num1,num2);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &#39;-&#39;:</span><br><span class=\"line\">\t\t\tcal &#x3D; new Sub(num1,num2);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &#39;*&#39;:</span><br><span class=\"line\">\t\t\tcal &#x3D; new Mul(num1,num2);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &#39;&#x2F;&#39;:</span><br><span class=\"line\">\t\t\tcal &#x3D; new Div(num1,num2);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tdefault:</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tresult &#x3D; cal-&gt;calculate();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treturn result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"优缺点分析\"><a href=\"#优缺点分析\" class=\"headerlink\" title=\"优缺点分析\"></a>优缺点分析</h2><p>优点：</p>\n<p>1.客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量</p>\n<p>2.当需要引入新的产品是不需要修改客户端的代码，只需要添加相应的产品类并修改工厂类就可以了，所以说从产品的角度上简单工厂模式是符合“开-闭”原则的</p>\n<p>3.工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象</p>\n<p>缺点：<br>1.一旦工厂类出问题，整个程序会受影响</p>\n<p>2.增加系统了中类的个数，在一定程序上增加了系统的复杂度和理解难度</p>\n<p>3.系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护</p>\n<h2 id=\"适用场合\"><a href=\"#适用场合\" class=\"headerlink\" title=\"适用场合\"></a>适用场合</h2><p>1.工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p>\n<p>2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</p>\n"},{"title":"进程","date":"2019-03-15T09:44:38.000Z","_content":"\n最近面了鹅厂实习的提前批，复试凉凉，还是挂在操作系统。\n\n所以决定恶补一波，跟着工大孙志岗老师的视频和《操作系统之哲学原理》重新学一下操作系统。\n\n## 操作系统\n\n操作系统的作用是管理计算机上的各种资源，在硬件和软件之间起到桥梁的作用。\n\n资源主要包括CPU、内存、文件系统、I/O等。\n\n<!--more-->\n\n## 进程\n\n针对CPU管理，操作系统使用的是进程模型，也就是说操作系统用进程来控制CPU进行计算。\n\n进程是为了在CPU上实现多道编程而出现的概念，也就是通过并发来提高系统利用率，同时缩短系统响应时间。\n\n进程：执行中的程序，也就是说一个程序加载到内存中就变成了进程。\n\n每一个进程都占用一片内存空间，那么如何让多个进程共享同一个物理内存而不发生冲突，这就涉及到[内存管理](http://striveben.top/2019/03/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n\n如何将CPU在多个进程之间进行切换，这就涉及进程实现的另一个问题，[CPU调度](http://striveben.top/2019/03/15/CPU%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/)\n\n#### 进程控制\n\nlinux在操作系统通过进程控制块(PCB)来管理进程,实际上就是一个task_struct结构体。\n\n在我的虚拟机上，它保存在/usr/src/linux-headers-4.4.0-21/include/linux/sched.h文件中\n\n通过/ str(待查找的字符串)可以找到task_struct结构体的定义，保存了进程所有的信息。\n\n单个进程是通过PCB来管理的，那么操作系统又是怎么管理所有进程的PCB的呢？(有待查证)\n\n维护所有进程的队列、就绪队列、设备队列(每个I/O设备都有一个队列，进程阻塞在对应IO的队列上)\n\n那么队列是用什么数据结构实现的呢？\n\n由于各个队列之间需要频繁的添加、删除操作，因此用链表实现似乎更适合。\n\n但是，在操作系统底层用的一个大数组，然后用指针指向一个结构体存储所有就绪队列的编号，用指针指向一个结构体存储设备队列的编号。\n\n为什么要数组呢？\n\n1.访问比较快速，链表遍历是一个很耗时的操作\n\n2.局部性原理(cache)，链表遍历可能造成cache一直刷新，效率低，局部性原理和数组比较般配\n\n3.缺点：有空间的闲置、空洞，造成内存浪费，但是如今硬件条件更好了。\n\n#### 进程在内存中的模型\n\n虚拟地址空间\n\n32位系统  0-4G\n\n64位系统  0-256TB\n\n以32位为例\n\n![](/pic/linux进程内存分布.png)\n\nLinux 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为： \n\n- 只读段：该部分空间只能读，不可写；(包括：代码段、rodata 段(C常量字符串和#define定义的常量) )\n- 数据段：保存全局变量、静态变量的空间；\n- 堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。 \n- 文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。\n- 栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。 \n- 内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)\n\n其中 0x08048000~0xbfffffff 是用户空间，0xc0000000~0xffffffff 是内核空间，包括内核代码和数据、与进程相关的数据结构（如页表、内核栈）等。另外，%esp 执行栈顶，往低地址方向变化；brk/sbrk 函数控制堆顶_edata往高地址方向变化。\n\n","source":"_posts/进程.md","raw":"---\ntitle: 进程\ndate: 2019-03-15 17:44:38\ntags:\n- 进程\n- 操作系统\n---\n\n最近面了鹅厂实习的提前批，复试凉凉，还是挂在操作系统。\n\n所以决定恶补一波，跟着工大孙志岗老师的视频和《操作系统之哲学原理》重新学一下操作系统。\n\n## 操作系统\n\n操作系统的作用是管理计算机上的各种资源，在硬件和软件之间起到桥梁的作用。\n\n资源主要包括CPU、内存、文件系统、I/O等。\n\n<!--more-->\n\n## 进程\n\n针对CPU管理，操作系统使用的是进程模型，也就是说操作系统用进程来控制CPU进行计算。\n\n进程是为了在CPU上实现多道编程而出现的概念，也就是通过并发来提高系统利用率，同时缩短系统响应时间。\n\n进程：执行中的程序，也就是说一个程序加载到内存中就变成了进程。\n\n每一个进程都占用一片内存空间，那么如何让多个进程共享同一个物理内存而不发生冲突，这就涉及到[内存管理](http://striveben.top/2019/03/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n\n如何将CPU在多个进程之间进行切换，这就涉及进程实现的另一个问题，[CPU调度](http://striveben.top/2019/03/15/CPU%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/)\n\n#### 进程控制\n\nlinux在操作系统通过进程控制块(PCB)来管理进程,实际上就是一个task_struct结构体。\n\n在我的虚拟机上，它保存在/usr/src/linux-headers-4.4.0-21/include/linux/sched.h文件中\n\n通过/ str(待查找的字符串)可以找到task_struct结构体的定义，保存了进程所有的信息。\n\n单个进程是通过PCB来管理的，那么操作系统又是怎么管理所有进程的PCB的呢？(有待查证)\n\n维护所有进程的队列、就绪队列、设备队列(每个I/O设备都有一个队列，进程阻塞在对应IO的队列上)\n\n那么队列是用什么数据结构实现的呢？\n\n由于各个队列之间需要频繁的添加、删除操作，因此用链表实现似乎更适合。\n\n但是，在操作系统底层用的一个大数组，然后用指针指向一个结构体存储所有就绪队列的编号，用指针指向一个结构体存储设备队列的编号。\n\n为什么要数组呢？\n\n1.访问比较快速，链表遍历是一个很耗时的操作\n\n2.局部性原理(cache)，链表遍历可能造成cache一直刷新，效率低，局部性原理和数组比较般配\n\n3.缺点：有空间的闲置、空洞，造成内存浪费，但是如今硬件条件更好了。\n\n#### 进程在内存中的模型\n\n虚拟地址空间\n\n32位系统  0-4G\n\n64位系统  0-256TB\n\n以32位为例\n\n![](/pic/linux进程内存分布.png)\n\nLinux 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为： \n\n- 只读段：该部分空间只能读，不可写；(包括：代码段、rodata 段(C常量字符串和#define定义的常量) )\n- 数据段：保存全局变量、静态变量的空间；\n- 堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。 \n- 文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。\n- 栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。 \n- 内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)\n\n其中 0x08048000~0xbfffffff 是用户空间，0xc0000000~0xffffffff 是内核空间，包括内核代码和数据、与进程相关的数据结构（如页表、内核栈）等。另外，%esp 执行栈顶，往低地址方向变化；brk/sbrk 函数控制堆顶_edata往高地址方向变化。\n\n","slug":"进程","published":1,"updated":"2021-12-06T05:30:36.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip80002s96caailfhe22","content":"<p>最近面了鹅厂实习的提前批，复试凉凉，还是挂在操作系统。</p>\n<p>所以决定恶补一波，跟着工大孙志岗老师的视频和《操作系统之哲学原理》重新学一下操作系统。</p>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><p>操作系统的作用是管理计算机上的各种资源，在硬件和软件之间起到桥梁的作用。</p>\n<p>资源主要包括CPU、内存、文件系统、I/O等。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>针对CPU管理，操作系统使用的是进程模型，也就是说操作系统用进程来控制CPU进行计算。</p>\n<p>进程是为了在CPU上实现多道编程而出现的概念，也就是通过并发来提高系统利用率，同时缩短系统响应时间。</p>\n<p>进程：执行中的程序，也就是说一个程序加载到内存中就变成了进程。</p>\n<p>每一个进程都占用一片内存空间，那么如何让多个进程共享同一个物理内存而不发生冲突，这就涉及到<a href=\"http://striveben.top/2019/03/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理</a></p>\n<p>如何将CPU在多个进程之间进行切换，这就涉及进程实现的另一个问题，<a href=\"http://striveben.top/2019/03/15/CPU%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">CPU调度</a></p>\n<h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><p>linux在操作系统通过进程控制块(PCB)来管理进程,实际上就是一个task_struct结构体。</p>\n<p>在我的虚拟机上，它保存在/usr/src/linux-headers-4.4.0-21/include/linux/sched.h文件中</p>\n<p>通过/ str(待查找的字符串)可以找到task_struct结构体的定义，保存了进程所有的信息。</p>\n<p>单个进程是通过PCB来管理的，那么操作系统又是怎么管理所有进程的PCB的呢？(有待查证)</p>\n<p>维护所有进程的队列、就绪队列、设备队列(每个I/O设备都有一个队列，进程阻塞在对应IO的队列上)</p>\n<p>那么队列是用什么数据结构实现的呢？</p>\n<p>由于各个队列之间需要频繁的添加、删除操作，因此用链表实现似乎更适合。</p>\n<p>但是，在操作系统底层用的一个大数组，然后用指针指向一个结构体存储所有就绪队列的编号，用指针指向一个结构体存储设备队列的编号。</p>\n<p>为什么要数组呢？</p>\n<p>1.访问比较快速，链表遍历是一个很耗时的操作</p>\n<p>2.局部性原理(cache)，链表遍历可能造成cache一直刷新，效率低，局部性原理和数组比较般配</p>\n<p>3.缺点：有空间的闲置、空洞，造成内存浪费，但是如今硬件条件更好了。</p>\n<h4 id=\"进程在内存中的模型\"><a href=\"#进程在内存中的模型\" class=\"headerlink\" title=\"进程在内存中的模型\"></a>进程在内存中的模型</h4><p>虚拟地址空间</p>\n<p>32位系统  0-4G</p>\n<p>64位系统  0-256TB</p>\n<p>以32位为例</p>\n<p><img src=\"/pic/linux%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png\" alt=\"\"></p>\n<p>Linux 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为： </p>\n<ul>\n<li>只读段：该部分空间只能读，不可写；(包括：代码段、rodata 段(C常量字符串和#define定义的常量) )</li>\n<li>数据段：保存全局变量、静态变量的空间；</li>\n<li>堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。 </li>\n<li>文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。</li>\n<li>栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。 </li>\n<li>内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)</li>\n</ul>\n<p>其中 0x08048000<del>0xbfffffff 是用户空间，0xc0000000</del>0xffffffff 是内核空间，包括内核代码和数据、与进程相关的数据结构（如页表、内核栈）等。另外，%esp 执行栈顶，往低地址方向变化；brk/sbrk 函数控制堆顶_edata往高地址方向变化。</p>\n","site":{"data":{}},"excerpt":"<p>最近面了鹅厂实习的提前批，复试凉凉，还是挂在操作系统。</p>\n<p>所以决定恶补一波，跟着工大孙志岗老师的视频和《操作系统之哲学原理》重新学一下操作系统。</p>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><p>操作系统的作用是管理计算机上的各种资源，在硬件和软件之间起到桥梁的作用。</p>\n<p>资源主要包括CPU、内存、文件系统、I/O等。</p>","more":"<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>针对CPU管理，操作系统使用的是进程模型，也就是说操作系统用进程来控制CPU进行计算。</p>\n<p>进程是为了在CPU上实现多道编程而出现的概念，也就是通过并发来提高系统利用率，同时缩短系统响应时间。</p>\n<p>进程：执行中的程序，也就是说一个程序加载到内存中就变成了进程。</p>\n<p>每一个进程都占用一片内存空间，那么如何让多个进程共享同一个物理内存而不发生冲突，这就涉及到<a href=\"http://striveben.top/2019/03/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理</a></p>\n<p>如何将CPU在多个进程之间进行切换，这就涉及进程实现的另一个问题，<a href=\"http://striveben.top/2019/03/15/CPU%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">CPU调度</a></p>\n<h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><p>linux在操作系统通过进程控制块(PCB)来管理进程,实际上就是一个task_struct结构体。</p>\n<p>在我的虚拟机上，它保存在/usr/src/linux-headers-4.4.0-21/include/linux/sched.h文件中</p>\n<p>通过/ str(待查找的字符串)可以找到task_struct结构体的定义，保存了进程所有的信息。</p>\n<p>单个进程是通过PCB来管理的，那么操作系统又是怎么管理所有进程的PCB的呢？(有待查证)</p>\n<p>维护所有进程的队列、就绪队列、设备队列(每个I/O设备都有一个队列，进程阻塞在对应IO的队列上)</p>\n<p>那么队列是用什么数据结构实现的呢？</p>\n<p>由于各个队列之间需要频繁的添加、删除操作，因此用链表实现似乎更适合。</p>\n<p>但是，在操作系统底层用的一个大数组，然后用指针指向一个结构体存储所有就绪队列的编号，用指针指向一个结构体存储设备队列的编号。</p>\n<p>为什么要数组呢？</p>\n<p>1.访问比较快速，链表遍历是一个很耗时的操作</p>\n<p>2.局部性原理(cache)，链表遍历可能造成cache一直刷新，效率低，局部性原理和数组比较般配</p>\n<p>3.缺点：有空间的闲置、空洞，造成内存浪费，但是如今硬件条件更好了。</p>\n<h4 id=\"进程在内存中的模型\"><a href=\"#进程在内存中的模型\" class=\"headerlink\" title=\"进程在内存中的模型\"></a>进程在内存中的模型</h4><p>虚拟地址空间</p>\n<p>32位系统  0-4G</p>\n<p>64位系统  0-256TB</p>\n<p>以32位为例</p>\n<p><img src=\"/pic/linux%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png\" alt=\"\"></p>\n<p>Linux 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为： </p>\n<ul>\n<li>只读段：该部分空间只能读，不可写；(包括：代码段、rodata 段(C常量字符串和#define定义的常量) )</li>\n<li>数据段：保存全局变量、静态变量的空间；</li>\n<li>堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。 </li>\n<li>文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。</li>\n<li>栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。 </li>\n<li>内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)</li>\n</ul>\n<p>其中 0x08048000<del>0xbfffffff 是用户空间，0xc0000000</del>0xffffffff 是内核空间，包括内核代码和数据、与进程相关的数据结构（如页表、内核栈）等。另外，%esp 执行栈顶，往低地址方向变化；brk/sbrk 函数控制堆顶_edata往高地址方向变化。</p>"},{"title":"高性能服务器程序框架","date":"2019-03-25T09:14:01.000Z","_content":"\n服务器主要可以分成三个模块\n\n- I/O处理单元\n- 逻辑单元\n- 存储单元\n\n<!--more-->\n\n## 服务器模型\n\n- C/S模型(客户端/服务器模型)\n\n这种模型很好理解，服务器掌控着资源，客户端每次都需要请求服务器来获取资源。\n\n这种模型很适合资源相对集中的场合，但是当访问量过大时，可能所有客户都将得到很慢的回应。\n\n![](/pic/CS模型.png)\n\n- P2P模型(点对点模型)\n\n网络中所有的主机都是对等的地位。P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享，但是当用户之间传输的请求过多时，网络的负载将加重。\n\n云计算机群是P2P模型的一个典范。\n\n![](/pic/P2P1.png)\n\n上图所示的P2P模型存在一个显著的问题，就是主机之间很难互相发现，所以实际使用的P2P模型通常带一个专门的发现服务器。发现服务器通常还提供查找服务，使得每个客户都能尽快找到自己需要的资源。\n\n![](/pic/P2P2.png)\n\n## I/O处理单元\n\n- I/O模型\n  - 阻塞I/O\n  - 非阻塞I/O\n  - I/O复用\n  - 信号驱动I/O(SIGIO)\n  - 异步I/O\n\n具体参见[Linux下的网络I/O模型]()\n\n- 两种高效的事件处理模式\n\n服务器通常要处理三类事件：I/O事件、信号、定时事件\n\n1.Reactor\n\n同步I/O模型通常用于实现Reactor模式\n\nReactor:要求主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。\n\n![](/pic/Reactor.png)\n\n使用同步I/O模型(epoll_wait)实现Reactor。\n\n- 主线程往epoll内核事件表中注册socket上的读就绪事件\n- 主线程调用epoll_wait等待socket上有数据可读\n- 当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列\n- 睡眠在请求队列上的某个工作线程被唤醒，它从socket上读取数据，并处理客户端请求，然后往epoll内核事件表中注册该socket上的写就绪事件\n- 主线程调用epoll_wait等待socket可写\n- 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列\n- 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果\n\n2.Proactor\n\n异步I/O模型通常用于实现Proactor模式，同步I/O也能模拟\n\nProactor:将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。因此这种模式更符合一般的服务器编程框架。\n\n![](/pic/Proactor.png)\n\n使用异步I/O模型(aio_read和aio_write)实现Proactor模式\n\n主线程中的epoll_wait调用仅仅用来检测监听socket上的连接请求事件，而不能检测连接socket上的读写事件。连接socket上的读写事件是通过aio_read和aio_write向内核注册的，内核通过信号向应用程序通知连接socket上的读写事件。\n\n- 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(以信号为例)\n- 主线程继续处理其他逻辑(这里体现出异步，不同于同步的阻塞)\n- 当socket上的数据被读入用户缓冲区，内核将向应用程序发送一个信号，以通知应用程序数据已经可用\n- 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序(以信号为例)\n- 主线程继续处理其他逻辑\n- 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕\n- 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket\n\n\n\n使用同步I/O模拟Proactor模式\n\n原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一\"完成事件\"。那么从工作线程的角度来看，它们直接获得了数据读写的结果，只需要对读写的结果进行逻辑处理。\n\n![](/pic/Proactor1.png)\n\n- 主线程往epoll内核事件表中注册socket上的读就绪事件\n- 主线程调用epoll_wait等待socket上有数据可读\n- 当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，知道没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列\n- 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket的写就绪事件\n- 主线程调用epoll_wait等待socket可写\n- 当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果\n\n## 逻辑单元\n\n- 两种高效的并发模式\n\n并发模式：I/O处理单元和多个逻辑单元之间协调完成任务的方法\n\n1.半同步/半异步模式\n\n首先区分一下并发模式中的同步和异步概念\n\n在I/O模式中，同步和异步的区别在于内核向应用程序通知的是什么类型的事件，换句话说I/O读写是由谁完成的\n\n在并发模式中，“同步”指的程序完全按照代码序列顺序执行，\"异步\"指的是程序的执行需要由系统事件来驱动。常见的系统事件有中断、信号等。\n\n下图描绘了并发模式下同步异步的区别：\n\n![](/pic/并发模式同步异步.png)\n\n异步线程执行效率高，实时性强，很多嵌入式程序采用的模型，但是以异步方式执行的程序相对复杂，难以调试和扩展，不适合于大量的并发。\n\n同步线程虽然效率相对较低，实时性较差，但逻辑简单。\n\n因此，像服务器这种既要求较好的实时性，又要求同时处理多个客户请求的应用程序，应该同时使用同步线程和异步线程相结合来实现，也就是半同步/半异步模式。\n\n半同步/半异步模式中，同步线程用于处理客户逻辑，相当于逻辑单元，异步线程用于处理I/O事件，相当于I/O处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。\n\n![](/pic/半同步半异步模式.png)\n\n在服务器程序中，结合考虑两种事件处理模式和几种I/O模型，那么半同步/半异步模式存在多种变体\n\n- 半同步/半反应堆模式\n\n![](/pic/半同步半反应堆.png)\n\n异步线程只有一个，由主线程充当，负责监听所有socket上的事件如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送给客户端，主线程就将该连接socket插入请求队列中。\n\n所有的工作线程都睡眠在请求队列上，当有任务到来时，它们 将通过竞争(比如申请互斥锁)来获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务。\n\n由于主线程插入请求队列的任务是就绪的连接socket，因此半同步/半反应堆模式采用的事件处理模式是Reactor模式，要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。\n\n缺点：\n\n1.主线程和工作线程共享请求队列。主线程往请求队列中添加任务或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间\n\n2.每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，请求队列中就会堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这个问题，工作线程的切换也将消耗大量的CPU时间\n\n- 半同步/半异步模式\n\n![](/pic/半同步半异步.png)\n\n主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道里有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，就把新的socket上的读写事件注册到自己的epoll内核事件表中。因此，每个工作线程都能同时处理多个客户连接。\n\n每个线程(主线程和工作线程)都维持着自己的事件循环，它们各自独立地监听不同的事件。因此，半同步/半异步模式下，每个线程都工作在异步的模式。\n\n2.领导者/追随者模式\n\n领导者/追随者：多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件\n\n在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件，而其他线程都是追随者，他们休眠在线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。\n\n该模式主要包括：句柄集、线程集、事件处理器、具体事件处理器。\n\n具体关系参见《Linux高性能服务器编程》P134\n\n- 有限状态机\n\n逻辑单元内部的一种高效编程方法。我们以一个HTTP请求的读取和分析程序来分析一下，在服务器读取HTTP请求时，如果没有利用有限状态机，就需要等读取到表示头部结束的空行才能对头部进行解析，但是用有限状态机之后可以一边接受数据一边进行分析，其效率更高。】\n\n使用有限状态机读取和分析HTTP请求，[代码实例](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/8_chapter/HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%88%86%E6%9E%90.cpp)\n\n模拟了正确的请求报文和错误的请求报文两种情况，发现其正常工作。\n\n![](/pic/HTTP请求读取和分析1.png)\n\n![](/pic/HTTP请求读取和分析2.png)\n\n在main函数中，循环调用recv函数往buf中读入用户数据，每次成功读取数据后，交给parse_content函数来分析读入的数据。parse_content函数首先要做的是调用parse_line函数来获取完整一行，对于完整的一行根据行状态的不同调用不同的处理函数。\n\n分析一下发现，这里面存在着两个有限状态机，分别是主状态机和从状态机，从状态机就是一个parse_line函数，负责从buf中解析出一个行，其初始状态为LINE_OK，原始驱动力来源于buf中新到达的数据，而当从状态机读取到了一个完整的行，就需要将这个行交给主状态机处理，主状态机中根据当前状态调用不同的函数对报文进行解析，从而实现状态转移。\n\n","source":"_posts/高性能服务器程序框架.md","raw":"---\ntitle: 高性能服务器程序框架\ndate: 2019-03-25 17:14:01\ntags:\n- 网络\n- Linux高性能服务器编程\n---\n\n服务器主要可以分成三个模块\n\n- I/O处理单元\n- 逻辑单元\n- 存储单元\n\n<!--more-->\n\n## 服务器模型\n\n- C/S模型(客户端/服务器模型)\n\n这种模型很好理解，服务器掌控着资源，客户端每次都需要请求服务器来获取资源。\n\n这种模型很适合资源相对集中的场合，但是当访问量过大时，可能所有客户都将得到很慢的回应。\n\n![](/pic/CS模型.png)\n\n- P2P模型(点对点模型)\n\n网络中所有的主机都是对等的地位。P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享，但是当用户之间传输的请求过多时，网络的负载将加重。\n\n云计算机群是P2P模型的一个典范。\n\n![](/pic/P2P1.png)\n\n上图所示的P2P模型存在一个显著的问题，就是主机之间很难互相发现，所以实际使用的P2P模型通常带一个专门的发现服务器。发现服务器通常还提供查找服务，使得每个客户都能尽快找到自己需要的资源。\n\n![](/pic/P2P2.png)\n\n## I/O处理单元\n\n- I/O模型\n  - 阻塞I/O\n  - 非阻塞I/O\n  - I/O复用\n  - 信号驱动I/O(SIGIO)\n  - 异步I/O\n\n具体参见[Linux下的网络I/O模型]()\n\n- 两种高效的事件处理模式\n\n服务器通常要处理三类事件：I/O事件、信号、定时事件\n\n1.Reactor\n\n同步I/O模型通常用于实现Reactor模式\n\nReactor:要求主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。\n\n![](/pic/Reactor.png)\n\n使用同步I/O模型(epoll_wait)实现Reactor。\n\n- 主线程往epoll内核事件表中注册socket上的读就绪事件\n- 主线程调用epoll_wait等待socket上有数据可读\n- 当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列\n- 睡眠在请求队列上的某个工作线程被唤醒，它从socket上读取数据，并处理客户端请求，然后往epoll内核事件表中注册该socket上的写就绪事件\n- 主线程调用epoll_wait等待socket可写\n- 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列\n- 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果\n\n2.Proactor\n\n异步I/O模型通常用于实现Proactor模式，同步I/O也能模拟\n\nProactor:将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。因此这种模式更符合一般的服务器编程框架。\n\n![](/pic/Proactor.png)\n\n使用异步I/O模型(aio_read和aio_write)实现Proactor模式\n\n主线程中的epoll_wait调用仅仅用来检测监听socket上的连接请求事件，而不能检测连接socket上的读写事件。连接socket上的读写事件是通过aio_read和aio_write向内核注册的，内核通过信号向应用程序通知连接socket上的读写事件。\n\n- 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(以信号为例)\n- 主线程继续处理其他逻辑(这里体现出异步，不同于同步的阻塞)\n- 当socket上的数据被读入用户缓冲区，内核将向应用程序发送一个信号，以通知应用程序数据已经可用\n- 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序(以信号为例)\n- 主线程继续处理其他逻辑\n- 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕\n- 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket\n\n\n\n使用同步I/O模拟Proactor模式\n\n原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一\"完成事件\"。那么从工作线程的角度来看，它们直接获得了数据读写的结果，只需要对读写的结果进行逻辑处理。\n\n![](/pic/Proactor1.png)\n\n- 主线程往epoll内核事件表中注册socket上的读就绪事件\n- 主线程调用epoll_wait等待socket上有数据可读\n- 当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，知道没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列\n- 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket的写就绪事件\n- 主线程调用epoll_wait等待socket可写\n- 当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果\n\n## 逻辑单元\n\n- 两种高效的并发模式\n\n并发模式：I/O处理单元和多个逻辑单元之间协调完成任务的方法\n\n1.半同步/半异步模式\n\n首先区分一下并发模式中的同步和异步概念\n\n在I/O模式中，同步和异步的区别在于内核向应用程序通知的是什么类型的事件，换句话说I/O读写是由谁完成的\n\n在并发模式中，“同步”指的程序完全按照代码序列顺序执行，\"异步\"指的是程序的执行需要由系统事件来驱动。常见的系统事件有中断、信号等。\n\n下图描绘了并发模式下同步异步的区别：\n\n![](/pic/并发模式同步异步.png)\n\n异步线程执行效率高，实时性强，很多嵌入式程序采用的模型，但是以异步方式执行的程序相对复杂，难以调试和扩展，不适合于大量的并发。\n\n同步线程虽然效率相对较低，实时性较差，但逻辑简单。\n\n因此，像服务器这种既要求较好的实时性，又要求同时处理多个客户请求的应用程序，应该同时使用同步线程和异步线程相结合来实现，也就是半同步/半异步模式。\n\n半同步/半异步模式中，同步线程用于处理客户逻辑，相当于逻辑单元，异步线程用于处理I/O事件，相当于I/O处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。\n\n![](/pic/半同步半异步模式.png)\n\n在服务器程序中，结合考虑两种事件处理模式和几种I/O模型，那么半同步/半异步模式存在多种变体\n\n- 半同步/半反应堆模式\n\n![](/pic/半同步半反应堆.png)\n\n异步线程只有一个，由主线程充当，负责监听所有socket上的事件如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送给客户端，主线程就将该连接socket插入请求队列中。\n\n所有的工作线程都睡眠在请求队列上，当有任务到来时，它们 将通过竞争(比如申请互斥锁)来获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务。\n\n由于主线程插入请求队列的任务是就绪的连接socket，因此半同步/半反应堆模式采用的事件处理模式是Reactor模式，要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。\n\n缺点：\n\n1.主线程和工作线程共享请求队列。主线程往请求队列中添加任务或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间\n\n2.每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，请求队列中就会堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这个问题，工作线程的切换也将消耗大量的CPU时间\n\n- 半同步/半异步模式\n\n![](/pic/半同步半异步.png)\n\n主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道里有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，就把新的socket上的读写事件注册到自己的epoll内核事件表中。因此，每个工作线程都能同时处理多个客户连接。\n\n每个线程(主线程和工作线程)都维持着自己的事件循环，它们各自独立地监听不同的事件。因此，半同步/半异步模式下，每个线程都工作在异步的模式。\n\n2.领导者/追随者模式\n\n领导者/追随者：多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件\n\n在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件，而其他线程都是追随者，他们休眠在线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。\n\n该模式主要包括：句柄集、线程集、事件处理器、具体事件处理器。\n\n具体关系参见《Linux高性能服务器编程》P134\n\n- 有限状态机\n\n逻辑单元内部的一种高效编程方法。我们以一个HTTP请求的读取和分析程序来分析一下，在服务器读取HTTP请求时，如果没有利用有限状态机，就需要等读取到表示头部结束的空行才能对头部进行解析，但是用有限状态机之后可以一边接受数据一边进行分析，其效率更高。】\n\n使用有限状态机读取和分析HTTP请求，[代码实例](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/8_chapter/HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%88%86%E6%9E%90.cpp)\n\n模拟了正确的请求报文和错误的请求报文两种情况，发现其正常工作。\n\n![](/pic/HTTP请求读取和分析1.png)\n\n![](/pic/HTTP请求读取和分析2.png)\n\n在main函数中，循环调用recv函数往buf中读入用户数据，每次成功读取数据后，交给parse_content函数来分析读入的数据。parse_content函数首先要做的是调用parse_line函数来获取完整一行，对于完整的一行根据行状态的不同调用不同的处理函数。\n\n分析一下发现，这里面存在着两个有限状态机，分别是主状态机和从状态机，从状态机就是一个parse_line函数，负责从buf中解析出一个行，其初始状态为LINE_OK，原始驱动力来源于buf中新到达的数据，而当从状态机读取到了一个完整的行，就需要将这个行交给主状态机处理，主状态机中根据当前状态调用不同的函数对报文进行解析，从而实现状态转移。\n\n","slug":"高性能服务器程序框架","published":1,"updated":"2021-12-06T05:30:36.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip81002u96ca2gpj0hkk","content":"<p>服务器主要可以分成三个模块</p>\n<ul>\n<li>I/O处理单元</li>\n<li>逻辑单元</li>\n<li>存储单元</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"服务器模型\"><a href=\"#服务器模型\" class=\"headerlink\" title=\"服务器模型\"></a>服务器模型</h2><ul>\n<li>C/S模型(客户端/服务器模型)</li>\n</ul>\n<p>这种模型很好理解，服务器掌控着资源，客户端每次都需要请求服务器来获取资源。</p>\n<p>这种模型很适合资源相对集中的场合，但是当访问量过大时，可能所有客户都将得到很慢的回应。</p>\n<p><img src=\"/pic/CS%E6%A8%A1%E5%9E%8B.png\" alt=\"\"></p>\n<ul>\n<li>P2P模型(点对点模型)</li>\n</ul>\n<p>网络中所有的主机都是对等的地位。P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享，但是当用户之间传输的请求过多时，网络的负载将加重。</p>\n<p>云计算机群是P2P模型的一个典范。</p>\n<p><img src=\"/pic/P2P1.png\" alt=\"\"></p>\n<p>上图所示的P2P模型存在一个显著的问题，就是主机之间很难互相发现，所以实际使用的P2P模型通常带一个专门的发现服务器。发现服务器通常还提供查找服务，使得每个客户都能尽快找到自己需要的资源。</p>\n<p><img src=\"/pic/P2P2.png\" alt=\"\"></p>\n<h2 id=\"I-O处理单元\"><a href=\"#I-O处理单元\" class=\"headerlink\" title=\"I/O处理单元\"></a>I/O处理单元</h2><ul>\n<li>I/O模型<ul>\n<li>阻塞I/O</li>\n<li>非阻塞I/O</li>\n<li>I/O复用</li>\n<li>信号驱动I/O(SIGIO)</li>\n<li>异步I/O</li>\n</ul>\n</li>\n</ul>\n<p>具体参见<a href=\"\">Linux下的网络I/O模型</a></p>\n<ul>\n<li>两种高效的事件处理模式</li>\n</ul>\n<p>服务器通常要处理三类事件：I/O事件、信号、定时事件</p>\n<p>1.Reactor</p>\n<p>同步I/O模型通常用于实现Reactor模式</p>\n<p>Reactor:要求主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p>\n<p><img src=\"/pic/Reactor.png\" alt=\"\"></p>\n<p>使用同步I/O模型(epoll_wait)实现Reactor。</p>\n<ul>\n<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>\n<li>主线程调用epoll_wait等待socket上有数据可读</li>\n<li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket上读取数据，并处理客户端请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>\n<li>主线程调用epoll_wait等待socket可写</li>\n<li>当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果</li>\n</ul>\n<p>2.Proactor</p>\n<p>异步I/O模型通常用于实现Proactor模式，同步I/O也能模拟</p>\n<p>Proactor:将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。因此这种模式更符合一般的服务器编程框架。</p>\n<p><img src=\"/pic/Proactor.png\" alt=\"\"></p>\n<p>使用异步I/O模型(aio_read和aio_write)实现Proactor模式</p>\n<p>主线程中的epoll_wait调用仅仅用来检测监听socket上的连接请求事件，而不能检测连接socket上的读写事件。连接socket上的读写事件是通过aio_read和aio_write向内核注册的，内核通过信号向应用程序通知连接socket上的读写事件。</p>\n<ul>\n<li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(以信号为例)</li>\n<li>主线程继续处理其他逻辑(这里体现出异步，不同于同步的阻塞)</li>\n<li>当socket上的数据被读入用户缓冲区，内核将向应用程序发送一个信号，以通知应用程序数据已经可用</li>\n<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序(以信号为例)</li>\n<li>主线程继续处理其他逻辑</li>\n<li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕</li>\n<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket</li>\n</ul>\n<p>使用同步I/O模拟Proactor模式</p>\n<p>原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件”。那么从工作线程的角度来看，它们直接获得了数据读写的结果，只需要对读写的结果进行逻辑处理。</p>\n<p><img src=\"/pic/Proactor1.png\" alt=\"\"></p>\n<ul>\n<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>\n<li>主线程调用epoll_wait等待socket上有数据可读</li>\n<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，知道没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket的写就绪事件</li>\n<li>主线程调用epoll_wait等待socket可写</li>\n<li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果</li>\n</ul>\n<h2 id=\"逻辑单元\"><a href=\"#逻辑单元\" class=\"headerlink\" title=\"逻辑单元\"></a>逻辑单元</h2><ul>\n<li>两种高效的并发模式</li>\n</ul>\n<p>并发模式：I/O处理单元和多个逻辑单元之间协调完成任务的方法</p>\n<p>1.半同步/半异步模式</p>\n<p>首先区分一下并发模式中的同步和异步概念</p>\n<p>在I/O模式中，同步和异步的区别在于内核向应用程序通知的是什么类型的事件，换句话说I/O读写是由谁完成的</p>\n<p>在并发模式中，“同步”指的程序完全按照代码序列顺序执行，”异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件有中断、信号等。</p>\n<p>下图描绘了并发模式下同步异步的区别：</p>\n<p><img src=\"/pic/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5.png\" alt=\"\"></p>\n<p>异步线程执行效率高，实时性强，很多嵌入式程序采用的模型，但是以异步方式执行的程序相对复杂，难以调试和扩展，不适合于大量的并发。</p>\n<p>同步线程虽然效率相对较低，实时性较差，但逻辑简单。</p>\n<p>因此，像服务器这种既要求较好的实时性，又要求同时处理多个客户请求的应用程序，应该同时使用同步线程和异步线程相结合来实现，也就是半同步/半异步模式。</p>\n<p>半同步/半异步模式中，同步线程用于处理客户逻辑，相当于逻辑单元，异步线程用于处理I/O事件，相当于I/O处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。</p>\n<p><img src=\"/pic/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>在服务器程序中，结合考虑两种事件处理模式和几种I/O模型，那么半同步/半异步模式存在多种变体</p>\n<ul>\n<li>半同步/半反应堆模式</li>\n</ul>\n<p><img src=\"/pic/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86.png\" alt=\"\"></p>\n<p>异步线程只有一个，由主线程充当，负责监听所有socket上的事件如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送给客户端，主线程就将该连接socket插入请求队列中。</p>\n<p>所有的工作线程都睡眠在请求队列上，当有任务到来时，它们 将通过竞争(比如申请互斥锁)来获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务。</p>\n<p>由于主线程插入请求队列的任务是就绪的连接socket，因此半同步/半反应堆模式采用的事件处理模式是Reactor模式，要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。</p>\n<p>缺点：</p>\n<p>1.主线程和工作线程共享请求队列。主线程往请求队列中添加任务或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间</p>\n<p>2.每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，请求队列中就会堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这个问题，工作线程的切换也将消耗大量的CPU时间</p>\n<ul>\n<li>半同步/半异步模式</li>\n</ul>\n<p><img src=\"/pic/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5.png\" alt=\"\"></p>\n<p>主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道里有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，就把新的socket上的读写事件注册到自己的epoll内核事件表中。因此，每个工作线程都能同时处理多个客户连接。</p>\n<p>每个线程(主线程和工作线程)都维持着自己的事件循环，它们各自独立地监听不同的事件。因此，半同步/半异步模式下，每个线程都工作在异步的模式。</p>\n<p>2.领导者/追随者模式</p>\n<p>领导者/追随者：多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件</p>\n<p>在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件，而其他线程都是追随者，他们休眠在线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。</p>\n<p>该模式主要包括：句柄集、线程集、事件处理器、具体事件处理器。</p>\n<p>具体关系参见《Linux高性能服务器编程》P134</p>\n<ul>\n<li>有限状态机</li>\n</ul>\n<p>逻辑单元内部的一种高效编程方法。我们以一个HTTP请求的读取和分析程序来分析一下，在服务器读取HTTP请求时，如果没有利用有限状态机，就需要等读取到表示头部结束的空行才能对头部进行解析，但是用有限状态机之后可以一边接受数据一边进行分析，其效率更高。】</p>\n<p>使用有限状态机读取和分析HTTP请求，<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/8_chapter/HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%88%86%E6%9E%90.cpp\" target=\"_blank\" rel=\"noopener\">代码实例</a></p>\n<p>模拟了正确的请求报文和错误的请求报文两种情况，发现其正常工作。</p>\n<p><img src=\"/pic/HTTP%E8%AF%B7%E6%B1%82%E8%AF%BB%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%901.png\" alt=\"\"></p>\n<p><img src=\"/pic/HTTP%E8%AF%B7%E6%B1%82%E8%AF%BB%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%902.png\" alt=\"\"></p>\n<p>在main函数中，循环调用recv函数往buf中读入用户数据，每次成功读取数据后，交给parse_content函数来分析读入的数据。parse_content函数首先要做的是调用parse_line函数来获取完整一行，对于完整的一行根据行状态的不同调用不同的处理函数。</p>\n<p>分析一下发现，这里面存在着两个有限状态机，分别是主状态机和从状态机，从状态机就是一个parse_line函数，负责从buf中解析出一个行，其初始状态为LINE_OK，原始驱动力来源于buf中新到达的数据，而当从状态机读取到了一个完整的行，就需要将这个行交给主状态机处理，主状态机中根据当前状态调用不同的函数对报文进行解析，从而实现状态转移。</p>\n","site":{"data":{}},"excerpt":"<p>服务器主要可以分成三个模块</p>\n<ul>\n<li>I/O处理单元</li>\n<li>逻辑单元</li>\n<li>存储单元</li>\n</ul>","more":"<h2 id=\"服务器模型\"><a href=\"#服务器模型\" class=\"headerlink\" title=\"服务器模型\"></a>服务器模型</h2><ul>\n<li>C/S模型(客户端/服务器模型)</li>\n</ul>\n<p>这种模型很好理解，服务器掌控着资源，客户端每次都需要请求服务器来获取资源。</p>\n<p>这种模型很适合资源相对集中的场合，但是当访问量过大时，可能所有客户都将得到很慢的回应。</p>\n<p><img src=\"/pic/CS%E6%A8%A1%E5%9E%8B.png\" alt=\"\"></p>\n<ul>\n<li>P2P模型(点对点模型)</li>\n</ul>\n<p>网络中所有的主机都是对等的地位。P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享，但是当用户之间传输的请求过多时，网络的负载将加重。</p>\n<p>云计算机群是P2P模型的一个典范。</p>\n<p><img src=\"/pic/P2P1.png\" alt=\"\"></p>\n<p>上图所示的P2P模型存在一个显著的问题，就是主机之间很难互相发现，所以实际使用的P2P模型通常带一个专门的发现服务器。发现服务器通常还提供查找服务，使得每个客户都能尽快找到自己需要的资源。</p>\n<p><img src=\"/pic/P2P2.png\" alt=\"\"></p>\n<h2 id=\"I-O处理单元\"><a href=\"#I-O处理单元\" class=\"headerlink\" title=\"I/O处理单元\"></a>I/O处理单元</h2><ul>\n<li>I/O模型<ul>\n<li>阻塞I/O</li>\n<li>非阻塞I/O</li>\n<li>I/O复用</li>\n<li>信号驱动I/O(SIGIO)</li>\n<li>异步I/O</li>\n</ul>\n</li>\n</ul>\n<p>具体参见<a href=\"\">Linux下的网络I/O模型</a></p>\n<ul>\n<li>两种高效的事件处理模式</li>\n</ul>\n<p>服务器通常要处理三类事件：I/O事件、信号、定时事件</p>\n<p>1.Reactor</p>\n<p>同步I/O模型通常用于实现Reactor模式</p>\n<p>Reactor:要求主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p>\n<p><img src=\"/pic/Reactor.png\" alt=\"\"></p>\n<p>使用同步I/O模型(epoll_wait)实现Reactor。</p>\n<ul>\n<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>\n<li>主线程调用epoll_wait等待socket上有数据可读</li>\n<li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket上读取数据，并处理客户端请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>\n<li>主线程调用epoll_wait等待socket可写</li>\n<li>当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果</li>\n</ul>\n<p>2.Proactor</p>\n<p>异步I/O模型通常用于实现Proactor模式，同步I/O也能模拟</p>\n<p>Proactor:将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。因此这种模式更符合一般的服务器编程框架。</p>\n<p><img src=\"/pic/Proactor.png\" alt=\"\"></p>\n<p>使用异步I/O模型(aio_read和aio_write)实现Proactor模式</p>\n<p>主线程中的epoll_wait调用仅仅用来检测监听socket上的连接请求事件，而不能检测连接socket上的读写事件。连接socket上的读写事件是通过aio_read和aio_write向内核注册的，内核通过信号向应用程序通知连接socket上的读写事件。</p>\n<ul>\n<li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(以信号为例)</li>\n<li>主线程继续处理其他逻辑(这里体现出异步，不同于同步的阻塞)</li>\n<li>当socket上的数据被读入用户缓冲区，内核将向应用程序发送一个信号，以通知应用程序数据已经可用</li>\n<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序(以信号为例)</li>\n<li>主线程继续处理其他逻辑</li>\n<li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕</li>\n<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket</li>\n</ul>\n<p>使用同步I/O模拟Proactor模式</p>\n<p>原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件”。那么从工作线程的角度来看，它们直接获得了数据读写的结果，只需要对读写的结果进行逻辑处理。</p>\n<p><img src=\"/pic/Proactor1.png\" alt=\"\"></p>\n<ul>\n<li>主线程往epoll内核事件表中注册socket上的读就绪事件</li>\n<li>主线程调用epoll_wait等待socket上有数据可读</li>\n<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，知道没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket的写就绪事件</li>\n<li>主线程调用epoll_wait等待socket可写</li>\n<li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果</li>\n</ul>\n<h2 id=\"逻辑单元\"><a href=\"#逻辑单元\" class=\"headerlink\" title=\"逻辑单元\"></a>逻辑单元</h2><ul>\n<li>两种高效的并发模式</li>\n</ul>\n<p>并发模式：I/O处理单元和多个逻辑单元之间协调完成任务的方法</p>\n<p>1.半同步/半异步模式</p>\n<p>首先区分一下并发模式中的同步和异步概念</p>\n<p>在I/O模式中，同步和异步的区别在于内核向应用程序通知的是什么类型的事件，换句话说I/O读写是由谁完成的</p>\n<p>在并发模式中，“同步”指的程序完全按照代码序列顺序执行，”异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件有中断、信号等。</p>\n<p>下图描绘了并发模式下同步异步的区别：</p>\n<p><img src=\"/pic/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5.png\" alt=\"\"></p>\n<p>异步线程执行效率高，实时性强，很多嵌入式程序采用的模型，但是以异步方式执行的程序相对复杂，难以调试和扩展，不适合于大量的并发。</p>\n<p>同步线程虽然效率相对较低，实时性较差，但逻辑简单。</p>\n<p>因此，像服务器这种既要求较好的实时性，又要求同时处理多个客户请求的应用程序，应该同时使用同步线程和异步线程相结合来实现，也就是半同步/半异步模式。</p>\n<p>半同步/半异步模式中，同步线程用于处理客户逻辑，相当于逻辑单元，异步线程用于处理I/O事件，相当于I/O处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。</p>\n<p><img src=\"/pic/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>在服务器程序中，结合考虑两种事件处理模式和几种I/O模型，那么半同步/半异步模式存在多种变体</p>\n<ul>\n<li>半同步/半反应堆模式</li>\n</ul>\n<p><img src=\"/pic/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86.png\" alt=\"\"></p>\n<p>异步线程只有一个，由主线程充当，负责监听所有socket上的事件如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送给客户端，主线程就将该连接socket插入请求队列中。</p>\n<p>所有的工作线程都睡眠在请求队列上，当有任务到来时，它们 将通过竞争(比如申请互斥锁)来获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务。</p>\n<p>由于主线程插入请求队列的任务是就绪的连接socket，因此半同步/半反应堆模式采用的事件处理模式是Reactor模式，要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。</p>\n<p>缺点：</p>\n<p>1.主线程和工作线程共享请求队列。主线程往请求队列中添加任务或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间</p>\n<p>2.每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，请求队列中就会堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这个问题，工作线程的切换也将消耗大量的CPU时间</p>\n<ul>\n<li>半同步/半异步模式</li>\n</ul>\n<p><img src=\"/pic/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5.png\" alt=\"\"></p>\n<p>主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道里有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，就把新的socket上的读写事件注册到自己的epoll内核事件表中。因此，每个工作线程都能同时处理多个客户连接。</p>\n<p>每个线程(主线程和工作线程)都维持着自己的事件循环，它们各自独立地监听不同的事件。因此，半同步/半异步模式下，每个线程都工作在异步的模式。</p>\n<p>2.领导者/追随者模式</p>\n<p>领导者/追随者：多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件</p>\n<p>在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件，而其他线程都是追随者，他们休眠在线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。</p>\n<p>该模式主要包括：句柄集、线程集、事件处理器、具体事件处理器。</p>\n<p>具体关系参见《Linux高性能服务器编程》P134</p>\n<ul>\n<li>有限状态机</li>\n</ul>\n<p>逻辑单元内部的一种高效编程方法。我们以一个HTTP请求的读取和分析程序来分析一下，在服务器读取HTTP请求时，如果没有利用有限状态机，就需要等读取到表示头部结束的空行才能对头部进行解析，但是用有限状态机之后可以一边接受数据一边进行分析，其效率更高。】</p>\n<p>使用有限状态机读取和分析HTTP请求，<a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/8_chapter/HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%88%86%E6%9E%90.cpp\" target=\"_blank\" rel=\"noopener\">代码实例</a></p>\n<p>模拟了正确的请求报文和错误的请求报文两种情况，发现其正常工作。</p>\n<p><img src=\"/pic/HTTP%E8%AF%B7%E6%B1%82%E8%AF%BB%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%901.png\" alt=\"\"></p>\n<p><img src=\"/pic/HTTP%E8%AF%B7%E6%B1%82%E8%AF%BB%E5%8F%96%E5%92%8C%E5%88%86%E6%9E%902.png\" alt=\"\"></p>\n<p>在main函数中，循环调用recv函数往buf中读入用户数据，每次成功读取数据后，交给parse_content函数来分析读入的数据。parse_content函数首先要做的是调用parse_line函数来获取完整一行，对于完整的一行根据行状态的不同调用不同的处理函数。</p>\n<p>分析一下发现，这里面存在着两个有限状态机，分别是主状态机和从状态机，从状态机就是一个parse_line函数，负责从buf中解析出一个行，其初始状态为LINE_OK，原始驱动力来源于buf中新到达的数据，而当从状态机读取到了一个完整的行，就需要将这个行交给主状态机处理，主状态机中根据当前状态调用不同的函数对报文进行解析，从而实现状态转移。</p>"},{"title":"进程池","date":"2019-04-17T09:50:41.000Z","_content":"\n## 为什么需要池？\n\n多进程的网络模型为主进程负责accept，每来一个客户端就fork出一个子进程为之服务。这种动态创建子进程(子线程)来实现并发服务器有着诸多缺点。\n\n- 动态创建进程(或线程)比较耗费时间，会导致较慢的客户响应\n- 动态创建的子进程(或子线程)通常只用来为一个客户服务(除非做特殊的处理)，这将导致系统上产生大量的细微进程(线程)。进程(线程)切换将消耗大量CPU时间\n- 动态创建的子进程是当前进程的完整映像。当前进程必须谨慎管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使得系统的可用资源急剧下降，影响服务器的性能。\n\n进程池是由服务器预先创建一组子进程。进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、pgid等。因为进程池在服务器启动之前就创建好了，所以每个子进程相对干净，即它们没有打开不必要的文件描述符，也不会错误地使用大块的堆内存。\n\n当有新的任务来的时候，主进程将通过某种方式选择进程池中某一个子进程来为之服务。\n\n- 主进程使用某种算法来主动选择子进程。随机算法和Round Robin(轮流选取)算法。但更优秀、更智能的算法应该考虑负载的均衡\n- 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。\n\n选择好子进程之后，主进程还需要使用某种通知机制告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是通过管道。\n\n<!--more-->\n\n![](/pic/进程池模型.png)\n\n[半同步/半异步进程池实现](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/15_chapter/CGI_server.cpp)\n\n半同步/半异步模型是主进程负责管理所有监听socket，而各个子进程分别管理属于自己的连接socket。\n\n代码主要逻辑分析：\n\nmain函数负责进行网络的一些初始化工作，已经创建进程池，需要注意的是在创建进程池之前需要创建好监听socket，一旦进程池创建成功，调用run函数就使得父进程(程序一执行就存在，只不过发生了代码逻辑的跳转)和八个子进程同时启动，开始监听事件。\n\nrun函数区分父进程和子进程用了一个小技巧，通过循环创建进程时子进程继承过来的索引进行区分。父进程一开始初始化为-1，子进程都大于等于0。\n\n父进程：负责监听listenfd和信号管道的fd[0]端。信号管道用于统一事件源。\n\n- 父进程一旦监听到有新的连接到来时，通过Round Robin选择一个子进程(简单地通过m_pid是否为-1来选取)，然后就通过父子进程之间已经建立好的管道将这个事件通知给子进程。\n- 父进程还会监听到信号管道发来的信号事件，根据不同的信号进行相应的处理。比较需要注意的子进程的回收，还要关闭相应的管道\n\n子进程：负责监听父子进程通信的管道的fd[1]端，信号管道的fd[0]端和通过该子进程建立连接的confd。维护该子进程连接着的所有用户请求对象的一个数组。\n\n- 子进程一旦监听到父进程通过管道给自己发送数据，就代表有的客户连接需要接收。调用accept接收用户连接，然后进行用户请求类的初始化\n- 子进程监听到信号管道发来的信号事件，根据相应的信号进行对应的处理\n- 子进程监听到已经建立连接的用户有数据请求，就调用用户请求对象的process方法\n\n还有一个很关键的类，就是用来处理客户CGI请求的类，需要实现init方法和process方法，process方法就完成了CGI请求(创建一个子进程，用来执行CGI程序，并且将标准输出重定向到网络socket)\n\n小技巧：子进程中需要的变量都从父进程继承了过来，并根据需要进行相应的修改也不会相互影响\n\n扩展性：该进程池具有一定的扩展性，本次实例中process用来实现的CGI请求，但是可以根据不同的场景需要进行修改，但不会修改进程池内部源码。","source":"_posts/进程池.md","raw":"---\ntitle: 进程池\ndate: 2019-04-17 17:50:41\ntags:\n- Linux高性能服务器编程\n- 进程\n---\n\n## 为什么需要池？\n\n多进程的网络模型为主进程负责accept，每来一个客户端就fork出一个子进程为之服务。这种动态创建子进程(子线程)来实现并发服务器有着诸多缺点。\n\n- 动态创建进程(或线程)比较耗费时间，会导致较慢的客户响应\n- 动态创建的子进程(或子线程)通常只用来为一个客户服务(除非做特殊的处理)，这将导致系统上产生大量的细微进程(线程)。进程(线程)切换将消耗大量CPU时间\n- 动态创建的子进程是当前进程的完整映像。当前进程必须谨慎管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使得系统的可用资源急剧下降，影响服务器的性能。\n\n进程池是由服务器预先创建一组子进程。进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、pgid等。因为进程池在服务器启动之前就创建好了，所以每个子进程相对干净，即它们没有打开不必要的文件描述符，也不会错误地使用大块的堆内存。\n\n当有新的任务来的时候，主进程将通过某种方式选择进程池中某一个子进程来为之服务。\n\n- 主进程使用某种算法来主动选择子进程。随机算法和Round Robin(轮流选取)算法。但更优秀、更智能的算法应该考虑负载的均衡\n- 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。\n\n选择好子进程之后，主进程还需要使用某种通知机制告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是通过管道。\n\n<!--more-->\n\n![](/pic/进程池模型.png)\n\n[半同步/半异步进程池实现](https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/15_chapter/CGI_server.cpp)\n\n半同步/半异步模型是主进程负责管理所有监听socket，而各个子进程分别管理属于自己的连接socket。\n\n代码主要逻辑分析：\n\nmain函数负责进行网络的一些初始化工作，已经创建进程池，需要注意的是在创建进程池之前需要创建好监听socket，一旦进程池创建成功，调用run函数就使得父进程(程序一执行就存在，只不过发生了代码逻辑的跳转)和八个子进程同时启动，开始监听事件。\n\nrun函数区分父进程和子进程用了一个小技巧，通过循环创建进程时子进程继承过来的索引进行区分。父进程一开始初始化为-1，子进程都大于等于0。\n\n父进程：负责监听listenfd和信号管道的fd[0]端。信号管道用于统一事件源。\n\n- 父进程一旦监听到有新的连接到来时，通过Round Robin选择一个子进程(简单地通过m_pid是否为-1来选取)，然后就通过父子进程之间已经建立好的管道将这个事件通知给子进程。\n- 父进程还会监听到信号管道发来的信号事件，根据不同的信号进行相应的处理。比较需要注意的子进程的回收，还要关闭相应的管道\n\n子进程：负责监听父子进程通信的管道的fd[1]端，信号管道的fd[0]端和通过该子进程建立连接的confd。维护该子进程连接着的所有用户请求对象的一个数组。\n\n- 子进程一旦监听到父进程通过管道给自己发送数据，就代表有的客户连接需要接收。调用accept接收用户连接，然后进行用户请求类的初始化\n- 子进程监听到信号管道发来的信号事件，根据相应的信号进行对应的处理\n- 子进程监听到已经建立连接的用户有数据请求，就调用用户请求对象的process方法\n\n还有一个很关键的类，就是用来处理客户CGI请求的类，需要实现init方法和process方法，process方法就完成了CGI请求(创建一个子进程，用来执行CGI程序，并且将标准输出重定向到网络socket)\n\n小技巧：子进程中需要的变量都从父进程继承了过来，并根据需要进行相应的修改也不会相互影响\n\n扩展性：该进程池具有一定的扩展性，本次实例中process用来实现的CGI请求，但是可以根据不同的场景需要进行修改，但不会修改进程池内部源码。","slug":"进程池","published":1,"updated":"2021-12-06T05:30:36.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip81002x96ca5b8i7n10","content":"<h2 id=\"为什么需要池？\"><a href=\"#为什么需要池？\" class=\"headerlink\" title=\"为什么需要池？\"></a>为什么需要池？</h2><p>多进程的网络模型为主进程负责accept，每来一个客户端就fork出一个子进程为之服务。这种动态创建子进程(子线程)来实现并发服务器有着诸多缺点。</p>\n<ul>\n<li>动态创建进程(或线程)比较耗费时间，会导致较慢的客户响应</li>\n<li>动态创建的子进程(或子线程)通常只用来为一个客户服务(除非做特殊的处理)，这将导致系统上产生大量的细微进程(线程)。进程(线程)切换将消耗大量CPU时间</li>\n<li>动态创建的子进程是当前进程的完整映像。当前进程必须谨慎管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使得系统的可用资源急剧下降，影响服务器的性能。</li>\n</ul>\n<p>进程池是由服务器预先创建一组子进程。进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、pgid等。因为进程池在服务器启动之前就创建好了，所以每个子进程相对干净，即它们没有打开不必要的文件描述符，也不会错误地使用大块的堆内存。</p>\n<p>当有新的任务来的时候，主进程将通过某种方式选择进程池中某一个子进程来为之服务。</p>\n<ul>\n<li>主进程使用某种算法来主动选择子进程。随机算法和Round Robin(轮流选取)算法。但更优秀、更智能的算法应该考虑负载的均衡</li>\n<li>主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。</li>\n</ul>\n<p>选择好子进程之后，主进程还需要使用某种通知机制告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是通过管道。</p>\n<a id=\"more\"></a>\n\n<p><img src=\"/pic/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9E%8B.png\" alt=\"\"></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/15_chapter/CGI_server.cpp\" target=\"_blank\" rel=\"noopener\">半同步/半异步进程池实现</a></p>\n<p>半同步/半异步模型是主进程负责管理所有监听socket，而各个子进程分别管理属于自己的连接socket。</p>\n<p>代码主要逻辑分析：</p>\n<p>main函数负责进行网络的一些初始化工作，已经创建进程池，需要注意的是在创建进程池之前需要创建好监听socket，一旦进程池创建成功，调用run函数就使得父进程(程序一执行就存在，只不过发生了代码逻辑的跳转)和八个子进程同时启动，开始监听事件。</p>\n<p>run函数区分父进程和子进程用了一个小技巧，通过循环创建进程时子进程继承过来的索引进行区分。父进程一开始初始化为-1，子进程都大于等于0。</p>\n<p>父进程：负责监听listenfd和信号管道的fd[0]端。信号管道用于统一事件源。</p>\n<ul>\n<li>父进程一旦监听到有新的连接到来时，通过Round Robin选择一个子进程(简单地通过m_pid是否为-1来选取)，然后就通过父子进程之间已经建立好的管道将这个事件通知给子进程。</li>\n<li>父进程还会监听到信号管道发来的信号事件，根据不同的信号进行相应的处理。比较需要注意的子进程的回收，还要关闭相应的管道</li>\n</ul>\n<p>子进程：负责监听父子进程通信的管道的fd[1]端，信号管道的fd[0]端和通过该子进程建立连接的confd。维护该子进程连接着的所有用户请求对象的一个数组。</p>\n<ul>\n<li>子进程一旦监听到父进程通过管道给自己发送数据，就代表有的客户连接需要接收。调用accept接收用户连接，然后进行用户请求类的初始化</li>\n<li>子进程监听到信号管道发来的信号事件，根据相应的信号进行对应的处理</li>\n<li>子进程监听到已经建立连接的用户有数据请求，就调用用户请求对象的process方法</li>\n</ul>\n<p>还有一个很关键的类，就是用来处理客户CGI请求的类，需要实现init方法和process方法，process方法就完成了CGI请求(创建一个子进程，用来执行CGI程序，并且将标准输出重定向到网络socket)</p>\n<p>小技巧：子进程中需要的变量都从父进程继承了过来，并根据需要进行相应的修改也不会相互影响</p>\n<p>扩展性：该进程池具有一定的扩展性，本次实例中process用来实现的CGI请求，但是可以根据不同的场景需要进行修改，但不会修改进程池内部源码。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"为什么需要池？\"><a href=\"#为什么需要池？\" class=\"headerlink\" title=\"为什么需要池？\"></a>为什么需要池？</h2><p>多进程的网络模型为主进程负责accept，每来一个客户端就fork出一个子进程为之服务。这种动态创建子进程(子线程)来实现并发服务器有着诸多缺点。</p>\n<ul>\n<li>动态创建进程(或线程)比较耗费时间，会导致较慢的客户响应</li>\n<li>动态创建的子进程(或子线程)通常只用来为一个客户服务(除非做特殊的处理)，这将导致系统上产生大量的细微进程(线程)。进程(线程)切换将消耗大量CPU时间</li>\n<li>动态创建的子进程是当前进程的完整映像。当前进程必须谨慎管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使得系统的可用资源急剧下降，影响服务器的性能。</li>\n</ul>\n<p>进程池是由服务器预先创建一组子进程。进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、pgid等。因为进程池在服务器启动之前就创建好了，所以每个子进程相对干净，即它们没有打开不必要的文件描述符，也不会错误地使用大块的堆内存。</p>\n<p>当有新的任务来的时候，主进程将通过某种方式选择进程池中某一个子进程来为之服务。</p>\n<ul>\n<li>主进程使用某种算法来主动选择子进程。随机算法和Round Robin(轮流选取)算法。但更优秀、更智能的算法应该考虑负载的均衡</li>\n<li>主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。</li>\n</ul>\n<p>选择好子进程之后，主进程还需要使用某种通知机制告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是通过管道。</p>","more":"<p><img src=\"/pic/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9E%8B.png\" alt=\"\"></p>\n<p><a href=\"https://github.com/oldbuffalo/High-performance-Linux-Server-Programming/blob/master/15_chapter/CGI_server.cpp\" target=\"_blank\" rel=\"noopener\">半同步/半异步进程池实现</a></p>\n<p>半同步/半异步模型是主进程负责管理所有监听socket，而各个子进程分别管理属于自己的连接socket。</p>\n<p>代码主要逻辑分析：</p>\n<p>main函数负责进行网络的一些初始化工作，已经创建进程池，需要注意的是在创建进程池之前需要创建好监听socket，一旦进程池创建成功，调用run函数就使得父进程(程序一执行就存在，只不过发生了代码逻辑的跳转)和八个子进程同时启动，开始监听事件。</p>\n<p>run函数区分父进程和子进程用了一个小技巧，通过循环创建进程时子进程继承过来的索引进行区分。父进程一开始初始化为-1，子进程都大于等于0。</p>\n<p>父进程：负责监听listenfd和信号管道的fd[0]端。信号管道用于统一事件源。</p>\n<ul>\n<li>父进程一旦监听到有新的连接到来时，通过Round Robin选择一个子进程(简单地通过m_pid是否为-1来选取)，然后就通过父子进程之间已经建立好的管道将这个事件通知给子进程。</li>\n<li>父进程还会监听到信号管道发来的信号事件，根据不同的信号进行相应的处理。比较需要注意的子进程的回收，还要关闭相应的管道</li>\n</ul>\n<p>子进程：负责监听父子进程通信的管道的fd[1]端，信号管道的fd[0]端和通过该子进程建立连接的confd。维护该子进程连接着的所有用户请求对象的一个数组。</p>\n<ul>\n<li>子进程一旦监听到父进程通过管道给自己发送数据，就代表有的客户连接需要接收。调用accept接收用户连接，然后进行用户请求类的初始化</li>\n<li>子进程监听到信号管道发来的信号事件，根据相应的信号进行对应的处理</li>\n<li>子进程监听到已经建立连接的用户有数据请求，就调用用户请求对象的process方法</li>\n</ul>\n<p>还有一个很关键的类，就是用来处理客户CGI请求的类，需要实现init方法和process方法，process方法就完成了CGI请求(创建一个子进程，用来执行CGI程序，并且将标准输出重定向到网络socket)</p>\n<p>小技巧：子进程中需要的变量都从父进程继承了过来，并根据需要进行相应的修改也不会相互影响</p>\n<p>扩展性：该进程池具有一定的扩展性，本次实例中process用来实现的CGI请求，但是可以根据不同的场景需要进行修改，但不会修改进程池内部源码。</p>"},{"title":"重载","date":"2018-11-03T04:14:26.000Z","_content":"\n## 函数重载\n\n多个函数拥有相同的函数名，但是参数列表不同，仅仅返回值不同不行。\n\n参数列表包括参数的类型、参数的个数、参数顺序，只要有一个不同就叫参数列表不同。\n\n在C语言中，如果需要实现两个数相加，但不确定类型，可能需要定义多个函数\n\nint add1(int,int);\n\ndouble add2(double,double)\n\n在C++中，函数重载就体现了它的优势，没必要取多个函数名，有时候取名字真的是一件很麻烦的事情。\n\nint add(int,int);\n\ndouble add(double,double);\n\n在具体调用的时候会根据传入的参数，选择对应的函数。\n\n## 重载实现机理\n\nC++代码在编译时会根据参数列表对函数重命名。\n\n举个例子,int Add(int a,int b)会被重命名为Add_int_int,double Add(double a,double b)会被重命名为Add_double_double。当发生函数调用时，编译器根据传入的实参去猪哥匹配，选择对应的函数，如果匹配失败，编译器报错，这叫重载决议。也就是说本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。\n\n\n## 操作符重载\n\n对于内类的数据类型，执行一些操作很方便，譬如将两个整数相加，但是如何将两个类对象相加呢？\n\n这时候操作符重载就派上作用了，所谓操作符重载就是运算符与类结合，产生新的定义。\n\n注意：不能重载的运算符有 .和.*和? : 和:: 和sizeof\n\n## 如何实现\n\n定义成类的成员函数或者友元函数，当然如果不需要访问类中非公有成员，也不需要友元，只需定义成全局函数。\n\n假设现在有一个Test类。\n\n- 重载加号、减号\n  第一种方式 Test operator+(const Test& );   //第一个操作数必须是类对象\n  第二种方式 Test operator+(const Test&,const Test&); //定义成友元函数，解决加法交换律\n\n  调用方式：\n  1.隐式调用   obj1+obj2\n  2.显式调用   obj1.operator(obj2)----成员函数   operator+(obj1,obj2)-----友元函数\n\n  执行时 ，隐式调用和显式调用都会调用operator+()\n\n- 重载自增，自减\n\n  ```\n  Test operator++(){ //++obj\n      this->x++;\n      return *this;\n  }\n  Test operator(int x){ //obj++\n      Test temp = *this; //保存原有的状态\n      this->x++;\n      retrun temp;\n  }\n  ```\n\n  前缀形式，通过返回*this或者自身引用，也就是返回变化之后的结果 （++obj,--obj）\n\n  后缀形式，有一个int类型的虚参，返回的是原状态是拷贝后的临时变量。\n\n\n\n\n\n\n\n\n\n","source":"_posts/重载.md","raw":"---\ntitle: 重载\ndate: 2018-11-03 12:14:26\ntags: C++\n---\n\n## 函数重载\n\n多个函数拥有相同的函数名，但是参数列表不同，仅仅返回值不同不行。\n\n参数列表包括参数的类型、参数的个数、参数顺序，只要有一个不同就叫参数列表不同。\n\n在C语言中，如果需要实现两个数相加，但不确定类型，可能需要定义多个函数\n\nint add1(int,int);\n\ndouble add2(double,double)\n\n在C++中，函数重载就体现了它的优势，没必要取多个函数名，有时候取名字真的是一件很麻烦的事情。\n\nint add(int,int);\n\ndouble add(double,double);\n\n在具体调用的时候会根据传入的参数，选择对应的函数。\n\n## 重载实现机理\n\nC++代码在编译时会根据参数列表对函数重命名。\n\n举个例子,int Add(int a,int b)会被重命名为Add_int_int,double Add(double a,double b)会被重命名为Add_double_double。当发生函数调用时，编译器根据传入的实参去猪哥匹配，选择对应的函数，如果匹配失败，编译器报错，这叫重载决议。也就是说本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。\n\n\n## 操作符重载\n\n对于内类的数据类型，执行一些操作很方便，譬如将两个整数相加，但是如何将两个类对象相加呢？\n\n这时候操作符重载就派上作用了，所谓操作符重载就是运算符与类结合，产生新的定义。\n\n注意：不能重载的运算符有 .和.*和? : 和:: 和sizeof\n\n## 如何实现\n\n定义成类的成员函数或者友元函数，当然如果不需要访问类中非公有成员，也不需要友元，只需定义成全局函数。\n\n假设现在有一个Test类。\n\n- 重载加号、减号\n  第一种方式 Test operator+(const Test& );   //第一个操作数必须是类对象\n  第二种方式 Test operator+(const Test&,const Test&); //定义成友元函数，解决加法交换律\n\n  调用方式：\n  1.隐式调用   obj1+obj2\n  2.显式调用   obj1.operator(obj2)----成员函数   operator+(obj1,obj2)-----友元函数\n\n  执行时 ，隐式调用和显式调用都会调用operator+()\n\n- 重载自增，自减\n\n  ```\n  Test operator++(){ //++obj\n      this->x++;\n      return *this;\n  }\n  Test operator(int x){ //obj++\n      Test temp = *this; //保存原有的状态\n      this->x++;\n      retrun temp;\n  }\n  ```\n\n  前缀形式，通过返回*this或者自身引用，也就是返回变化之后的结果 （++obj,--obj）\n\n  后缀形式，有一个int类型的虚参，返回的是原状态是拷贝后的临时变量。\n\n\n\n\n\n\n\n\n\n","slug":"重载","published":1,"updated":"2021-12-06T05:30:36.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip82002z96cae3ncghgk","content":"<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>多个函数拥有相同的函数名，但是参数列表不同，仅仅返回值不同不行。</p>\n<p>参数列表包括参数的类型、参数的个数、参数顺序，只要有一个不同就叫参数列表不同。</p>\n<p>在C语言中，如果需要实现两个数相加，但不确定类型，可能需要定义多个函数</p>\n<p>int add1(int,int);</p>\n<p>double add2(double,double)</p>\n<p>在C++中，函数重载就体现了它的优势，没必要取多个函数名，有时候取名字真的是一件很麻烦的事情。</p>\n<p>int add(int,int);</p>\n<p>double add(double,double);</p>\n<p>在具体调用的时候会根据传入的参数，选择对应的函数。</p>\n<h2 id=\"重载实现机理\"><a href=\"#重载实现机理\" class=\"headerlink\" title=\"重载实现机理\"></a>重载实现机理</h2><p>C++代码在编译时会根据参数列表对函数重命名。</p>\n<p>举个例子,int Add(int a,int b)会被重命名为Add_int_int,double Add(double a,double b)会被重命名为Add_double_double。当发生函数调用时，编译器根据传入的实参去猪哥匹配，选择对应的函数，如果匹配失败，编译器报错，这叫重载决议。也就是说本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p>\n<h2 id=\"操作符重载\"><a href=\"#操作符重载\" class=\"headerlink\" title=\"操作符重载\"></a>操作符重载</h2><p>对于内类的数据类型，执行一些操作很方便，譬如将两个整数相加，但是如何将两个类对象相加呢？</p>\n<p>这时候操作符重载就派上作用了，所谓操作符重载就是运算符与类结合，产生新的定义。</p>\n<p>注意：不能重载的运算符有 .和.*和? : 和:: 和sizeof</p>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>定义成类的成员函数或者友元函数，当然如果不需要访问类中非公有成员，也不需要友元，只需定义成全局函数。</p>\n<p>假设现在有一个Test类。</p>\n<ul>\n<li><p>重载加号、减号<br>第一种方式 Test operator+(const Test&amp; );   //第一个操作数必须是类对象<br>第二种方式 Test operator+(const Test&amp;,const Test&amp;); //定义成友元函数，解决加法交换律</p>\n<p>调用方式：<br>1.隐式调用   obj1+obj2<br>2.显式调用   obj1.operator(obj2)—-成员函数   operator+(obj1,obj2)—–友元函数</p>\n<p>执行时 ，隐式调用和显式调用都会调用operator+()</p>\n</li>\n<li><p>重载自增，自减</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Test operator++()&#123; &#x2F;&#x2F;++obj</span><br><span class=\"line\">    this-&gt;x++;</span><br><span class=\"line\">    return *this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Test operator(int x)&#123; &#x2F;&#x2F;obj++</span><br><span class=\"line\">    Test temp &#x3D; *this; &#x2F;&#x2F;保存原有的状态</span><br><span class=\"line\">    this-&gt;x++;</span><br><span class=\"line\">    retrun temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前缀形式，通过返回*this或者自身引用，也就是返回变化之后的结果 （++obj,–obj）</p>\n<p>后缀形式，有一个int类型的虚参，返回的是原状态是拷贝后的临时变量。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>多个函数拥有相同的函数名，但是参数列表不同，仅仅返回值不同不行。</p>\n<p>参数列表包括参数的类型、参数的个数、参数顺序，只要有一个不同就叫参数列表不同。</p>\n<p>在C语言中，如果需要实现两个数相加，但不确定类型，可能需要定义多个函数</p>\n<p>int add1(int,int);</p>\n<p>double add2(double,double)</p>\n<p>在C++中，函数重载就体现了它的优势，没必要取多个函数名，有时候取名字真的是一件很麻烦的事情。</p>\n<p>int add(int,int);</p>\n<p>double add(double,double);</p>\n<p>在具体调用的时候会根据传入的参数，选择对应的函数。</p>\n<h2 id=\"重载实现机理\"><a href=\"#重载实现机理\" class=\"headerlink\" title=\"重载实现机理\"></a>重载实现机理</h2><p>C++代码在编译时会根据参数列表对函数重命名。</p>\n<p>举个例子,int Add(int a,int b)会被重命名为Add_int_int,double Add(double a,double b)会被重命名为Add_double_double。当发生函数调用时，编译器根据传入的实参去猪哥匹配，选择对应的函数，如果匹配失败，编译器报错，这叫重载决议。也就是说本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p>\n<h2 id=\"操作符重载\"><a href=\"#操作符重载\" class=\"headerlink\" title=\"操作符重载\"></a>操作符重载</h2><p>对于内类的数据类型，执行一些操作很方便，譬如将两个整数相加，但是如何将两个类对象相加呢？</p>\n<p>这时候操作符重载就派上作用了，所谓操作符重载就是运算符与类结合，产生新的定义。</p>\n<p>注意：不能重载的运算符有 .和.*和? : 和:: 和sizeof</p>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>定义成类的成员函数或者友元函数，当然如果不需要访问类中非公有成员，也不需要友元，只需定义成全局函数。</p>\n<p>假设现在有一个Test类。</p>\n<ul>\n<li><p>重载加号、减号<br>第一种方式 Test operator+(const Test&amp; );   //第一个操作数必须是类对象<br>第二种方式 Test operator+(const Test&amp;,const Test&amp;); //定义成友元函数，解决加法交换律</p>\n<p>调用方式：<br>1.隐式调用   obj1+obj2<br>2.显式调用   obj1.operator(obj2)—-成员函数   operator+(obj1,obj2)—–友元函数</p>\n<p>执行时 ，隐式调用和显式调用都会调用operator+()</p>\n</li>\n<li><p>重载自增，自减</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Test operator++()&#123; &#x2F;&#x2F;++obj</span><br><span class=\"line\">    this-&gt;x++;</span><br><span class=\"line\">    return *this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Test operator(int x)&#123; &#x2F;&#x2F;obj++</span><br><span class=\"line\">    Test temp &#x3D; *this; &#x2F;&#x2F;保存原有的状态</span><br><span class=\"line\">    this-&gt;x++;</span><br><span class=\"line\">    retrun temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前缀形式，通过返回*this或者自身引用，也就是返回变化之后的结果 （++obj,–obj）</p>\n<p>后缀形式，有一个int类型的虚参，返回的是原状态是拷贝后的临时变量。</p>\n</li>\n</ul>\n"},{"_content":"```\ntitle: 博客搭建流程再记录\ndate: 2021-12-06\ntags:\n- 流程记录\n```\n\n采用hexo+github进行博客搭建\n\n第一部分：hexo的初级搭建还有部署到github page上，以及个人域名的绑定。\n\n第二部分：hexo的基本配置，更换主题，实现多终端工作\n\n\n\nhexo介绍\n\n\n\n前置准备工作\n\n\n\n# 第一部分\n\n## hexo博客搭建流程\n\n1. git安装\n2. Node.js安装\n3. Hexo安装\n4. GitHub创建个人仓库\n5. 生成SSH添加到GitHub\n6. 将hexo部署到GitHub\n7. 设置个人域名\n8. 发布文章","source":"_posts/2021/博客搭建流程再记录.md","raw":"```\ntitle: 博客搭建流程再记录\ndate: 2021-12-06\ntags:\n- 流程记录\n```\n\n采用hexo+github进行博客搭建\n\n第一部分：hexo的初级搭建还有部署到github page上，以及个人域名的绑定。\n\n第二部分：hexo的基本配置，更换主题，实现多终端工作\n\n\n\nhexo介绍\n\n\n\n前置准备工作\n\n\n\n# 第一部分\n\n## hexo博客搭建流程\n\n1. git安装\n2. Node.js安装\n3. Hexo安装\n4. GitHub创建个人仓库\n5. 生成SSH添加到GitHub\n6. 将hexo部署到GitHub\n7. 设置个人域名\n8. 发布文章","slug":"2021-博客搭建流程再记录","published":1,"date":"2021-12-06T05:33:24.267Z","updated":"2021-12-06T05:57:43.489Z","title":"2021-博客搭建流程再记录","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip8h005t96ca3doo09er","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 博客搭建流程再记录</span><br><span class=\"line\">date: 2021-12-06</span><br><span class=\"line\">tags:</span><br><span class=\"line\">- 流程记录</span><br></pre></td></tr></table></figure>\n\n<p>采用hexo+github进行博客搭建</p>\n<p>第一部分：hexo的初级搭建还有部署到github page上，以及个人域名的绑定。</p>\n<p>第二部分：hexo的基本配置，更换主题，实现多终端工作</p>\n<p>hexo介绍</p>\n<p>前置准备工作</p>\n<h1 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h1><h2 id=\"hexo博客搭建流程\"><a href=\"#hexo博客搭建流程\" class=\"headerlink\" title=\"hexo博客搭建流程\"></a>hexo博客搭建流程</h2><ol>\n<li>git安装</li>\n<li>Node.js安装</li>\n<li>Hexo安装</li>\n<li>GitHub创建个人仓库</li>\n<li>生成SSH添加到GitHub</li>\n<li>将hexo部署到GitHub</li>\n<li>设置个人域名</li>\n<li>发布文章</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 博客搭建流程再记录</span><br><span class=\"line\">date: 2021-12-06</span><br><span class=\"line\">tags:</span><br><span class=\"line\">- 流程记录</span><br></pre></td></tr></table></figure>\n\n<p>采用hexo+github进行博客搭建</p>\n<p>第一部分：hexo的初级搭建还有部署到github page上，以及个人域名的绑定。</p>\n<p>第二部分：hexo的基本配置，更换主题，实现多终端工作</p>\n<p>hexo介绍</p>\n<p>前置准备工作</p>\n<h1 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h1><h2 id=\"hexo博客搭建流程\"><a href=\"#hexo博客搭建流程\" class=\"headerlink\" title=\"hexo博客搭建流程\"></a>hexo博客搭建流程</h2><ol>\n<li>git安装</li>\n<li>Node.js安装</li>\n<li>Hexo安装</li>\n<li>GitHub创建个人仓库</li>\n<li>生成SSH添加到GitHub</li>\n<li>将hexo部署到GitHub</li>\n<li>设置个人域名</li>\n<li>发布文章</li>\n</ol>\n"},{"title":"pycharm快捷键整理","date":"2020-01-16T17:06:13.000Z","_content":"\n最近实习准备下班之后好好学一学python，虽然之前接触过，但感觉很浅显，没有深入使用。\n\n俗话说，一个好的开发工具能够事半功倍，Pycharm就是这样一款产品，记录一下常用的快捷键，持续补充\n\n公司电脑是Mac，因此只记录Mac版本\n\n<!--more-->\n\n### 任意位置换行\n\n无论光标在任何位置，都可以通过 `shift+enter` 另起一行，无需把光标移到末尾再按回车，特别方便，使用频率很高\n\n\n\n#### 智能提示\n\nPycharm默认有自动提示的功能，但是还不够智能。对于还没有import的模块，就没有提示了，可以使用 `option+enter`智能提示选择合适的模块导入\n\n\n\n####  分屏操作\n\nPycharm的默认配置是没有设置分割的快捷键的，可以在keymap中自己配置\n\n![](/pic/pycharm分屏.png)\n\n设置的左右分屏  `option+v`     Vertically代表水平\n\n设置的上下分屏  `option+h`     Horizontally代表垂直\n\n设置的取消分屏  `option+q`    对应的key是unsplit\n\n\n\n#### 历史粘贴板\n\nMac中有Alfred有这个功能，但是收费，这是针对整个系统的历史粘贴板\n\n针对Pycharm，实现了自己的历史粘贴板,快捷键是 `option+shift+v`\n\n\n\n#### 万能搜索\n\n最最实用的快捷键，没有之一，double shift\n\n可以搜索类名、文件名、方法名\n\n\n\n#### 一些比较好理解的命令\n\n查看最近看过的文件   `command+e`\n\n\n\n","source":"_posts/2020/01/pycharm快捷键整理.md","raw":"---\ntitle: pycharm快捷键整理\ndate: 2020-01-17 01:06:13\ntags:\n- 工具\n---\n\n最近实习准备下班之后好好学一学python，虽然之前接触过，但感觉很浅显，没有深入使用。\n\n俗话说，一个好的开发工具能够事半功倍，Pycharm就是这样一款产品，记录一下常用的快捷键，持续补充\n\n公司电脑是Mac，因此只记录Mac版本\n\n<!--more-->\n\n### 任意位置换行\n\n无论光标在任何位置，都可以通过 `shift+enter` 另起一行，无需把光标移到末尾再按回车，特别方便，使用频率很高\n\n\n\n#### 智能提示\n\nPycharm默认有自动提示的功能，但是还不够智能。对于还没有import的模块，就没有提示了，可以使用 `option+enter`智能提示选择合适的模块导入\n\n\n\n####  分屏操作\n\nPycharm的默认配置是没有设置分割的快捷键的，可以在keymap中自己配置\n\n![](/pic/pycharm分屏.png)\n\n设置的左右分屏  `option+v`     Vertically代表水平\n\n设置的上下分屏  `option+h`     Horizontally代表垂直\n\n设置的取消分屏  `option+q`    对应的key是unsplit\n\n\n\n#### 历史粘贴板\n\nMac中有Alfred有这个功能，但是收费，这是针对整个系统的历史粘贴板\n\n针对Pycharm，实现了自己的历史粘贴板,快捷键是 `option+shift+v`\n\n\n\n#### 万能搜索\n\n最最实用的快捷键，没有之一，double shift\n\n可以搜索类名、文件名、方法名\n\n\n\n#### 一些比较好理解的命令\n\n查看最近看过的文件   `command+e`\n\n\n\n","slug":"pycharm快捷键整理","published":1,"updated":"2021-12-06T05:30:36.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip8j005u96ca0fuq3pzt","content":"<p>最近实习准备下班之后好好学一学python，虽然之前接触过，但感觉很浅显，没有深入使用。</p>\n<p>俗话说，一个好的开发工具能够事半功倍，Pycharm就是这样一款产品，记录一下常用的快捷键，持续补充</p>\n<p>公司电脑是Mac，因此只记录Mac版本</p>\n<a id=\"more\"></a>\n\n<h3 id=\"任意位置换行\"><a href=\"#任意位置换行\" class=\"headerlink\" title=\"任意位置换行\"></a>任意位置换行</h3><p>无论光标在任何位置，都可以通过 <code>shift+enter</code> 另起一行，无需把光标移到末尾再按回车，特别方便，使用频率很高</p>\n<h4 id=\"智能提示\"><a href=\"#智能提示\" class=\"headerlink\" title=\"智能提示\"></a>智能提示</h4><p>Pycharm默认有自动提示的功能，但是还不够智能。对于还没有import的模块，就没有提示了，可以使用 <code>option+enter</code>智能提示选择合适的模块导入</p>\n<h4 id=\"分屏操作\"><a href=\"#分屏操作\" class=\"headerlink\" title=\"分屏操作\"></a>分屏操作</h4><p>Pycharm的默认配置是没有设置分割的快捷键的，可以在keymap中自己配置</p>\n<p><img src=\"/pic/pycharm%E5%88%86%E5%B1%8F.png\" alt=\"\"></p>\n<p>设置的左右分屏  <code>option+v</code>     Vertically代表水平</p>\n<p>设置的上下分屏  <code>option+h</code>     Horizontally代表垂直</p>\n<p>设置的取消分屏  <code>option+q</code>    对应的key是unsplit</p>\n<h4 id=\"历史粘贴板\"><a href=\"#历史粘贴板\" class=\"headerlink\" title=\"历史粘贴板\"></a>历史粘贴板</h4><p>Mac中有Alfred有这个功能，但是收费，这是针对整个系统的历史粘贴板</p>\n<p>针对Pycharm，实现了自己的历史粘贴板,快捷键是 <code>option+shift+v</code></p>\n<h4 id=\"万能搜索\"><a href=\"#万能搜索\" class=\"headerlink\" title=\"万能搜索\"></a>万能搜索</h4><p>最最实用的快捷键，没有之一，double shift</p>\n<p>可以搜索类名、文件名、方法名</p>\n<h4 id=\"一些比较好理解的命令\"><a href=\"#一些比较好理解的命令\" class=\"headerlink\" title=\"一些比较好理解的命令\"></a>一些比较好理解的命令</h4><p>查看最近看过的文件   <code>command+e</code></p>\n","site":{"data":{}},"excerpt":"<p>最近实习准备下班之后好好学一学python，虽然之前接触过，但感觉很浅显，没有深入使用。</p>\n<p>俗话说，一个好的开发工具能够事半功倍，Pycharm就是这样一款产品，记录一下常用的快捷键，持续补充</p>\n<p>公司电脑是Mac，因此只记录Mac版本</p>","more":"<h3 id=\"任意位置换行\"><a href=\"#任意位置换行\" class=\"headerlink\" title=\"任意位置换行\"></a>任意位置换行</h3><p>无论光标在任何位置，都可以通过 <code>shift+enter</code> 另起一行，无需把光标移到末尾再按回车，特别方便，使用频率很高</p>\n<h4 id=\"智能提示\"><a href=\"#智能提示\" class=\"headerlink\" title=\"智能提示\"></a>智能提示</h4><p>Pycharm默认有自动提示的功能，但是还不够智能。对于还没有import的模块，就没有提示了，可以使用 <code>option+enter</code>智能提示选择合适的模块导入</p>\n<h4 id=\"分屏操作\"><a href=\"#分屏操作\" class=\"headerlink\" title=\"分屏操作\"></a>分屏操作</h4><p>Pycharm的默认配置是没有设置分割的快捷键的，可以在keymap中自己配置</p>\n<p><img src=\"/pic/pycharm%E5%88%86%E5%B1%8F.png\" alt=\"\"></p>\n<p>设置的左右分屏  <code>option+v</code>     Vertically代表水平</p>\n<p>设置的上下分屏  <code>option+h</code>     Horizontally代表垂直</p>\n<p>设置的取消分屏  <code>option+q</code>    对应的key是unsplit</p>\n<h4 id=\"历史粘贴板\"><a href=\"#历史粘贴板\" class=\"headerlink\" title=\"历史粘贴板\"></a>历史粘贴板</h4><p>Mac中有Alfred有这个功能，但是收费，这是针对整个系统的历史粘贴板</p>\n<p>针对Pycharm，实现了自己的历史粘贴板,快捷键是 <code>option+shift+v</code></p>\n<h4 id=\"万能搜索\"><a href=\"#万能搜索\" class=\"headerlink\" title=\"万能搜索\"></a>万能搜索</h4><p>最最实用的快捷键，没有之一，double shift</p>\n<p>可以搜索类名、文件名、方法名</p>\n<h4 id=\"一些比较好理解的命令\"><a href=\"#一些比较好理解的命令\" class=\"headerlink\" title=\"一些比较好理解的命令\"></a>一些比较好理解的命令</h4><p>查看最近看过的文件   <code>command+e</code></p>"},{"title":"博客搭建流程","date":"2020-01-15T17:18:17.000Z","_content":"\n## 背景\n\n准备用公司的电脑写博客上传到github，然后部署。之前的代码库在原来自己的电脑上，github上只有部署后的代码。遇到的问题就是，换了电脑之后如何切换写好的博客文章库\n\n<!--more-->\n\n## 安装流程\n\n**使用Hexo搭建github博客**\n\nHexo搭建的博客其实是个静态的博客，每次需要新发表一篇博客时，需要在本地库中新增一个.md文件，执行hexo g再次生成一个新的网页，然后执行hexo d进行网页的部署，从而替换到原先的网页\n\n优势：有着更大的自主性，从主题到博文展示\n\n劣势：不能在线编辑，需要自己管理博文库\n\n\n\n依赖的软件：Node.js\n\n前提条件：\n\n- 已安装Git工具\n- 已有GitHub账号\n- （Mac）已安装Xcode command line tools\n\n### 第一步-安装Node.js\n\n[参考博文](https://www.jianshu.com/p/c1b6c452a98a)\n\n[官网下载地址](https://nodejs.org/en/)\n\n我直接在官网下下载的，一路安装都不存在问题\n\n### 第二步-安装Hexo\n\n执行命令 \n\n```npm install -g hexo-cli    \nnpm install -g hexo-cli    \n```\n\n一开始我报了个某个文件夹没有写入权限  加上sudo再次执行就OK了\n\n为了方便部署，安装\n\n```\nnpm install hexo-deployer-git --save\n```\n\n同时修改_config.yml文件\n\n```\ndeploy:\n\ttype: git\n\trepository: git@github.com:oldbuffalo/oldbuffalo.github.io.git  # 仓库用ssh  需要配一下公钥\n\tbranch: master\n```\n\n为了执行所有文章按钮\n\n```\nnpm i hexo-generator-json-content --save\n```\n\n迁移的过程中，我采用的比较笨的方法，将原先电脑中的文件夹拷贝到公司电脑\n\n缺点：不方便，如果原先电脑出问题了，就不存在了\n\n关于里面文件作用的解释：\n\n- _config.yml  配置文件        必须拷贝\n- theme  自己下载的可选主题     必须拷贝\n- source  最重要  博文源码      必须拷贝\n- scaffolds  文章模板     不必拷贝\n- package.json   说明使用哪些包  不必拷贝\n- .gitignore  限制提交的时候哪些文件可以忽略   不必拷贝\n\n后三个文件在执行 hexo init的时候会自动生成，上面六个可以全部拷贝过去\n\n- .git  没必要拷贝\n- node_modules     npm install会重新生成\n- public   hexo g 重新生成\n- .deploy_git  hexo g 重新生成\n- db.json  不用管\n\n其实上面五个文件也就是.gitignore文件里面记载的可以忽略的内容\n\n**需要注意的是**：如果采用拷贝文件的方式迁移，则不必再执行hexo init，因为_config.yml会被重写\n\n## 更优秀的做法\n\n看到知乎上有人在github上创建了两个分支，master用来发布，hexo存放hexo源码，以后每次需要迁移的时候只要配置一下hexo环境，然后git clone一下hexo分支下面的代码\n\n[参考链接](https://www.zhihu.com/question/21193762)\n\n\n\n## 注意点\n\n修改配置文件的时候\npermalink 要与new_post_name 路径对齐\n\n```\npermalink: :year/:month/:title/      # 控制页面点击博文时候的url\nnew_post_name: :year/:month/:title.md   # 控制新建博文时 在_posts中的路径\n```\n\n","source":"_posts/2020/01/博客搭建流程.md","raw":"---\ntitle: 博客搭建流程\ndate: 2020-01-16 01:18:17\ntags: \n- git\n- 软件安装\n---\n\n## 背景\n\n准备用公司的电脑写博客上传到github，然后部署。之前的代码库在原来自己的电脑上，github上只有部署后的代码。遇到的问题就是，换了电脑之后如何切换写好的博客文章库\n\n<!--more-->\n\n## 安装流程\n\n**使用Hexo搭建github博客**\n\nHexo搭建的博客其实是个静态的博客，每次需要新发表一篇博客时，需要在本地库中新增一个.md文件，执行hexo g再次生成一个新的网页，然后执行hexo d进行网页的部署，从而替换到原先的网页\n\n优势：有着更大的自主性，从主题到博文展示\n\n劣势：不能在线编辑，需要自己管理博文库\n\n\n\n依赖的软件：Node.js\n\n前提条件：\n\n- 已安装Git工具\n- 已有GitHub账号\n- （Mac）已安装Xcode command line tools\n\n### 第一步-安装Node.js\n\n[参考博文](https://www.jianshu.com/p/c1b6c452a98a)\n\n[官网下载地址](https://nodejs.org/en/)\n\n我直接在官网下下载的，一路安装都不存在问题\n\n### 第二步-安装Hexo\n\n执行命令 \n\n```npm install -g hexo-cli    \nnpm install -g hexo-cli    \n```\n\n一开始我报了个某个文件夹没有写入权限  加上sudo再次执行就OK了\n\n为了方便部署，安装\n\n```\nnpm install hexo-deployer-git --save\n```\n\n同时修改_config.yml文件\n\n```\ndeploy:\n\ttype: git\n\trepository: git@github.com:oldbuffalo/oldbuffalo.github.io.git  # 仓库用ssh  需要配一下公钥\n\tbranch: master\n```\n\n为了执行所有文章按钮\n\n```\nnpm i hexo-generator-json-content --save\n```\n\n迁移的过程中，我采用的比较笨的方法，将原先电脑中的文件夹拷贝到公司电脑\n\n缺点：不方便，如果原先电脑出问题了，就不存在了\n\n关于里面文件作用的解释：\n\n- _config.yml  配置文件        必须拷贝\n- theme  自己下载的可选主题     必须拷贝\n- source  最重要  博文源码      必须拷贝\n- scaffolds  文章模板     不必拷贝\n- package.json   说明使用哪些包  不必拷贝\n- .gitignore  限制提交的时候哪些文件可以忽略   不必拷贝\n\n后三个文件在执行 hexo init的时候会自动生成，上面六个可以全部拷贝过去\n\n- .git  没必要拷贝\n- node_modules     npm install会重新生成\n- public   hexo g 重新生成\n- .deploy_git  hexo g 重新生成\n- db.json  不用管\n\n其实上面五个文件也就是.gitignore文件里面记载的可以忽略的内容\n\n**需要注意的是**：如果采用拷贝文件的方式迁移，则不必再执行hexo init，因为_config.yml会被重写\n\n## 更优秀的做法\n\n看到知乎上有人在github上创建了两个分支，master用来发布，hexo存放hexo源码，以后每次需要迁移的时候只要配置一下hexo环境，然后git clone一下hexo分支下面的代码\n\n[参考链接](https://www.zhihu.com/question/21193762)\n\n\n\n## 注意点\n\n修改配置文件的时候\npermalink 要与new_post_name 路径对齐\n\n```\npermalink: :year/:month/:title/      # 控制页面点击博文时候的url\nnew_post_name: :year/:month/:title.md   # 控制新建博文时 在_posts中的路径\n```\n\n","slug":"博客搭建流程","published":1,"updated":"2021-12-06T05:30:36.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwu9ip8j005v96ca62x423zx","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>准备用公司的电脑写博客上传到github，然后部署。之前的代码库在原来自己的电脑上，github上只有部署后的代码。遇到的问题就是，换了电脑之后如何切换写好的博客文章库</p>\n<a id=\"more\"></a>\n\n<h2 id=\"安装流程\"><a href=\"#安装流程\" class=\"headerlink\" title=\"安装流程\"></a>安装流程</h2><p><strong>使用Hexo搭建github博客</strong></p>\n<p>Hexo搭建的博客其实是个静态的博客，每次需要新发表一篇博客时，需要在本地库中新增一个.md文件，执行hexo g再次生成一个新的网页，然后执行hexo d进行网页的部署，从而替换到原先的网页</p>\n<p>优势：有着更大的自主性，从主题到博文展示</p>\n<p>劣势：不能在线编辑，需要自己管理博文库</p>\n<p>依赖的软件：Node.js</p>\n<p>前提条件：</p>\n<ul>\n<li>已安装Git工具</li>\n<li>已有GitHub账号</li>\n<li>（Mac）已安装Xcode command line tools</li>\n</ul>\n<h3 id=\"第一步-安装Node-js\"><a href=\"#第一步-安装Node-js\" class=\"headerlink\" title=\"第一步-安装Node.js\"></a>第一步-安装Node.js</h3><p><a href=\"https://www.jianshu.com/p/c1b6c452a98a\" target=\"_blank\" rel=\"noopener\">参考博文</a></p>\n<p><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">官网下载地址</a></p>\n<p>我直接在官网下下载的，一路安装都不存在问题</p>\n<h3 id=\"第二步-安装Hexo\"><a href=\"#第二步-安装Hexo\" class=\"headerlink\" title=\"第二步-安装Hexo\"></a>第二步-安装Hexo</h3><p>执行命令 </p>\n<figure class=\"highlight plain\"><figcaption><span>install -g hexo-cli    </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>一开始我报了个某个文件夹没有写入权限  加上sudo再次执行就OK了</p>\n<p>为了方便部署，安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>同时修改_config.yml文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">\ttype: git</span><br><span class=\"line\">\trepository: git@github.com:oldbuffalo&#x2F;oldbuffalo.github.io.git  # 仓库用ssh  需要配一下公钥</span><br><span class=\"line\">\tbranch: master</span><br></pre></td></tr></table></figure>\n\n<p>为了执行所有文章按钮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-generator-json-content --save</span><br></pre></td></tr></table></figure>\n\n<p>迁移的过程中，我采用的比较笨的方法，将原先电脑中的文件夹拷贝到公司电脑</p>\n<p>缺点：不方便，如果原先电脑出问题了，就不存在了</p>\n<p>关于里面文件作用的解释：</p>\n<ul>\n<li>_config.yml  配置文件        必须拷贝</li>\n<li>theme  自己下载的可选主题     必须拷贝</li>\n<li>source  最重要  博文源码      必须拷贝</li>\n<li>scaffolds  文章模板     不必拷贝</li>\n<li>package.json   说明使用哪些包  不必拷贝</li>\n<li>.gitignore  限制提交的时候哪些文件可以忽略   不必拷贝</li>\n</ul>\n<p>后三个文件在执行 hexo init的时候会自动生成，上面六个可以全部拷贝过去</p>\n<ul>\n<li>.git  没必要拷贝</li>\n<li>node_modules     npm install会重新生成</li>\n<li>public   hexo g 重新生成</li>\n<li>.deploy_git  hexo g 重新生成</li>\n<li>db.json  不用管</li>\n</ul>\n<p>其实上面五个文件也就是.gitignore文件里面记载的可以忽略的内容</p>\n<p><strong>需要注意的是</strong>：如果采用拷贝文件的方式迁移，则不必再执行hexo init，因为_config.yml会被重写</p>\n<h2 id=\"更优秀的做法\"><a href=\"#更优秀的做法\" class=\"headerlink\" title=\"更优秀的做法\"></a>更优秀的做法</h2><p>看到知乎上有人在github上创建了两个分支，master用来发布，hexo存放hexo源码，以后每次需要迁移的时候只要配置一下hexo环境，然后git clone一下hexo分支下面的代码</p>\n<p><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>修改配置文件的时候<br>permalink 要与new_post_name 路径对齐</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">permalink: :year&#x2F;:month&#x2F;:title&#x2F;      # 控制页面点击博文时候的url</span><br><span class=\"line\">new_post_name: :year&#x2F;:month&#x2F;:title.md   # 控制新建博文时 在_posts中的路径</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>准备用公司的电脑写博客上传到github，然后部署。之前的代码库在原来自己的电脑上，github上只有部署后的代码。遇到的问题就是，换了电脑之后如何切换写好的博客文章库</p>","more":"<h2 id=\"安装流程\"><a href=\"#安装流程\" class=\"headerlink\" title=\"安装流程\"></a>安装流程</h2><p><strong>使用Hexo搭建github博客</strong></p>\n<p>Hexo搭建的博客其实是个静态的博客，每次需要新发表一篇博客时，需要在本地库中新增一个.md文件，执行hexo g再次生成一个新的网页，然后执行hexo d进行网页的部署，从而替换到原先的网页</p>\n<p>优势：有着更大的自主性，从主题到博文展示</p>\n<p>劣势：不能在线编辑，需要自己管理博文库</p>\n<p>依赖的软件：Node.js</p>\n<p>前提条件：</p>\n<ul>\n<li>已安装Git工具</li>\n<li>已有GitHub账号</li>\n<li>（Mac）已安装Xcode command line tools</li>\n</ul>\n<h3 id=\"第一步-安装Node-js\"><a href=\"#第一步-安装Node-js\" class=\"headerlink\" title=\"第一步-安装Node.js\"></a>第一步-安装Node.js</h3><p><a href=\"https://www.jianshu.com/p/c1b6c452a98a\" target=\"_blank\" rel=\"noopener\">参考博文</a></p>\n<p><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">官网下载地址</a></p>\n<p>我直接在官网下下载的，一路安装都不存在问题</p>\n<h3 id=\"第二步-安装Hexo\"><a href=\"#第二步-安装Hexo\" class=\"headerlink\" title=\"第二步-安装Hexo\"></a>第二步-安装Hexo</h3><p>执行命令 </p>\n<figure class=\"highlight plain\"><figcaption><span>install -g hexo-cli    </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>一开始我报了个某个文件夹没有写入权限  加上sudo再次执行就OK了</p>\n<p>为了方便部署，安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>同时修改_config.yml文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">\ttype: git</span><br><span class=\"line\">\trepository: git@github.com:oldbuffalo&#x2F;oldbuffalo.github.io.git  # 仓库用ssh  需要配一下公钥</span><br><span class=\"line\">\tbranch: master</span><br></pre></td></tr></table></figure>\n\n<p>为了执行所有文章按钮</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i hexo-generator-json-content --save</span><br></pre></td></tr></table></figure>\n\n<p>迁移的过程中，我采用的比较笨的方法，将原先电脑中的文件夹拷贝到公司电脑</p>\n<p>缺点：不方便，如果原先电脑出问题了，就不存在了</p>\n<p>关于里面文件作用的解释：</p>\n<ul>\n<li>_config.yml  配置文件        必须拷贝</li>\n<li>theme  自己下载的可选主题     必须拷贝</li>\n<li>source  最重要  博文源码      必须拷贝</li>\n<li>scaffolds  文章模板     不必拷贝</li>\n<li>package.json   说明使用哪些包  不必拷贝</li>\n<li>.gitignore  限制提交的时候哪些文件可以忽略   不必拷贝</li>\n</ul>\n<p>后三个文件在执行 hexo init的时候会自动生成，上面六个可以全部拷贝过去</p>\n<ul>\n<li>.git  没必要拷贝</li>\n<li>node_modules     npm install会重新生成</li>\n<li>public   hexo g 重新生成</li>\n<li>.deploy_git  hexo g 重新生成</li>\n<li>db.json  不用管</li>\n</ul>\n<p>其实上面五个文件也就是.gitignore文件里面记载的可以忽略的内容</p>\n<p><strong>需要注意的是</strong>：如果采用拷贝文件的方式迁移，则不必再执行hexo init，因为_config.yml会被重写</p>\n<h2 id=\"更优秀的做法\"><a href=\"#更优秀的做法\" class=\"headerlink\" title=\"更优秀的做法\"></a>更优秀的做法</h2><p>看到知乎上有人在github上创建了两个分支，master用来发布，hexo存放hexo源码，以后每次需要迁移的时候只要配置一下hexo环境，然后git clone一下hexo分支下面的代码</p>\n<p><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">参考链接</a></p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><p>修改配置文件的时候<br>permalink 要与new_post_name 路径对齐</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">permalink: :year&#x2F;:month&#x2F;:title&#x2F;      # 控制页面点击博文时候的url</span><br><span class=\"line\">new_post_name: :year&#x2F;:month&#x2F;:title.md   # 控制新建博文时 在_posts中的路径</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckwu9ip70000196ca7iw0bme7","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip7c000d96caaaoj7a1v"},{"post_id":"ckwu9ip70000196ca7iw0bme7","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip7d000f96cabth7dxm1"},{"post_id":"ckwu9ip73000396caabpj41i6","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip7g000l96ca0u4tav1a"},{"post_id":"ckwu9ip73000396caabpj41i6","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip7g000n96ca6vjidphe"},{"post_id":"ckwu9ip76000596cadw7rara4","tag_id":"ckwu9ip7f000j96cabsiwhy1j","_id":"ckwu9ip7i000t96ca0pbdd0ja"},{"post_id":"ckwu9ip76000596cadw7rara4","tag_id":"ckwu9ip7g000o96ca6hn18r3g","_id":"ckwu9ip7j000v96ca0qjfhjtz"},{"post_id":"ckwu9ip77000696ca8qd6c9rr","tag_id":"ckwu9ip7i000r96ca96wy0o9z","_id":"ckwu9ip7l001196ca4pqq5s0h"},{"post_id":"ckwu9ip77000696ca8qd6c9rr","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip7l001396ca9tqf9dvz"},{"post_id":"ckwu9ip77000696ca8qd6c9rr","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip7m001696cact7z6x2p"},{"post_id":"ckwu9ip7l001496caapq00y0p","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip7n001896ca9kug26cm"},{"post_id":"ckwu9ip7l001496caapq00y0p","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip7n001b96cae84j849w"},{"post_id":"ckwu9ip78000796ca79w765bk","tag_id":"ckwu9ip7i000r96ca96wy0o9z","_id":"ckwu9ip7o001d96ca16jl4s6k"},{"post_id":"ckwu9ip78000796ca79w765bk","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip7p001g96ca7boif3i0"},{"post_id":"ckwu9ip78000796ca79w765bk","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip7p001i96cab2f81b3f"},{"post_id":"ckwu9ip7n001996caf2t33nr8","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip7q001l96ca4qaec0es"},{"post_id":"ckwu9ip7n001996caf2t33nr8","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip7q001n96ca6wnwf68s"},{"post_id":"ckwu9ip79000996ca724p3r8l","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip7r001q96cabgzo5dg5"},{"post_id":"ckwu9ip79000996ca724p3r8l","tag_id":"ckwu9ip7n001a96ca3h8zfjwe","_id":"ckwu9ip7s001s96ca3c5n25xj"},{"post_id":"ckwu9ip7a000a96cadx0z85cw","tag_id":"ckwu9ip7f000j96cabsiwhy1j","_id":"ckwu9ip7s001v96cafgdcgq0p"},{"post_id":"ckwu9ip7a000a96cadx0z85cw","tag_id":"ckwu9ip7q001k96ca2i1d51yz","_id":"ckwu9ip7t001x96cahtotft3x"},{"post_id":"ckwu9ip7r001r96ca3qiy7it1","tag_id":"ckwu9ip7f000j96cabsiwhy1j","_id":"ckwu9ip7u002096cab81s254a"},{"post_id":"ckwu9ip7c000c96ca9yjmftli","tag_id":"ckwu9ip7r001p96cacs2qbuhl","_id":"ckwu9ip7u002296ca5o3qcu3v"},{"post_id":"ckwu9ip7c000c96ca9yjmftli","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip7v002596ca1rtt92er"},{"post_id":"ckwu9ip7c000c96ca9yjmftli","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip7v002796cabn3mco01"},{"post_id":"ckwu9ip7s001t96ca6w5ocg80","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip7w002a96ca1fcgft4r"},{"post_id":"ckwu9ip7c000e96ca5pibd4dt","tag_id":"ckwu9ip7f000j96cabsiwhy1j","_id":"ckwu9ip7x002c96ca4riw0hvq"},{"post_id":"ckwu9ip7c000e96ca5pibd4dt","tag_id":"ckwu9ip7q001k96ca2i1d51yz","_id":"ckwu9ip7x002e96cahpae4xxu"},{"post_id":"ckwu9ip7e000h96ca8ei29jd6","tag_id":"ckwu9ip7r001p96cacs2qbuhl","_id":"ckwu9ip7y002h96cahl397sr6"},{"post_id":"ckwu9ip7e000h96ca8ei29jd6","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip7y002j96caeamc2ve4"},{"post_id":"ckwu9ip7e000h96ca8ei29jd6","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip7z002m96ca6bngcfk1"},{"post_id":"ckwu9ip7v002896caagxt0fy3","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip80002o96ca0edkfift"},{"post_id":"ckwu9ip7v002896caagxt0fy3","tag_id":"ckwu9ip7r001p96cacs2qbuhl","_id":"ckwu9ip80002r96cagrjt7u9w"},{"post_id":"ckwu9ip7e000i96ca4z35cdd2","tag_id":"ckwu9ip7w002996cabx0ohsdv","_id":"ckwu9ip81002t96ca8acdg14z"},{"post_id":"ckwu9ip7e000i96ca4z35cdd2","tag_id":"ckwu9ip7n001a96ca3h8zfjwe","_id":"ckwu9ip81002w96ca2ex2gn5o"},{"post_id":"ckwu9ip7e000i96ca4z35cdd2","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip82002y96cag7y1021v"},{"post_id":"ckwu9ip7e000i96ca4z35cdd2","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip83003196ca05a22ijp"},{"post_id":"ckwu9ip7z002k96ca3pkd2dgd","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip83003296ca8zrc20h3"},{"post_id":"ckwu9ip7z002k96ca3pkd2dgd","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip83003496ca05h3d868"},{"post_id":"ckwu9ip7z002n96ca13xu6tfa","tag_id":"ckwu9ip7f000j96cabsiwhy1j","_id":"ckwu9ip83003596cahy0w2zh6"},{"post_id":"ckwu9ip7f000k96caf2s4c20d","tag_id":"ckwu9ip7z002l96cac74978lb","_id":"ckwu9ip83003796ca2q3x6usa"},{"post_id":"ckwu9ip7f000k96caf2s4c20d","tag_id":"ckwu9ip80002q96cafk0o705v","_id":"ckwu9ip83003896ca98p5bzm6"},{"post_id":"ckwu9ip81002u96ca2gpj0hkk","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip84003a96ca9byrehwn"},{"post_id":"ckwu9ip81002u96ca2gpj0hkk","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip84003b96cacshieccl"},{"post_id":"ckwu9ip7g000m96cac9bsdw3t","tag_id":"ckwu9ip7f000j96cabsiwhy1j","_id":"ckwu9ip84003c96ca2wnk74mm"},{"post_id":"ckwu9ip7g000m96cac9bsdw3t","tag_id":"ckwu9ip7g000o96ca6hn18r3g","_id":"ckwu9ip84003e96ca5bfn23s5"},{"post_id":"ckwu9ip82002z96cae3ncghgk","tag_id":"ckwu9ip7f000j96cabsiwhy1j","_id":"ckwu9ip84003f96ca8q17bizr"},{"post_id":"ckwu9ip7h000p96cahe3nea1c","tag_id":"ckwu9ip7z002l96cac74978lb","_id":"ckwu9ip84003h96cacrp435jk"},{"post_id":"ckwu9ip7h000p96cahe3nea1c","tag_id":"ckwu9ip80002q96cafk0o705v","_id":"ckwu9ip85003i96ca938b37cb"},{"post_id":"ckwu9ip7h000q96ca0dgv93u6","tag_id":"ckwu9ip83003696ca3v2qano9","_id":"ckwu9ip85003k96ca430d2rgk"},{"post_id":"ckwu9ip7h000q96ca0dgv93u6","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip85003l96ca8hfbbwz6"},{"post_id":"ckwu9ip7i000s96ca5vgn4797","tag_id":"ckwu9ip84003996ca6bb66haa","_id":"ckwu9ip85003n96ca07090rxu"},{"post_id":"ckwu9ip7i000s96ca5vgn4797","tag_id":"ckwu9ip84003d96cahwgx5zl1","_id":"ckwu9ip85003o96caa8hf5ogo"},{"post_id":"ckwu9ip7i000s96ca5vgn4797","tag_id":"ckwu9ip7n001a96ca3h8zfjwe","_id":"ckwu9ip86003q96ca0o263t6o"},{"post_id":"ckwu9ip7i000u96ca6aen1zmu","tag_id":"ckwu9ip7z002l96cac74978lb","_id":"ckwu9ip86003r96cae3fe1qzb"},{"post_id":"ckwu9ip7i000u96ca6aen1zmu","tag_id":"ckwu9ip7n001a96ca3h8zfjwe","_id":"ckwu9ip86003t96ca8x0ac9hz"},{"post_id":"ckwu9ip7j000w96caeisve4jh","tag_id":"ckwu9ip7n001a96ca3h8zfjwe","_id":"ckwu9ip87003x96caefe91dxl"},{"post_id":"ckwu9ip7j000w96caeisve4jh","tag_id":"ckwu9ip7z002l96cac74978lb","_id":"ckwu9ip87003y96ca01kvdr8y"},{"post_id":"ckwu9ip7j000w96caeisve4jh","tag_id":"ckwu9ip84003d96cahwgx5zl1","_id":"ckwu9ip87004096ca5mpzalis"},{"post_id":"ckwu9ip7j000w96caeisve4jh","tag_id":"ckwu9ip86003v96cae0957t4x","_id":"ckwu9ip87004196ca7ba63255"},{"post_id":"ckwu9ip7k000y96ca2e9p3vbs","tag_id":"ckwu9ip7w002996cabx0ohsdv","_id":"ckwu9ip88004396caa98ah0bx"},{"post_id":"ckwu9ip7k000y96ca2e9p3vbs","tag_id":"ckwu9ip7n001a96ca3h8zfjwe","_id":"ckwu9ip88004496ca9f70e6ux"},{"post_id":"ckwu9ip7k000y96ca2e9p3vbs","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip88004696ca62iv14pd"},{"post_id":"ckwu9ip7k000y96ca2e9p3vbs","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip88004796cahpep658n"},{"post_id":"ckwu9ip7k000z96cahgxchs7r","tag_id":"ckwu9ip83003696ca3v2qano9","_id":"ckwu9ip88004996caawbj6xjh"},{"post_id":"ckwu9ip7l001296cahuo3c8t3","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip88004a96ca5b694qd5"},{"post_id":"ckwu9ip7l001296cahuo3c8t3","tag_id":"ckwu9ip7n001a96ca3h8zfjwe","_id":"ckwu9ip88004c96ca257ke1dz"},{"post_id":"ckwu9ip7l001296cahuo3c8t3","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip89004d96ca6dnv7hex"},{"post_id":"ckwu9ip7m001796ca82ks0129","tag_id":"ckwu9ip7w002996cabx0ohsdv","_id":"ckwu9ip89004f96cacq9uajc8"},{"post_id":"ckwu9ip7m001796ca82ks0129","tag_id":"ckwu9ip7n001a96ca3h8zfjwe","_id":"ckwu9ip89004g96cahoschdgc"},{"post_id":"ckwu9ip7m001796ca82ks0129","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip89004i96ca8n2mhsii"},{"post_id":"ckwu9ip7m001796ca82ks0129","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip89004j96caf22o9s7x"},{"post_id":"ckwu9ip7n001c96cad37k29qg","tag_id":"ckwu9ip7r001p96cacs2qbuhl","_id":"ckwu9ip8a004l96cahn71g808"},{"post_id":"ckwu9ip7n001c96cad37k29qg","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip8a004m96ca7x0k8ar3"},{"post_id":"ckwu9ip7n001c96cad37k29qg","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip8a004o96cabzz92aj1"},{"post_id":"ckwu9ip7o001e96cadxo0gvk7","tag_id":"ckwu9ip89004h96ca4y2sfhnu","_id":"ckwu9ip8a004p96ca30i29ur4"},{"post_id":"ckwu9ip7p001h96ca02u70zdn","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip8a004r96cahsa5f97v"},{"post_id":"ckwu9ip7p001h96ca02u70zdn","tag_id":"ckwu9ip83003696ca3v2qano9","_id":"ckwu9ip8a004s96cafukja7ut"},{"post_id":"ckwu9ip7p001h96ca02u70zdn","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip8a004u96ca2pblbczm"},{"post_id":"ckwu9ip7p001j96ca7m6v2d1v","tag_id":"ckwu9ip8a004n96ca90k4d6d1","_id":"ckwu9ip8b004v96cabj9m460s"},{"post_id":"ckwu9ip7q001m96ca0jquf469","tag_id":"ckwu9ip8a004n96ca90k4d6d1","_id":"ckwu9ip8b004x96ca118dezwz"},{"post_id":"ckwu9ip7r001o96ca8495fm13","tag_id":"ckwu9ip7r001p96cacs2qbuhl","_id":"ckwu9ip8b004y96cafuhofjo1"},{"post_id":"ckwu9ip7r001o96ca8495fm13","tag_id":"ckwu9ip75000496cahfr0cl60","_id":"ckwu9ip8b005096cac708bvll"},{"post_id":"ckwu9ip7s001w96ca14meftok","tag_id":"ckwu9ip89004h96ca4y2sfhnu","_id":"ckwu9ip8b005196caek7h4yiy"},{"post_id":"ckwu9ip7t001y96ca6ezbgxi6","tag_id":"ckwu9ip7f000j96cabsiwhy1j","_id":"ckwu9ip8b005396ca1tsferfa"},{"post_id":"ckwu9ip7t001y96ca6ezbgxi6","tag_id":"ckwu9ip8b004z96caeyc8fsvn","_id":"ckwu9ip8c005496cacz6lfrsm"},{"post_id":"ckwu9ip7u002196caartb6xq2","tag_id":"ckwu9ip8b005296ca57cl165r","_id":"ckwu9ip8c005696cagoua21s8"},{"post_id":"ckwu9ip7u002396cag3k2hscw","tag_id":"ckwu9ip8a004n96ca90k4d6d1","_id":"ckwu9ip8c005896ca5jd2cjb5"},{"post_id":"ckwu9ip7v002696cabf00hicz","tag_id":"ckwu9ip8a004n96ca90k4d6d1","_id":"ckwu9ip8c005a96ca14gq2znw"},{"post_id":"ckwu9ip7w002b96cab7ot6dfc","tag_id":"ckwu9ip7z002l96cac74978lb","_id":"ckwu9ip8d005c96cafcwmb225"},{"post_id":"ckwu9ip7x002d96caap3x4lig","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip8d005e96ca77fc5slx"},{"post_id":"ckwu9ip7x002d96caap3x4lig","tag_id":"ckwu9ip8c005b96ca15qz6s0n","_id":"ckwu9ip8d005f96ca5udo6ayp"},{"post_id":"ckwu9ip7x002f96ca596mgo4m","tag_id":"ckwu9ip8d005d96ca3h8j252v","_id":"ckwu9ip8d005i96caexvj32e1"},{"post_id":"ckwu9ip7x002f96ca596mgo4m","tag_id":"ckwu9ip8b005296ca57cl165r","_id":"ckwu9ip8e005j96ca8chyc7pz"},{"post_id":"ckwu9ip7y002i96cacv6k6zfm","tag_id":"ckwu9ip89004h96ca4y2sfhnu","_id":"ckwu9ip8e005l96ca02rtgnec"},{"post_id":"ckwu9ip80002p96ca86s1asbq","tag_id":"ckwu9ip89004h96ca4y2sfhnu","_id":"ckwu9ip8e005n96ca9gjkgolh"},{"post_id":"ckwu9ip80002s96caailfhe22","tag_id":"ckwu9ip84003d96cahwgx5zl1","_id":"ckwu9ip8e005p96ca7h186hmf"},{"post_id":"ckwu9ip80002s96caailfhe22","tag_id":"ckwu9ip7z002l96cac74978lb","_id":"ckwu9ip8e005q96cadbxpdq0j"},{"post_id":"ckwu9ip81002x96ca5b8i7n10","tag_id":"ckwu9ip78000896cadldtg5cm","_id":"ckwu9ip8f005r96caalsg7yf7"},{"post_id":"ckwu9ip81002x96ca5b8i7n10","tag_id":"ckwu9ip84003d96cahwgx5zl1","_id":"ckwu9ip8f005s96cag7qw137i"},{"post_id":"ckwu9ip8j005u96ca0fuq3pzt","tag_id":"ckwu9ip8k005w96cahhnm7meq","_id":"ckwu9ip8k005y96caedi6dfgc"},{"post_id":"ckwu9ip8j005v96ca62x423zx","tag_id":"ckwu9ip8k005x96ca6spua4of","_id":"ckwu9ip8l006096ca1svbcj2o"},{"post_id":"ckwu9ip8j005v96ca62x423zx","tag_id":"ckwu9ip8k005z96cabmupg69n","_id":"ckwu9ip8l006196caf3hj4jvk"}],"Tag":[{"name":"网络","_id":"ckwu9ip75000496cahfr0cl60"},{"name":"Linux高性能服务器编程","_id":"ckwu9ip78000896cadldtg5cm"},{"name":"C++","_id":"ckwu9ip7f000j96cabsiwhy1j"},{"name":"C++11","_id":"ckwu9ip7g000o96ca6hn18r3g"},{"name":"HTTP","_id":"ckwu9ip7i000r96ca96wy0o9z"},{"name":"Linux","_id":"ckwu9ip7n001a96ca3h8zfjwe"},{"name":"STL","_id":"ckwu9ip7q001k96ca2i1d51yz"},{"name":"TCP","_id":"ckwu9ip7r001p96cacs2qbuhl"},{"name":"IO复用","_id":"ckwu9ip7w002996cabx0ohsdv"},{"name":"操作系统","_id":"ckwu9ip7z002l96cac74978lb"},{"name":"Windows","_id":"ckwu9ip80002q96cafk0o705v"},{"name":"常用工具","_id":"ckwu9ip83003696ca3v2qano9"},{"name":"服务器模型","_id":"ckwu9ip84003996ca6bb66haa"},{"name":"进程","_id":"ckwu9ip84003d96cahwgx5zl1"},{"name":"apue","_id":"ckwu9ip86003v96cae0957t4x"},{"name":"设计模式","_id":"ckwu9ip89004h96ca4y2sfhnu"},{"name":"随笔","_id":"ckwu9ip8a004n96ca90k4d6d1"},{"name":"Effective C++","_id":"ckwu9ip8b004z96caeyc8fsvn"},{"name":"算法","_id":"ckwu9ip8b005296ca57cl165r"},{"name":"线程","_id":"ckwu9ip8c005b96ca15qz6s0n"},{"name":"数据结构","_id":"ckwu9ip8d005d96ca3h8j252v"},{"name":"工具","_id":"ckwu9ip8k005w96cahhnm7meq"},{"name":"git","_id":"ckwu9ip8k005x96ca6spua4of"},{"name":"软件安装","_id":"ckwu9ip8k005z96cabmupg69n"}]}}