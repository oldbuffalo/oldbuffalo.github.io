---
title: 重载
date: 2018-11-03 12:14:26
tags: C++
---

## 函数重载

多个函数拥有相同的函数名，但是参数列表不同，仅仅返回值不同不行。

参数列表包括参数的类型、参数的个数、参数顺序，只要有一个不同就叫参数列表不同。

在C语言中，如果需要实现两个数相加，但不确定类型，可能需要定义多个函数

int add1(int,int);

double add2(double,double)

在C++中，函数重载就体现了它的优势，没必要取多个函数名，有时候取名字真的是一件很麻烦的事情。

int add(int,int);

double add(double,double);

在具体调用的时候会根据传入的参数，选择对应的函数。

## 重载实现机理

C++代码在编译时会根据参数列表对函数重命名。

举个例子,int Add(int a,int b)会被重命名为Add_int_int,double Add(double a,double b)会被重命名为Add_double_double。当发生函数调用时，编译器根据传入的实参去猪哥匹配，选择对应的函数，如果匹配失败，编译器报错，这叫重载决议。也就是说本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。


## 操作符重载

对于内类的数据类型，执行一些操作很方便，譬如将两个整数相加，但是如何将两个类对象相加呢？

这时候操作符重载就派上作用了，所谓操作符重载就是运算符与类结合，产生新的定义。

注意：不能重载的运算符有 .和.*和? : 和:: 和sizeof

## 如何实现

定义成类的成员函数或者友元函数，当然如果不需要访问类中非公有成员，也不需要友元，只需定义成全局函数。

假设现在有一个Test类。

- 重载加号、减号
  第一种方式 Test operator+(const Test& );   //第一个操作数必须是类对象
  第二种方式 Test operator+(const Test&,const Test&); //定义成友元函数，解决加法交换律

  调用方式：
  1.隐式调用   obj1+obj2
  2.显式调用   obj1.operator(obj2)----成员函数   operator+(obj1,obj2)-----友元函数

  执行时 ，隐式调用和显式调用都会调用operator+()

- 重载自增，自减

  ```
  Test operator++(){ //++obj
      this->x++;
      return *this;
  }
  Test operator(int x){ //obj++
      Test temp = *this; //保存原有的状态
      this->x++;
      retrun temp;
  }
  ```

  前缀形式，通过返回*this或者自身引用，也就是返回变化之后的结果 （++obj,--obj）

  后缀形式，有一个int类型的虚参，返回的是原状态是拷贝后的临时变量。









