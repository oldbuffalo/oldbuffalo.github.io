---
title: IP协议
date: 2019-03-07 11:04:56
tags:
- 网络
- Linux高性能服务器编程
---

## 特点

IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。

无状态：IP通信双方不同步传输数据的状态信息，因此所有的IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。UDP和HTTP都是无状态

- 缺点：无法处理乱序和重复的IP数据报，因为数据报之间没有任何上下文关系
  - 比如发送端发送的第N个IP数据报可能比第N+1个数据报后到达，就造成乱序
  - 同一个IP数据报也可能经过不同的路径多次到达接收端
- 优点：简单、高效，无须为保持通信的状态分配一些内核资源，也无须每次传输数据都携带状态信息

无连接：IP通信双方不长久地维持对方的任何信息。因此，上层协议每次发送数据的时候，都必须明确指定对方的IP地址

不可靠：IP协议不能保证IP数据报准确到达接收端，只是尽最大努力交付，很多情况都能导致IP数据报发送失败。

- 某个中转路由器发现IP数据报在网络上存活时间太长(根据IP头部TTL字段)，那它将被丢弃，并返回一个ICMP错误信息(超时错误)给发送端。
- 接收端发现收到的IP数据报不正确(通过CRC校验)，它也将丢弃之，并返回一个ICMP错误信息(IP头部参数错误)给发送端。

无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议(比如TCP)需要自己实现数据确认、超时重传等机制来达到可靠传输的目的。

<!--more -->

## IPv4头部

![](/pic/IPv4头部.png)

4位版本号：指定IP协议的版本。对IPv4来说，值是4。其他IPv4协议的扩展版本(如SIP协议和PIP协议)则具有不同的版本号(头部也和上图不一样)

4位头部长度：标识该IP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以IP头部最长是60字节

8位服务类型：包括一个3位的优先权字段（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。4位的TOS字段分别表示：最小延时、最大吞吐量、最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要设置。比如像ssh和telnet这样的登录程序需要最小延时服务，文件传输程序则需要最大吞吐量服务。

16位总长度：整个IP数据报的长度，以字节为单位，因此IP数据报最大长度时65535字节，但由于MTU的限制，长度超过MTU的数据报都将被分片传输。

16位标识：唯一地标识主机发送的每一个数据报。其初始值由系统随机生成，每发送一个数据包，值就加1.该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都有相同的标识值。

3位标志字段：第一位保留，第二位表示“禁止分片”，在这种情况下，如果IP数据报长度超过MTU，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位表示“更多分片”，除了数据报的最后一个分片外，其他分片都要置1

13位分片偏移：是分片相对原始IP数据报开始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位(乘8)后得到的，由于这个原因，**除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍**。

8位生存时间（TTL）：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(通常是64)，数据报每经过一个路由，值就减1。减到0的时候就丢弃数据报，返回ICMP差错报文，**TTL的值可以防止数据报陷入路由循环**。

8位协议：用来区分上层协议。ICMP是1，TCP是6，UDP是17

16位头部校验和：由发送端填充，接收端对其使用CRC算法以验算IP数据报头部(只检验头部)在传输过程中是否损坏

32位的源端IP和目的端IP用来标识数据报的发送端和接收端。

IPv4最后一个字段是可变长的可选信息。最多包含40字节，列举常用的，更多可以看RFC 1393

- 记录路由，告诉数据报途径的所有路由器都将自己的IP地址填入IP头部的选项部分，就可以跟踪数据报的传递路径
- 时间戳：告诉每个路由器都将数据报被转发的时间(或时间与IP对)填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间
- 松散源路由选择：指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器
- 严格源路由选择：和松散源路由选择类似，不过数据报只能经过指定的路由器

## tcpdump抓包

在用telnet远程登录的时候，遇到一些问题。

![](/pic/telnet问题.png)

提示我无法连接到远程主机，连接被拒绝，上网查了一下发现telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。因此需要打开telnet服务。

1.安装openbsd-inetd

sudo apt-get install openbsd-inetd

2.安装telnetd

sudo apt-get install telnetd

3.重启openbsd-inetd

sudo /etc/init.d/openbsd-inetd restart

4.查看telnet运行状态     没开启之前输出为空

sudo netstat -a | grep telnet

![](/pic/telnet测试.png)

这时候开始进行抓包

sudo tcpdump -i lo -ntx    #抓取本地回路上的数据包

开启另外一个终端执行telnet命令

![](/pic/IP抓包telnet.png)

用tcpdump抓取到的第一个关于telmet的数据包(开头有两个DNS请求和应答的数据包)

![](/pic/IP抓包tcpdump.png)

该数据包描述的是一个IP数据报，由于使用telnet登录本机，所以IP数据报的源端IP地址和目的端IP地址都是

“127.0.0.1”。telnet服务器程序使用的端口号是23，而telnet客户端程序使用临时端口号34620与服务器通信。

"Flags"、“seq”、“win”、“options”都是TCP头部的信息，这里不展开。“length”描述的是IP数据报所携带的应用程序数据的长度。

由上图可知，这个数据包共60字节，其中前20字节是IP头部，后40字节是TCP头部，不包含应用程序数据

分析IP头部：

| 十六进制数 | 十进制表示 | IP头部信息                   |
| ---------- | :--------- | :--------------------------- |
| 0x4        | 4          | IP                           |
| 0x5        | 5          | 头部长度为5个32位(20字节)    |
| 0x10       |            | TOS选项中最小延时服务被开启  |
| 0x003c     | 60         | 数据报总长度，60字节         |
| 0x3174     |            | 数据报标识                   |
| 0x4        |            | 设置了禁止                   |
| 0x000      | 0          | 分片偏移                     |
| 0x40       | 64         | TTL被设为64                  |
| 0x06       | 6          | 协议字段为6，表示上层协议是T |
| 0x0b36     |            | IP头部校验和                 |
| 0x7f000001 |            | 32位源端IP地址127.0.0.1      |
| 0x7f000001 |            | 32位目的端IP地址127.0.0.1    |

由此可见，IPv4头部结构和分析的完全吻合，并且知道了telnet服务选择使用具有最小延时的服务，并且默认使用的传输层协议是TCP协议，并且这个IP数据报没有分片，因为它没有携带任何应用程序数据。

## IP分片

![](/pic/IP分片.png)

第一个IP分片长度1500字节，IP头部设置了MF标志

第二个IP分片长度21字节，没有设置MF标志，因为已经是最后一个分片

需要注意的是：第二个IP分片里面没有ICMP的头部信息，因为IP模块重组ICMP报文的只需要一份ICMP头部信息

通过抓包来分析IP分片

ping www.baidu.com -s 1473     #指定放1473字节的数据

抓包的IP数据包如下：

![](/pic/IP分片抓包.png)

这两个数据包标识值都是46843，说明他们是同一个IP数据报的分片。第一个分片的片偏移值是0，而第二个是1480。第一个分片设置了MF标志标识(flags[+])还有后续分片,第二个没设置说明是最后一个分片。两个分片的长度分别是1500和21字节。

由此可见，通过tcpdump抓包的分析和图片的分析完全一致。

## IP路由

IP协议的核心任务是数据报的路由，也就是决定数据报到目标机器的路径。

#### 工作流程图

![](/pic/IP模块工作流程图.png)

此图的具体分析可以参考游双老师的《Linux高性能服务器编程》P23

#### 路由机制

首先了解一下路由表，可以用route命令或者netstat查看

![](/pic/route命令.png)

各个字段的解释：

![](/pic/路由表.png)

接下来需要考虑的问题：路由表如何按照IP地址进行分类？或者说给定数据报的IP地址，将匹配路由表中的哪一项？这也就是IP的路由机制，有三个步骤。

- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址。如果找到，就使用路由项，没找到就跳转步骤2
- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址(例如route命令展示的路由表的第三项)，如果找到就使用该路由项，没找到就跳转步骤3
- 选择默认路由项，这通常意味着数据报的下一跳路由是网关

也就是说，对于本机，所有发送到IP地址为192.168.152.*的机器的IP数据报都可以直接发送到目标机器，而所有访问因特网的请求都将通过网关来转发。

#### 路由表更新

可以用route命令来修改路由表(路由缓存  加-C选项)

sudo route add -host 192.168.152.1 dev ens33  

添加主机192.168.152.1对应的路由项，以后所有从本机发送到192.168.152.1的IP数据报将通过网卡ens33直接发送到目标机器的接收网卡。

sudo route del -net 192.168.152.0 netmask 255.255.255.0

删除网络192.168.152.0对应的路由项，这样主机就无法访问该局域网上的任何其他机器

sudo route del  default

删除默认路由项，这样就无法访问因特网



通过route命令和其他工具修改的路由表，都是静态的路由更新方式。对于大型路由器，通常是通过BGP、RIP、OSPF等协议来发现路径，并更新自己的路由表，这样式动态的、自动的。

#### IP转发

路由器都能执行数据报的转发操作，而主机一般只能发送和接收数据报，因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。

可以修改这个参数使主机具有数据报转发能力

1.用root身份   sudo  su

2.echo 1 > /proc/sys/net/ipv4/ip_forward

路由器或主机进行数据报转发的操作：

- 检查数据报头部的TTL值，为0就丢弃
- 查看数据报头部的严格源路由选择项。如果该选项被设置，就检测数据报的目标IP是否是本机的某个IP地址，如果不是，则发送一个ICMP源站选路失败报文给发送端。
- 如果有必要，就给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一个路由器
- 将TTL值减1
- 处理IP头部选项
- 如果有必要，则执行IP分片操作

#### 重定向

![](/pic/ICMP重定向报文.png)

重定向报文类型值是5，代码字段有4个可选值，代表不同的重定向类型。

/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文

/proc/sys/net/ipv4/conf/all/accept_redirects内核参数指定是否允许接收ICMP重定向报文

一般，主机只能接收，路由器只能发送。

## IPv6（RFC 2460）

不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如

- 增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制
- 引入自动配置功能，使得局域网管理更方便
- 增加专门的网络安全功能

![](/pic/IPv6头部.png)

4位版本号：指定IP协议的版本。对IPv6来说，值是6

8位通信类型：指定数据流通信类型或优先级，和IPv4中的TOS类似

20位流标签：IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输

16位净荷长度：IPv6扩展头部和应用程序数据长度之和，不包括固定头部长度

8位下一个包头：指出紧跟IPv6固定头部后的包头类型，如扩展头或某个上层协议头

8位跳数限制：类似于IPv4中的TTL

IPv6用128位(16字节)来表示IP地址，IP地址总数达到2^128个

32位表示的IPv4地址一般用点分十进制来表示，而IPv6地址一般用十六进制字符串来表示

"FE80:0000:0000:0000:1234 :5678:0000:0012"用：分割成8组，每组16位

"FE80:​:1234 :5678:0000:0012​" 零压缩法------省略连续的、全零的组，一个地址中只能用一次，所以后面的零没压缩

IPv6扩展头部

![](/pic/IPv6扩展头部.png)

