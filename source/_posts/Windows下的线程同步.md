---
title: Windows下的线程同步
date: 2018-11-07 19:02:33
tags: 
- 操作系统
- Windows
---

## 引言

线程可以共享进程的资源，这是一件很好的事情，便于线程之间通信。但是，同时对全局资源进行操作，也容易造成一些问题。例如，两根线程同时对一个全局变量进行++操作，假如初值为0，线程A加1000次，线程B加1000次，结果很有可能不是我们想象中的2000。因为某个线程加完之后还没写入内存，另一根线程就读出了之前的数，这就会造成加的次数减少，导致最后的值小于2000。这是个很简单的例子，但是警示我们在多线程编程中，同时操作全局资源，要注意线程同步的问题。
<!-- more -->

## 线程同步：让线程协调一致地工作，有序访问全局资源，保证资源完整性。

## Windows下线程互斥和同步的方式

​互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的  访问顺序，即访问是无序的。

​同步: 在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源，如“第一类读写者模型”。

​同步包括互斥，互斥其实是一种特殊的同步

1. **原子访问**     利用Interlocked系列函数    只能对一个变量进行原子操作

- 增减操作    返回变量执行增减操作之后的值

​InterlockedIncrement

​InterlockedDecrement

​ InterlockedExchangeAdd 返回运算后的值，注意！加个负数就是减。

- 赋值操作

​InterlockedExchange函数会返回原先的值。

2. **关键段(临界区) **  让多行代码以原子方式对资源进行操作   CRITICAL_SECTION (结构体)

​初始化:InitializeCriticalSection               销毁:  DeleteCriticalSection
​进入：EnterCriticalSection                     离开：LeaveCriticalSection
​尝试进入：TryEnterCriticalSection
​初始化旋转锁:  InitializeCriticalSectionAndSpinCoun
​设置旋转锁次数:SetCriticalSectionSpinCount

- 直接阻塞     
  ​	对于一个线程在访问临界区，别的想要访问的线程会从用户态切到内核态，一旦那个线程离开，阻塞的线程就切换到可调度状态，这样来回切换状态开销大，效率不高

- 旋转锁    拿不到锁不马上阻塞，而是等待一段时间再阻塞
- 异步处理  TryEnter   尝试着拿锁，拿不到就处理别的工作

注意点:如果在关键段中途离开，离开之前需要解开关键段。

3. **互斥量** 内核对象  通过句柄操作   配合 WaitForSingleObject使用

互斥对象包含使用计数、线程ID以及一个递归计数(占有互斥量的次数)
创建:CreateMutex
进入:WaitForSingleObject  等互斥量
释放:ReleaseMutex
跨进程操作:OpenMutex    通过创建时候的最后一个参数：名字


4. **事件** 内核对象 通过句柄操作

创建:CreateEvent    注意创建的是人工事件还是自动事件，初始化是有事件还是没有事件
进入:WaitForSingleObject  等事件  如果是自动事件自动变成无事件，如果是人工，需要手动置成无事件  
设置成有事件:SetEvent       设置成无事件:ResetEvent
跨进程操作:OpenEvent

​注意点：如果是人工事件，设置成有信号不变回去的话，所有的线程都能共享资源。适合通知的场合，如果    需要线程之间互斥，则设置成自动事件。

5.  **信号量** 内核对象  通过句柄操作
创建:CreateSemaphore    注意初始化的信号量个数以及信号量的最大值(不一定是线程个数，看情况而定)
​进入:WaitForSingleObject    等信号量
​释放:ReleaseSemaphore
​跨进程操作:OpenSemaphore
​注意点:1.一次释放信号量个数不允许超过最大值2.分多次释放信号量，如果总和超过最大值，就取最大值

## 误区

volatile并不能实现线程同步，只是防止编译优化，每次都要求从内存中读取值。

### 它们之间的区别

码一个整理得不错的[博客](https://blog.csdn.net/morewindows/article/details/7538247)

原子访问局限性比较大，只能作用于变量，因此使用范围不是很广泛。

关键段只能在同一个进程中实现线程同步，而其余三个内核对象都可以实现跨进程。如果是同一进程中进行线程同步，建议用临界区，因为更节省系统资源，更有效率，因为关键段是用户模式下的同步对象内核对象的缺点是性能。要从用户态切换到内核态，开销大。有线程所有权概念，可以实现互斥，但实现不了同步。

互斥量有线程所有权，谁创建谁有优先选择权，可以实现互斥，实现不了同步。能很好地处理"遗弃"问题

“遗弃”问题就是占有某种资源的进程意外终止后，其它等待该资源的进程能否感知

事件有人工事件，可以同时让多个线程做事，但是指定不了个数，而信号量可以指定个数



