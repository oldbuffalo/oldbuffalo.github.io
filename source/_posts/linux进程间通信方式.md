---
title: Linux进程间通信方式
date: 2019-03-13 20:52:05
tags:
- Linux
- 操作系统
- 进程
- apue
---

## 进程间通信(InterProcess Communication)

当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程同步的问题，确保任一时刻只有一个进程可以拥有对资源的独占式访问。

程序对共享资源访问的代码只是很短的一段，但就是这一段代码引发了进程之间的竞态条件，那么这段代码称为关键段，也叫临界区。

进程间通信大体思路有两种：1.数据传递(通过内核)  2.共享内存



#### 管道

```
int pipe(int fd[2]);   //成功返回0  出错返回-1
```

局限性：

- 半双工(数据只能在一个方向上流动)。现在UNIX域套接字默认是全双工的(通过socketpair创建)
- 只能在具有公共祖先的两个进程之间使用。一般都是一个进程先调用pipe，然后调用fork
  - 父进程把文件描述符传给子进程之后父子进程 之间通信
  - 也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信

- 缓冲区有限（在管道创建时，为缓冲区分配一个页面大小），常量PIPE_BUF决定

![](/pic/fork之后的管道.png)

fork之后做什么取决于我们想要的数据流方向。对于从父进程到子进程的管道，父进程关闭管道的读端(fd[0])，子进程关闭管道的写端(fd[1])。

![](/pic/从父到子的管道.png)

使用注意事项(假设都是阻塞I/O操作)：

- 当读一个写端被关闭的管道(引用计数为0)，在所有数据都被读取后，read返回0，表示文件结束。
- 如果写端没有被关闭，这时有进程从管道读数据，那么管道中剩余的数据被读取完之后，再次调用read将阻塞，直到持有写端的进程向管道中写入数据
- 当对于一个读端被关闭的管道进行写操作，将产生SIGPIPE信号，默认动作终止进程。如果忽略该信号或者捕捉该信号并从其处理程序返回，write返回-1，并设置errno为EPIPE
- 如果读端没有被关闭，持有读端的进程也没有读数据，这是写端向管道写数据，管道被写满时再次调用write将阻塞，知道有数据被read才能继续写入

PIPE_BUF规定了内核的管道缓冲区大小。

如果对管道调用write，并且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道(或者FIFO)的write交叉进行。

如果有多个进程同时写一个管道(或者FIFO)，而且要求写的字节数超过PIPE_BUF,那么所写的数据可能会与其他进程所写的数据相互交叉。   //有待实验

用pathconf或者fpathconf函数可以确定PIPE_BUF的值。  

