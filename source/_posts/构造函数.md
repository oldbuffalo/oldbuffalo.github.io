---
title: 构造函数
date: 2018-11-02 12:52:10
tags: C++
---

## 构造函数介绍

构造函数：类通过一个或几个特殊的成员函数来控制其成员对象的初始化过程。

特点：1. 没有返回类型  2. 支持重载  3. 不能被声明成const(这一点还不是很理解 先码上 C++Primer p235) 4.无法被子类继承

既然构造函数也是函数，那么什么时候调用构造函数？

答案：对象被创建的时候。

构造函数执行顺序: ①传参  ②给类数据成员开辟空间   ③执行冒号语法给数据成员初始化  ④执行构造函数括号里面的内容
<!-- more -->


如果不指定构造函数，编译器会默认生成一个构造函数，拷贝构造函数(浅拷贝)，析构函数,重载=操作符函数。

当我们不需要编译器生成的这么函数时，就需要自己显式地声明出来。通过利用这点我们就可以限制对象的产生，例如，我们将默认构造函数，拷贝构造函数声明为私有，就可以防止外界来产生这个对象，这点主要是在单例模式中使用。

如果我们需要默认的构造函数可以用    类名()=default;  //C++11新特性

## 初始化成员对象的方式

1. 构造函数里赋值
2. 初始化列表
3. 类内直接初始化(C++11新特性）

**需要注意的是：const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化(编译器不支持的话就只能选用前者)**

例如:

```c++
class A{
    int x;
    A(int y){x = y;}
};
class B{
    A a;
    const int b;
    int &c;
    static int si;
    static const int sci;
    static const int sci2 = 100;
    static const double  = 99.9 //error 
    //在vs2012中只有静态常量整型才能在类中初始化
    B():a(100),b(10),c(c.a){}
}; 
int B::si = 1;
const int B::sci = 2;

```

由此可见，初始化列表和构造函数赋值完成的是同样的工作，但是有的工作构造函数做不了，因此最好使用初始化列表，整理一下理由。

1. const类型的成员、引用以及只有带参数构造的类成员 必须使用初始化列表或者类内直接初始化
2. 效率更高，这涉及初始化和赋值关于底层效率的问题。如果在类的构造函数中赋值，在成员初始化时会调用一次默认的构造函数，在函数体中赋值又调用一次。而利用初始化列表仅调用一次。

## 成员变量初始化顺序

用初始化列表进行初始化，是按照变量声明的顺序进行初始化

```
class T{
  int x;
  int y;
  T(int val):y(val),x(y+1){}  
};   
//输出x=-858993459,y=10 
```

可见x是一个未定义的值，这是因为编译器先初始了x，因为x先定义，此时y还没有被初始化为10。由此可见变量初始化的顺序跟变量在内存中的顺序有关。

解决方案：1.保持声明和初始化顺序一致 2.使用构造函数赋值

**需要注意的点：static成员变量必须在类外初始化**

为什么？

因为在类外定义和初始化是保证static成员变量只被定义一次的好方法，static变量的生命期与类对象是异步的，这也是可以用作用域访问静态成员变量的原因。如果在类内初始化，让静态成员变量依赖于类对象，就无所谓静态两字了。

继承关系的初始化顺序：

1. 基类的静态成员
2. 派生类的静态成员
3. 基类的成员变量
4. 派生类的成员变量

当派生类中不含对象成员时:

构造执行顺序: 基类->派生类(构造函数无法被继承，为了继承父类中的成员变量，要先调用父类的构造)

析构执行顺序：派生类->基类

当派生类中含有对象成员时：
构造执行顺序:基类->对象成员构造->派生类(类成员初始化总在构造函数执行之前)

析构执行顺序:派生类->对象成员析构->基类

## 扩展

关于构造函数，C++11新特性还有一个委托构造函数，大致想法就是使用别的构造函数来实现自己。(C++ primer 261)

